<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Geomorphometric analysis - WhiteboxTools User Manual</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../preface.html">Preface</a></li><li><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="../install.html"><strong aria-hidden="true">2.</strong> Setting Up WhiteboxTools</a></li><li><a href="../using_whiteboxtools.html"><strong aria-hidden="true">3.</strong> Using WhiteboxTools</a></li><li><ol class="section"><li><a href="../command_prompt.html"><strong aria-hidden="true">3.1.</strong> Command-line interface</a></li><li><a href="../python_scripting/scripting.html"><strong aria-hidden="true">3.2.</strong> Interfacing with Python</a></li><li><ol class="section"><li><a href="../python_scripting/using_whitebox_tools.html"><strong aria-hidden="true">3.2.1.</strong> Using whitebox_tools.py</a></li><li><a href="../python_scripting/tool_output.html"><strong aria-hidden="true">3.2.2.</strong> Handling tool output</a></li><li><a href="../python_scripting/additional_functions.html"><strong aria-hidden="true">3.2.3.</strong> Additional functions</a></li><li><a href="../python_scripting/example.html"><strong aria-hidden="true">3.2.4.</strong> An example Python project</a></li></ol></li><li><a href="../r_interface.html"><strong aria-hidden="true">3.3.</strong> Interfacing with R</a></li><li><a href="../whitebox_tools_runner.html"><strong aria-hidden="true">3.4.</strong> WhiteboxTools Runner</a></li><li><a href="../qgis_plugin.html"><strong aria-hidden="true">3.5.</strong> QGIS plugin</a></li><li><a href="../arcgis_plugin.html"><strong aria-hidden="true">3.6.</strong> ArcGIS plugin</a></li></ol></li><li><a href="../available_tools/index.html"><strong aria-hidden="true">4.</strong> Tools Reference</a></li><li><ol class="section"><li><a href="../available_tools/data_tools.html"><strong aria-hidden="true">4.1.</strong> Data tools</a></li><li><a href="../available_tools/geomorphometric_analysis.html" class="active"><strong aria-hidden="true">4.2.</strong> Geomorphometric analysis</a></li><li><a href="../available_tools/gis_analysis.html"><strong aria-hidden="true">4.3.</strong> GIS analysis</a></li><li><ol class="section"><li><a href="../available_tools/gis_analysis_distance_tools.html"><strong aria-hidden="true">4.3.1.</strong> Distance tools</a></li><li><a href="../available_tools/gis_analysis_overlay_tools.html"><strong aria-hidden="true">4.3.2.</strong> Overlay tools</a></li><li><a href="../available_tools/gis_analysis_patch_shape_tools.html"><strong aria-hidden="true">4.3.3.</strong> Patch shape tools</a></li></ol></li><li><a href="../available_tools/hydrological_analysis.html"><strong aria-hidden="true">4.4.</strong> Hydrological analysis</a></li><li><a href="../available_tools/image_processing_tools.html"><strong aria-hidden="true">4.5.</strong> Image processing tools</a></li><li><ol class="section"><li><a href="../available_tools/image_processing_tools_filters.html"><strong aria-hidden="true">4.5.1.</strong> Filters</a></li><li><a href="../available_tools/image_processing_tools_image_enhancement.html"><strong aria-hidden="true">4.5.2.</strong> Image enchancement</a></li></ol></li><li><a href="../available_tools/lidar_tools.html"><strong aria-hidden="true">4.6.</strong> LiDAR tools</a></li><li><a href="../available_tools/mathand_stats_tools.html"><strong aria-hidden="true">4.7.</strong> Mathematical and statistical analysis</a></li><li><a href="../available_tools/stream_network_analysis.html"><strong aria-hidden="true">4.8.</strong> Stream network analysis</a></li></ol></li><li><a href="../tutorials/index.html"><strong aria-hidden="true">5.</strong> Tutorials</a></li><li><ol class="section"><li><a href="../tutorials/lidar.html"><strong aria-hidden="true">5.1.</strong> Processing LiDAR data</a></li></ol></li><li><a href="../supported_formats.html"><strong aria-hidden="true">6.</strong> Supported Data Formats</a></li><li><a href="../contributing.html"><strong aria-hidden="true">7.</strong> Contributing and Reporting Bugs</a></li><li><a href="../limitations.html"><strong aria-hidden="true">8.</strong> Limitations</a></li><li><a href="../license.html"><strong aria-hidden="true">9.</strong> License</a></li><li><a href="../faq.html"><strong aria-hidden="true">10.</strong> Frequently Asked Questions</a></li><li><a href="../tool_index.html"><strong aria-hidden="true">11.</strong> Tool Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">WhiteboxTools User Manual</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#geomorphometric-analysis" id="geomorphometric-analysis"><h1>Geomorphometric Analysis</h1></a>
<ul>
<li><a href="#Aspect">Aspect</a></li>
<li><a href="#AverageNormalVectorAngularDeviation">AverageNormalVectorAngularDeviation</a></li>
<li><a href="#CircularVarianceOfAspect">CircularVarianceOfAspect</a></li>
<li><a href="#DevFromMeanElev">DevFromMeanElev</a></li>
<li><a href="#DiffFromMeanElev">DiffFromMeanElev</a></li>
<li><a href="#DirectionalRelief">DirectionalRelief</a></li>
<li><a href="#DownslopeIndex">DownslopeIndex</a></li>
<li><a href="#DrainagePreservingSmoothing">DrainagePreservingSmoothing</a></li>
<li><a href="#EdgeDensity">EdgeDensity</a></li>
<li><a href="#ElevAbovePit">ElevAbovePit</a></li>
<li><a href="#ElevPercentile">ElevPercentile</a></li>
<li><a href="#ElevRelativeToMinMax">ElevRelativeToMinMax</a></li>
<li><a href="#ElevRelativeToWatershedMinMax">ElevRelativeToWatershedMinMax</a></li>
<li><a href="#FeaturePreservingDenoise">FeaturePreservingDenoise</a></li>
<li><a href="#FetchAnalysis">FetchAnalysis</a></li>
<li><a href="#FillMissingData">FillMissingData</a></li>
<li><a href="#FindRidges">FindRidges</a></li>
<li><a href="#Hillshade">Hillshade</a></li>
<li><a href="#HorizonAngle">HorizonAngle</a></li>
<li><a href="#HypsometricAnalysis">HypsometricAnalysis</a></li>
<li><a href="#MaxAnisotropyDev">MaxAnisotropyDev</a></li>
<li><a href="#MaxAnisotropyDevSignature">MaxAnisotropyDevSignature</a></li>
<li><a href="#MaxBranchLength">MaxBranchLength</a></li>
<li><a href="#MaxDifferenceFromMean">MaxDifferenceFromMean</a></li>
<li><a href="#MaxDownslopeElevChange">MaxDownslopeElevChange</a></li>
<li><a href="#MaxElevDevSignature">MaxElevDevSignature</a></li>
<li><a href="#MaxElevationDeviation">MaxElevationDeviation</a></li>
<li><a href="#MinDownslopeElevChange">MinDownslopeElevChange</a></li>
<li><a href="#MultiscaleRoughness">MultiscaleRoughness</a></li>
<li><a href="#MultiscaleRoughnessSignature">MultiscaleRoughnessSignature</a></li>
<li><a href="#MultiscaleStdDevNormals">MultiscaleStdDevNormals</a></li>
<li><a href="#MultiscaleTopographicPositionImage">MultiscaleTopographicPositionImage</a></li>
<li><a href="#NumDownslopeNeighbours">NumDownslopeNeighbours</a></li>
<li><a href="#NumUpslopeNeighbours">NumUpslopeNeighbours</a></li>
<li><a href="#PennockLandformClass">PennockLandformClass</a></li>
<li><a href="#PercentElevRange">PercentElevRange</a></li>
<li><a href="#PlanCurvature">PlanCurvature</a></li>
<li><a href="#Profile">Profile</a></li>
<li><a href="#ProfileCurvature">ProfileCurvature</a></li>
<li><a href="#RelativeAspect">RelativeAspect</a></li>
<li><a href="#RelativeStreamPowerIndex">RelativeStreamPowerIndex</a></li>
<li><a href="#RelativeTopographicPosition">RelativeTopographicPosition</a></li>
<li><a href="#RemoveOffTerrainObjects">RemoveOffTerrainObjects</a></li>
<li><a href="#RuggednessIndex">RuggednessIndex</a></li>
<li><a href="#SedimentTransportIndex">SedimentTransportIndex</a></li>
<li><a href="#Slope">Slope</a></li>
<li><a href="#SlopeVsElevationPlot">SlopeVsElevationPlot</a></li>
<li><a href="#SphericalStdDevOfNormals">SphericalStdDevOfNormals</a></li>
<li><a href="#StandardDeviationOfSlope">StandardDeviationOfSlope</a></li>
<li><a href="#SurfaceAreaRatio">SurfaceAreaRatio</a></li>
<li><a href="#TangentialCurvature">TangentialCurvature</a></li>
<li><a href="#TotalCurvature">TotalCurvature</a></li>
<li><a href="#Viewshed">Viewshed</a></li>
<li><a href="#VisibilityIndex">VisibilityIndex</a></li>
<li><a href="#WetnessIndex">WetnessIndex</a></li>
</ul>
<p><a name="Aspect"></a></p>
<a class="header" href="#aspect" id="aspect"><h1>Aspect</h1></a>
<p>This tool calculates slope aspect (i.e. slope orientation in degrees clockwise from north) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>aspect = 180 - arctan(f<sub>y</sub> / f<sub>x</sub>) + 90(f<sub>x</sub> / |f<sub>x</sub>|)</p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / 8 * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.aspect(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Aspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="AverageNormalVectorAngularDeviation"></a></p>
<a class="header" href="#averagenormalvectorangulardeviation" id="averagenormalvectorangulardeviation"><h1>AverageNormalVectorAngularDeviation</h1></a>
<p>This tool characterizes the spatial distribution of the average normal vector angular deviation, a measure of
surface roughness. Working in the field of 3D printing, Ko et al. (2016) defined a measure of surface roughness
based on quantifying the angular deviations in the direction of the normal vector of a real surface from its ideal
(i.e. smoothed) form. This measure of surface complexity is therefore in units of degrees. Specifically, roughness
is defined in this study as the neighborhood-averaged difference in the normal vectors of the original DEM and a
smoothed DEM surface. Smoothed surfaces are derived by applying a Gaussian blur of the same size as the
neighborhood (<code>--filter</code>).</p>
<p>The <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a> tool calculates the same measure of surface roughness, except that it is designed to
work with multiple spatial scales.</p>
<p><em>Reference</em>:</p>
<p>Ko, M., Kang, H., ulrim Kim, J., Lee, Y., &amp; Hwang, J. E. (2016, July). How to measure quality of affordable 3D
printing: Cultivating quantitative index in the user community. In International Conference on Human-Computer
Interaction (pp. 116-121). Springer, Cham.</p>
<p>Lindsay, J. B., &amp; Newman, D. R. (2018). Hyper-scale analysis of surface roughness. PeerJ Preprints, 6, e27110v1.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_normal_vector_angular_deviation(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageNormalVectorAngularDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/average_normal_vector_angular_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><a name="CircularVarianceOfAspect"></a></p>
<a class="header" href="#circularvarianceofaspect" id="circularvarianceofaspect"><h1>CircularVarianceOfAspect</h1></a>
<p>This tool can be used to calculate the circular variance (i.e. one minus the mean resultant length) of aspect
for an input digital elevation model (DEM). This is a measure of how variable slope aspect is within a local
neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a> is therefore a measure of <strong>surface
shape complexity</strong>, or texture. It will take a value of 0.0 for smooth sites and near 1.0 in areas of high surface
roughness or complex topography.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular variance, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, the metric should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <strong><em>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</em></strong> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.circular_variance_of_aspect(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CircularVarianceOfAspect -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/circular_variance_of_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><a name="DevFromMeanElev"></a></p>
<a class="header" href="#devfrommeanelev" id="devfrommeanelev"><h1>DevFromMeanElev</h1></a>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood, normalized by standard
deviation. Therefore, this index of topographic residual is essentially equivalent to a
local z-score. This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the deviation from mean elevation (DEV) at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool can be used to output the per-pixel maximum DEV
value across a range of input scales.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.dev_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DevFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/dev_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/06/2017</p>
<p><a name="DiffFromMeanElev"></a></p>
<a class="header" href="#difffrommeanelev" id="difffrommeanelev"><h1>DiffFromMeanElev</h1></a>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood. This is similar to what a high-pass
filter calculates for imagery data, but is intended to work with DEM data instead. This attribute
measures the <em>relative topographic position</em>. <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the DIFF at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a> tool can be used to output the per-pixel maximum DIFF
value across a range of input scales.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.diff_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiffFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/diff_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="DirectionalRelief"></a></p>
<a class="header" href="#directionalrelief" id="directionalrelief"><h1>DirectionalRelief</h1></a>
<p>This tool calculates the relief for each grid cell in a digital elevation model (DEM) in a specified direction.
Directional relief is an index of the degree to which a DEM grid cell is higher or lower than its surroundings.
It is calculated by subtracting the elevation of a DEM grid cell from the average elevation of those cells which
lie between it and the edge of the DEM in a specified compass direction. Thus, positive values indicate that a
grid cell is lower than the average elevation of the grid cells in a specific direction (i.e. relatively sheltered),
whereas a negative directional relief indicates that the grid cell is higher (i.e. relatively exposed). The
algorithm is based on a modification of the procedure described by Lapen and Martz (1993). The modifications
include: (1) the ability to specify any direction between 0-degrees and 360-degrees (<code>--azimuth</code>), and (2) the ability to use
a distance-limited search (<code>--max_dist</code>), such that the ray-tracing procedure terminates before the DEM edge is
reached for longer search paths. The algorithm works by tracing a ray from each grid cell in the direction of
interest and evaluating the average elevation along the ray. Linear interpolation is used to estimate the elevation
of the surface where a ray does not intersect the DEM grid precisely at one of its nodes. The user must specify the
name of an input DEM raster file, the output raster name, and a hypothetical wind direction. Furthermore, the user
is able to constrain the maximum search distance for the ray tracing. If no maximum search distance is specified,
each ray will be traced to the edge of the DEM. The units of the output image are the same as the input DEM.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate
for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued grid cells in the
input image will be assigned NoData values in the output image. The output raster is of the float data type and
continuous data scale. Directional relief is best displayed using the blue-white-red bipolar palette to distinguish
between the positive and negative values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#fetchanalysis"><strong>FetchAnalysis</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees</td></tr>
<tr><td>--max_dist         </td><td> Optional maximum search distance (unspecified if none; in xy units)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.directional_relief(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DirectionalRelief -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/directional_relief.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="DownslopeIndex"></a></p>
<a class="header" href="#downslopeindex" id="downslopeindex"><h1>DownslopeIndex</h1></a>
<p>This tool can be used to calculate the downslope index described by Hjerdt et al. (2004).
The downslope index is a measure of the slope gradient between a grid cell and some
downslope location (along the flowpath passing through the upslope grid cell) that
represents a specified vertical drop (i.e. a potential head drop). The index has been
shown to be useful for hydrological, geomorphological, and biogeochemical applications.</p>
<p>The user must specify the name of a digital elevaton model (DEM) raster. This DEM
should be have been pre-processed to remove artifact topographic depressions and flat
areas. The user must also specify the head potential drop (d), and the output type. The
output type can be either '<code>tangent</code>', '<code>degrees</code>', '<code>radians</code>', or '<code>distance</code>'. If
'<code>distance</code>' is selected as the output type, the output grid actually represents the
downslope flowpath length required to drop d meters from each grid cell. Linear
interpolation is used when the specified drop value is encountered between two adjacent
grid cells along a flowpath traverse.</p>
<p>Notice that this algorithm is affected by edge contamination. That is, for some grid cells,
the edge of the grid will be encountered along a flowpath traverse before the specified
vertical drop occurs. In these cases, the value of the downslope index is approximated by
replacing d with the actual elevation drop observed along the flowpath. To avoid this problem,
the entire watershed containing an area of interest should be contained in the DEM.</p>
<p>Grid cells containing NoData values in any of the input images are assigned the NoData
value in the output raster. The output raster is of the float data type and continuous
data scale.</p>
<p><em>Reference</em>:</p>
<p>Hjerdt, K.N., McDonnell, J.J., Seibert, J. Rodhe, A. (2004) <em>A new topographic index to
quantify downslope controls on local drainage</em>, <strong>Water Resources Research</strong>, 40, W05602,
doi:10.1029/2004WR003130.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--drop             </td><td> Vertical drop value (default is 2.0)</td></tr>
<tr><td>--out_type         </td><td> Output type, options include 'tangent', 'degrees', 'radians', 'distance' (default is 'tangent')</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.downslope_index(
    dem, 
    output, 
    drop=2.0, 
    out_type=&quot;tangent&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DownslopeIndex -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=dsi.tif --drop=5.0 --out_type=distance 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/downslope_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 17, 2017</p>
<p><a name="DrainagePreservingSmoothing"></a></p>
<a class="header" href="#drainagepreservingsmoothing" id="drainagepreservingsmoothing"><h1>DrainagePreservingSmoothing</h1></a>
<p>This tool implements a modified form of the algorithm described by
Sun, Rosin, Martin, and Langbein (2007) '<em>Fast and effective feature-preserving
mesh denoising</em>'. This implimentation varies the threshold angle between
neighbouring grid cell normal vectors, used during the smoothing operation. The
threshold is varied as a function of how low-lying a site is. This varying
smoothing level better preserves small drainage features, such as ditches,
rills, gullies, etc., which would otherwise be smoothed over.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#featurepreservingdenoise"><strong>FeaturePreservingDenoise</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--num_iter         </td><td> Number of iterations</td></tr>
<tr><td>--max_diff         </td><td> Maximum allowable absolute elevation change (optional)</td></tr>
<tr><td>--reduction        </td><td> Maximum Amount to reduce the threshold angle by (0 = full smoothing; 100 = no smoothing)</td></tr>
<tr><td>--dfm              </td><td> Difference from median threshold (in z-units), determines when a location is low-lying</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.drainage_preserving_smoothing(
    dem, 
    output, 
    filter=11, 
    norm_diff=15.0, 
    num_iter=3, 
    max_diff=0.5, 
    reduction=80.0, 
    dfm=0.15, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DrainagePreservingSmoothing -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --filter=15 ^
--norm_diff=20.0 --num_iter=4 --reduction=90.0 --dfm=0.15 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/drainage_preserving_smoothing.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay and Anthony Francioni</p>
<p><em>Created</em>: 06/09/2018</p>
<p><a name="EdgeDensity"></a></p>
<a class="header" href="#edgedensity" id="edgedensity"><h1>EdgeDensity</h1></a>
<p>This tool calculates the density of edges, or breaks-in-slope within an input digital elevation model (DEM).
A break-in-slope occurs between two neighbouring grid cells if the angular difference between their normal
vectors is greater than a user-specified threshold value (<code>--norm_diff</code>). <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> calculates the proportion
of edge cells within the neighbouring window, of square filter dimension <code>--filter</code>, surrounding each grid cell.
Therefore, <code>EdgeDensity</code>is a measure of how complex the topographic surface is within a local neighbourhood.
It is therefore a measure of topographic texture. It will take a value near 0.0 for smooth sites and 1.0 in areas
of high surface roughness or complex topography.</p>
<p>The distribution of <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> is highly dependent upon the value of the <code>norm_diff</code> used in the calculation. This
threshold may require experimentation to find an appropriate value and is likely dependent upon the topography and
source data. Nonetheless, experience has shown that <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> provides one of the best measures of surface
texture of any of the available roughness tools.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.edge_density(
    dem, 
    output, 
    filter=11, 
    norm_diff=5.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgeDensity -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=15 --norm_diff=20.0 ^
--num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/edge_density.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/01/2019</p>
<p><a name="ElevAbovePit"></a></p>
<a class="header" href="#elevabovepit" id="elevabovepit"><h1>ElevAbovePit</h1></a>
<p>This tool will calculate the elevation of each grid cell in a digital elevation model (DEM) above the nearest
downslope pit cell or grid edge cell, depending on which is encountered first during the flow-path traverse.
The resulting image is therefore a measure of relative landscape position. The user must specify the names of
a D8 flow pointer grid, a DEM file, and the output file. The flow pointer grid must be derived using the D8
flow algorithm.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_above_pit(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevAbovePit -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_above_pit.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="ElevPercentile"></a></p>
<a class="header" href="#elevpercentile" id="elevpercentile"><h1>ElevPercentile</h1></a>
<p>Elevation percentile (EP) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentile of the
elevation distribution within the filter window, such that:</p>
<blockquote>
<p>EP = count<sub>i∈C</sub>(z<sub>i</sub> &gt; z<sub>0</sub>) x (100 / n<sub>C</sub>)</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>i</sub> is the elevation
of cell <em>i</em> contained within the neighboring set C, and n<sub>C</sub> is the number
of grid cells contained within the window.</p>
<p>EP is unsigned and expressed as a percentage, bound between 0%
and 100%. Quantile-based estimates (e.g., the median and interquartile
range) are often used in nonparametric statistics to provide data
variability estimates without assuming the distribution is normal.
Thus, EP is largely unaffected by irregularly shaped elevation frequency
distributions or by outliers in the DEM, resulting in a highly robust metric
of LTP. In fact, elevation distributions within small to medium sized
neighborhoods often exhibit skewed, multimodal, and non-Gaussian
distributions, where the occurrence of elevation errors can often result
in distribution outliers. Thus, based on these statistical characteristics,
EP is considered one of the most robust representation of LTP.</p>
<p>The algorithm implemented by this tool uses the relatively efficient running-histogram filtering algorithm of Huang
et al. (1979). Because most DEMs contain floating point data, elevation values must be rounded to be binned. The
<code>--sig_digits</code> parameter is used to determine the level of precision preserved during this binning process. The
algorithm is parallelized to further aid with computational efficiency.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_percentile(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevPercentile -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_percentile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="ElevRelativeToMinMax"></a></p>
<a class="header" href="#elevrelativetominmax" id="elevrelativetominmax"><h1>ElevRelativeToMinMax</h1></a>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a
percentage of the relief between the DEM minimum and maximum values. As such, it provides a basic
measure of relative topographic position.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevrelativetowatershedminmax"><strong>ElevRelativeToWatershedMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_min_max(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_relative_to_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="ElevRelativeToWatershedMinMax"></a></p>
<a class="header" href="#elevrelativetowatershedminmax" id="elevrelativetowatershedminmax"><h1>ElevRelativeToWatershedMinMax</h1></a>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a percentage
of the relief between the watershed minimum and maximum values. As such, it provides a basic
measure of relative topographic position. The user must specify the names of DEM (<code>--dem</code>) and watersheds (<code>--watersheds</code>)
raster files.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevrelativetominmax"><strong>ElevRelativeToMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--watersheds       </td><td> Input raster watersheds file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_watershed_min_max(
    dem, 
    watersheds, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToWatershedMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --watersheds=watershed.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_relative_to_watershed_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="FeaturePreservingDenoise"></a></p>
<a class="header" href="#featurepreservingdenoise" id="featurepreservingdenoise"><h1>FeaturePreservingDenoise</h1></a>
<p>This tool implements a highly modified form of the DEM de-noising algorithm described
by Sun et al. (2007). It is very effective at removing surface roughness from digital
elevation models (DEMs), without significantly altering breaks-in-slope. As such,
this tool should be used for smoothing DEMs rather than either smoothing with
low-pass filters (e.g. mean, median, Gaussian filters) or grid size coarsening
by resampling. The algorithm works by 1) calculating the surface normal 3D vector
of each grid cell in the DEM, 2) smoothing the normal vector field using a
filtering scheme that applies more weight to neighbours with lower angular difference
in surface normal vectors, and 3) uses the smoothed normal vector field to update
the elevations in the input DEM.</p>
<p>Sun et al.'s (2007) original method was intended to work on input point clouds and
fitted triangular irregular networks (TINs). The algorithm has been modified to
work with input raster DEMs instead. In so doing, this algorithm calculates surface
normal vectors from the planes fitted to 3 x 3 neighbourhoods surrounding each
grid cell, rather than the triangular facet. The normal vector field smoothing and
elevation updating procedures are also based on raster filtering operations. These
modifications make this tool more efficient than Sun's original method, but will
also result in a slightly different output than what would be achieved with Sun's
method.</p>
<p><em>Reference</em>:</p>
<p>Sun, X., Rosin, P., Martin, R., &amp; Langbein, F. (2007). Fast and effective feature-preserving
mesh denoising. IEEE Transactions on Visualization &amp; Computer Graphics, (5), 925-938.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#drainagepreservingsmoothing"><strong>DrainagePreservingSmoothing</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--num_iter         </td><td> Number of iterations</td></tr>
<tr><td>--max_diff         </td><td> Maximum allowable absolute elevation change (optional)</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.feature_preserving_denoise(
    dem, 
    output, 
    filter=11, 
    norm_diff=15.0, 
    num_iter=3, 
    max_diff=0.5, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FeaturePreservingDenoise -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --filter=15 ^
--norm_diff=20.0 --num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/feature_preserving_denoise.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/11/2017</p>
<p><a name="FetchAnalysis"></a></p>
<a class="header" href="#fetchanalysis" id="fetchanalysis"><h1>FetchAnalysis</h1></a>
<p>This tool creates a new raster in which each grid cell is assigned the distance, in meters, to the nearest
topographic obstacle in a specified direction. It is a modification of the algorithm described by Lapen and
Martz (1993). Unlike the original algorithm, Fetch Analysis is capable of analyzing fetch in any direction
from 0-360 degrees. The user must specify the name of an input digital elevation model (DEM) raster file, the
output raster name, a hypothetical wind direction, and a value for the height increment parameter. The algorithm
searches each grid cell in a path following the specified wind direction until the following condition is met:</p>
<blockquote>
<p><em>Z</em><sub>test</sub> &gt;= <em>Z</em><sub>core</sub> + <em>DI</em></p>
</blockquote>
<p>where <em>Z</em><sub>core</sub> is the elevation of the grid cell at which fetch is being determined, <em>Z</em><sub>test</sub>
is the elevation of the grid cell being tested as a topographic obstacle, <em>D</em> is the distance between the two
grid cells in meters, and <em>I</em> is the height increment in m/m. Lapen and Martz (1993) suggest values for <em>I</em> in
the range of 0.025 m/m to 0.1 m/m based on their study of snow re-distribution in low-relief agricultural
landscapes of the Canadian Prairies. If the directional search does not identify an obstacle grid cell before the
edge of the DEM is reached, the distance between the DEM edge and Zcore is entered. Edge distances are assigned
negative values to differentiate between these artificially truncated fetch values and those for which a valid
topographic obstacle was identified. Notice that linear interpolation is used to estimate the elevation of the
surface where a ray (i.e. the search path) does not intersect the DEM grid precisely at one of its nodes.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to
operate for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued
grid cells in the input image will be assigned NoData values in the output image. Fetch Analysis images are
best displayed using the blue-white-red bipolar palette to distinguish between the positive and negative
values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#directionalrelief"><strong>DirectionalRelief</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees in degrees</td></tr>
<tr><td>--hgt_inc          </td><td> Height increment value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fetch_analysis(
    dem, 
    output, 
    azimuth=0.0, 
    hgt_inc=0.05, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FetchAnalysis -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/fetch_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="FillMissingData"></a></p>
<a class="header" href="#fillmissingdata" id="fillmissingdata"><h1>FillMissingData</h1></a>
<p>This tool can be used to fill in small gaps in a raster or digital elevation model (DEM). The gaps,
or holes, must have recognized NoData values. If gaps do not currently have this characteristic, use
the <a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a> tool and ensure that the data are stored using a raster format that supports NoData
values. All valid, non-NoData values in the input raster will be assigned the same value in the output image.</p>
<p>The algorithm uses an inverse-distance weighted (IDW) scheme based on the valid values on the edge of
NoData gaps to estimate gap values. The user must specify the filter size (<code>--filter</code>), which determines
the size of gap that is filled, and the IDW weight (<code>--weight</code>).</p>
<p>The filter size, specified in grid cells, is used to determine how far the algorithm will search for valid,
non-NoData values. Therefore, setting a larger filter size allows for the filling of larger gaps in the input
raster.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Filter size (cells)</td></tr>
<tr><td>--weight           </td><td> IDW weight value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_missing_data(
    i, 
    output, 
    filter=11, 
    weight=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillMissingData -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 ^
--weight=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/fill_missing_data.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/06/2017</p>
<p><a name="FindRidges"></a></p>
<a class="header" href="#findridges" id="findridges"><h1>FindRidges</h1></a>
<p>This tool can be used to identify ridge cells in a digital elevation model (DEM). Ridge cells are those that
have lower neighbours either to the north and south or the east and west. Line thinning can optionally be used
to create single-cell wide ridge networks by specifying the <code>--line_thin</code> parameter.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--line_thin        </td><td> Optional flag indicating whether post-processing line-thinning should be performed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_ridges(
    dem, 
    output, 
    line_thin=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindRidges -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=out.tif --line_thin 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/find_ridges.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/12/2017</p>
<p><a name="Hillshade"></a></p>
<a class="header" href="#hillshade" id="hillshade"><h1>Hillshade</h1></a>
<p>This tool performs a hillshade operation (also called shaded relief) on an input digital elevation model (DEM).
The user must specify the  name of the input DEM and the output hillshade image name. Other parameters that must
be specified include the illumination source azimuth (<code>--azimuth</code>), or sun direction (0-360 degrees), the
illumination source altitude (<code>--altitude</code>; i.e. the elevation of the sun above the horizon, measured as an angle
from 0 to 90 degrees) and the Z conversion factor (<code>--zfactor</code>). The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The hillshade value (<em>HS</em>) of a DEM grid cell is calculate as:</p>
<blockquote>
<p><em>HS</em> = tan(<em>s</em>) / [1 - tan(<em>s</em>)<sup>2</sup>]<sup>0.5</sup> x [sin(<em>Alt</em>) / tan(<em>s</em>) - cos(<em>Alt</em>) x sin(<em>Az</em> - <em>a</em>)]</p>
</blockquote>
<p>where <em>s</em> and <em>a</em> are the local slope gradient and aspect (orientation) respectively and <em>Alt</em> and <em>Az</em>
are the illumination source altitude and azimuth respectively. Slope and aspect are calculated using
Horn's (1981) 3rd-order finate difference method.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Illumination source azimuth in degrees</td></tr>
<tr><td>--altitude         </td><td> Illumination source altitude in degrees</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hillshade(
    dem, 
    output, 
    azimuth=315.0, 
    altitude=30.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Hillshade -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --azimuth=315.0 --altitude=30.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="HorizonAngle"></a></p>
<a class="header" href="#horizonangle" id="horizonangle"><h1>HorizonAngle</h1></a>
<p>This tool calculates the horizon angle (<em>Sx</em>), i.e. the maximum slope along a specified azimuth (0-360 degrees) for
each grid cell in an input digital elevation model (DEM). Horizon angle is sometime referred to as the maximum upwind
slope in wind exposure/sheltering studies. Positive values can be considered sheltered with respect to the azimuth and
negative values are exposed. Thus, <em>Sx</em> is a measure of exposure to a wind from a specific direction. The algorithm works
by tracing a ray from each grid cell in the direction of interest and evaluating the slope for each location in which the
DEM grid is intersected by the ray. Linear interpolation is used to estimate the elevation of the surface where a ray does
not intersect the DEM grid precisely at one of its nodes.</p>
<p>The user is able to constrain the maximum search distance (<code>--max_dist</code>) for the ray tracing by entering a valid maximum
search distance value (in the same units as the X-Y coordinates of the input raster DEM). If the maximum search distance
is left blank, each ray will be traced to the edge of the DEM, which will add to the computational time.</p>
<p>Maximum upwind slope should not be calculated for very extensive areas over which the Earth's curvature must be taken into
account. Also, this index does not take into account the deflection of wind by topography. However, averaging the horizon
angle over a window of directions can yield a more robust measure of exposure, compensating for the deflection of wind from
its regional average by the topography. For example, if you are interested in measuring the exposure of a landscape to a
northerly wind, you could perform the following calculation:</p>
<blockquote>
<p>Sx(N) = [Sx(345)+Sx(350)+Sx(355)+Sx(0)+Sx(5)+Sx(10)+Sx(15)] / 7.0</p>
</blockquote>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate for
larger sized DEMs. Maximum upwind slope is best displayed using a Grey scale palette that is inverted.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees</td></tr>
<tr><td>--max_dist         </td><td> Optional maximum search distance (unspecified if none; in xy units)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.horizon_angle(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HorizonAngle -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/horizon_angle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="HypsometricAnalysis"></a></p>
<a class="header" href="#hypsometricanalysis" id="hypsometricanalysis"><h1>HypsometricAnalysis</h1></a>
<p>This tool can be used to derive the hypsometric curve, or area-altitude curve, of one or more
input digital elevation models (DEMs) (<code>--inputs</code>). A hypsometric curve is a histogram or cumulative
distribution function of elevations in a geographical area.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#slopevselevationplot"><strong>SlopeVsElevationPlot</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input DEM files</td></tr>
<tr><td>--watershed        </td><td> Input watershed files (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hypsometric_analysis(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HypsometricAnalysis -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/hypsometric_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/01/2018</p>
<p><a name="MaxAnisotropyDev"></a></p>
<a class="header" href="#maxanisotropydev" id="maxanisotropydev"><h1>MaxAnisotropyDev</h1></a>
<p>Calculates the maximum anisotropy (directionality) in elevation deviation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=3, 
    step=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_anisotropy_dev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: January 26, 2018</p>
<p><a name="MaxAnisotropyDevSignature"></a></p>
<a class="header" href="#maxanisotropydevsignature" id="maxanisotropydevsignature"><h1>MaxAnisotropyDevSignature</h1></a>
<p>Calculates the anisotropy in deviation from mean for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_anisotropy_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: 27/03/2018</p>
<p><a name="MaxBranchLength"></a></p>
<a class="header" href="#maxbranchlength" id="maxbranchlength"><h1>MaxBranchLength</h1></a>
<p>Maximum branch length (<code>Bmax</code>) is the longest branch length between a grid cell's flowpath
and the flowpaths initiated at each of its neighbours. It can be conceptualized as the
downslope distance that a volume of water that is split into two portions by a drainage
divide would travel before reuniting.</p>
<p>If the two flowpaths of neighbouring grid cells do not intersect, <code>Bmax</code> is simply the
flowpath length from the starting cell to its terminus at the edge of the grid or a cell
with undefined flow direction (i.e. a pit cell either in a topographic depression or at
the edge of a major body of water).</p>
<p>The pattern of <code>Bmax</code> derived from a DEM should be familiar to anyone who has interpreted
upslope contributing area images. In fact, <code>Bmax</code> can be thought of as the complement of
upslope contributing area. Whereas contributing area is greatest along valley bottoms and lowest at
drainage divides, <code>Bmax</code> is greatest at divides and lowest along channels. The two topographic
attributes are also distinguished by their units of measurements; <code>Bmax</code> is a length rather
than an area. The presence of a major drainage divide between neighbouring grid cells is apparent in
a <code>Bmax</code> image as a linear feature, often two grid cells wide, of relatively high values. This
property makes <code>Bmax</code> a useful land surface parameter for mapping ridges and divides.</p>
<p><code>Bmax</code> is useful in the study of landscape structure, particularly with respect to drainage patterns.
The index gives the relative significance of a specific location along a divide, with respect to the
dispersion of materials across the landscape, in much the same way that stream ordering can be used
to assess stream size.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#flowlengthdiff"><strong>FlowLengthDiff</strong></a></p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Seibert J. 2013. Measuring the significance of a divide to local drainage patterns.
International Journal of Geographical Information Science, 27: 1453-1468. DOI:
10.1080/13658816.2012.705289</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_branch_length(
    dem, 
    output, 
    log=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxBranchLength -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_branch_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 9, 2017</p>
<p><a name="MaxDifferenceFromMean"></a></p>
<a class="header" href="#maxdifferencefrommean" id="maxdifferencefrommean"><h1>MaxDifferenceFromMean</h1></a>
<p>Calculates the maximum difference from mean elevation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DIFFmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DIFFmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_difference_from_mean(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDifferenceFromMean -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_diff_from_mean.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/08/2018</p>
<p><a name="MaxDownslopeElevChange"></a></p>
<a class="header" href="#maxdownslopeelevchange" id="maxdownslopeelevchange"><h1>MaxDownslopeElevChange</h1></a>
<p>This tool calculates the maximum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#mindownslopeelevchange"><strong>MinDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MaxElevDevSignature"></a></p>
<a class="header" href="#maxelevdevsignature" id="maxelevdevsignature"><h1>MaxElevDevSignature</h1></a>
<p>Calculates the maximum elevation deviation over a range of spatial scales and for a set of points.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elev_dev_signature(
    dem, 
    points, 
    output, 
    min_scale, 
    max_scale, 
    step=10, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.tif ^
--output=topo_position.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_elev_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: March 1, 2018</p>
<p><a name="MaxElevationDeviation"></a></p>
<a class="header" href="#maxelevationdeviation" id="maxelevationdeviation"><h1>MaxElevationDeviation</h1></a>
<p>This tool can be used to calculate the maximum deviation from mean elevation, <em>DEVmax</em> (Lindsay et al. 2015) for each
grid cell in a digital elevation model (DEM) across a range specified spatial scales. <em>DEV</em>
is an elevation residual index and is essentially equivalent to a local elevation z-score.
This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. The multi-scaled calculation
of <em>DEVmax</em> utilizes an integral image approach (Crow, 1984) to ensure highly efficient
filtering that is invariant with filter size, which is the algorithm characteristic that allows for
this densely sampled multi-scale analysis. In this way, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> allows users
to estimate the locally optimal scale with which to estimate <em>DEV</em> on a pixel-by-pixel basis.
This multi-scaled version of local topographic position can reveal significant terrain
characteristics and can aid with soil, vegetation, landform, and other mapping applications
that depend on geomorphometric characterization.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM). The range of scales that are
evaluated in calculating <em>DEVmax</em> are determined by the user-specified <code>--min_scale</code>, <code>--max_scale</code>, and <code>--step</code>
parameters. All filter radii between the minimum and maximum scales, increasing by <code>step</code>, will be evaluated.
The scale parameters are in units of grid cells and specify kernel size &quot;radii&quot; (<em>r</em>), such that:</p>
<blockquote>
<p><em>d</em> = 2<em>r</em> + 1</p>
</blockquote>
<p>That is, a radii of 1, 2, 3... yields a square filters of dimension (<em>d</em>) 3 x 3, 5 x 5, 7 x 7...</p>
<p><em>DEV</em> is estimated at each tested filter size and every grid cell is assigned the maximum <em>DEV</em> value
across the evaluated scales.</p>
<p>The user must specify the file names of two output rasters, including the magnitude (<em>DEVmax</em>) and a
second raster the assigns each pixel the scale at which <em>DEVmax</em> is encountered (<em>DEVscale</em>). The
<em>DEVscale</em> raster can be very useful for revealing multi-scale landscape structure.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elevation_deviation(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevationDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_elev_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 20, 2017</p>
<p><a name="MinDownslopeElevChange"></a></p>
<a class="header" href="#mindownslopeelevchange" id="mindownslopeelevchange"><h1>MinDownslopeElevChange</h1></a>
<p>This tool calculates the minimum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#maxdownslopeelevchange"><strong>MaxDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/min_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MultiscaleRoughness"></a></p>
<a class="header" href="#multiscaleroughness" id="multiscaleroughness"><h1>MultiscaleRoughness</h1></a>
<p>Calculates surface roughness over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster roughness scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughness -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_roughness.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/02/2018</p>
<p><a name="MultiscaleRoughnessSignature"></a></p>
<a class="header" href="#multiscaleroughnesssignature" id="multiscaleroughnesssignature"><h1>MultiscaleRoughnessSignature</h1></a>
<p>Calculates the surface roughness for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughnessSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_roughness_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: February 27, 2018</p>
<p><a name="MultiscaleStdDevNormals"></a></p>
<a class="header" href="#multiscalestddevnormals" id="multiscalestddevnormals"><h1>MultiscaleStdDevNormals</h1></a>
<p>Calculates surface roughness over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster roughness scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_std_dev_normals(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleStdDevNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_std_dev_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/06/2019</p>
<p><a name="MultiscaleTopographicPositionImage"></a></p>
<a class="header" href="#multiscaletopographicpositionimage" id="multiscaletopographicpositionimage"><h1>MultiscaleTopographicPositionImage</h1></a>
<p>This tool creates a multiscale topographic position (MTP) image (<a href="https://www.uoguelph.ca/%7Ehydrogeo/pubs/UpdatedPosterMapSm.png">see here for an
example</a>) from three DEV<sub>max</sub> rasters of differing
spatial scale ranges. Specifically, <a href="./geomorphometric_analysis.html#multiscaletopographicpositionimage"><strong>MultiscaleTopographicPositionImage</strong></a> takes three DEV<sub>max</sub> <em>magnitude</em>
rasters, created using the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool, as inputs. The three inputs should correspond to the elevation
deviations in the local (<code>--local</code>), meso (<code>--meso</code>), and broad (<code>--broad</code>) scale ranges and will be forced into the
blue, green, and red colour components of the colour composite output (<code>--output</code>) raster. The image lightness value
(<code>--lightness</code>) controls the overall brightness of the output image, as depending on the topography and scale ranges,
these images can appear relatively dark. Higher values result in brighter, more colourful output images.</p>
<p>The output images can take some training to interpret correctly and a detailed explanation can be found in Lindsay et al.
(2015). Sites within the landscape that occupy prominent topographic positions, either
low-lying or elevated, will be apparent by their bright colouring in the MTP image. Those that are coloured more strongly in
the blue are promient at the local scale range; locations that are more strongly green coloured are promient at the meso scale;
and bright reds in the MTP image are associated with broad-scale landscape prominence. Of course, combination colours are also possible when
topography is elevated or low-lying across multiple scale ranges. For example, a yellow area would indicated a site of prominent
topographic position across the meso and broadest scale ranges.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--local            </td><td> Input local-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--meso             </td><td> Input meso-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--broad            </td><td> Input broad-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--lightness        </td><td> Image lightness value (default is 1.2)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_topographic_position_image(
    local, 
    meso, 
    broad, 
    output, 
    lightness=1.2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleTopographicPositionImage -v ^
--wd=&quot;/path/to/data/&quot; --local=DEV_local.tif --meso=DEV_meso.tif ^
--broad=DEV_broad.tif -o=output.tif --lightness=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_topographic_position_image.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2017</p>
<p><a name="NumDownslopeNeighbours"></a></p>
<a class="header" href="#numdownslopeneighbours" id="numdownslopeneighbours"><h1>NumDownslopeNeighbours</h1></a>
<p>This tool calculates the number of downslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output image can therefore have values raning from 0 to 8. A
raster grid cell with eight downslope neighbours is a peak and a cell with zero downslope neighbours is a pit. This
tool can be used with the <a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a> tool to assess the degree of local flow divergence/convergence.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_downslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumDownslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/num_downslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="NumUpslopeNeighbours"></a></p>
<a class="header" href="#numupslopeneighbours" id="numupslopeneighbours"><h1>NumUpslopeNeighbours</h1></a>
<p>This tool calculates the number of upslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output raster can therefore have values ranging from 0 to 8, although
in a DEM that has been hydrologically conditioned (i.e. depressions and flats removed), the values of the output will
not exceed seven. This tool can be used with the <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a> tool to assess the degree of local flow
divergence/convergence.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_upslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumUpslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/num_upslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PennockLandformClass"></a></p>
<a class="header" href="#pennocklandformclass" id="pennocklandformclass"><h1>PennockLandformClass</h1></a>
<p>Tool can be used to perform a simple landform classification based on measures of slope gradient
and curvature derived from a user-specified digital elevation model (DEM). The classification
scheme is based on the method proposed by Pennock, Zebarth, and DeJong (1987). The scheme divides
a landscape into seven element types, including: convergent footslopes (CFS), divergent footslopes
(DFS), convergent shoulders (CSH), divergent shoulders (DSH), convergent backslopes (CBS), divergent
backslopes (DBS), and level terrain (L). The output raster image will record each of these base element
types as:</p>
<table><thead><tr><th>Element Type  </th><th>  Code</th></tr></thead><tbody>
<tr><td>CFS           </td><td>  1</td></tr>
<tr><td>DFS           </td><td>  2</td></tr>
<tr><td>CSH           </td><td>  3</td></tr>
<tr><td>DSH           </td><td>  4</td></tr>
<tr><td>CBS           </td><td>  5</td></tr>
<tr><td>DBS           </td><td>  6</td></tr>
<tr><td>L             </td><td>  7</td></tr>
</tbody></table>
<p>The definition of each of the elements, based on the original Pennock et al. (1987) paper, is
as follows:</p>
<table><thead><tr><th align="left">    PROFILE             </th><th align="left">   GRADIENT    </th><th>   PLAN         </th><th>  Element </th></tr></thead><tbody>
<tr><td align="left"> Concave ( -0.10)       </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CFS     </td></tr>
<tr><td align="left"> Concave ( -0.10)       </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DFS     </td></tr>
<tr><td align="left"> Convex (&gt;0.10)         </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CSH     </td></tr>
<tr><td align="left"> Convex (&gt;0.10)         </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DSH     </td></tr>
<tr><td align="left"> Linear (-0.10...0.10)  </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CBS     </td></tr>
<tr><td align="left"> Linear (-0.10...0.10)  </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DBS     </td></tr>
<tr><td align="left"> --                     </td><td align="left">  Low 3.0      </td><td align="left"> --             </td><td align="left">  L       </td></tr>
</tbody></table>
<p>Where PROFILE is profile curvature, GRADIENT is the slope gradient, and PLAN is the plan curvature.
Note that these values are likely landscape and data specific and can be adjusted by the user.
Landscape classification schemes that are based on terrain attributes are highly sensitive to
short-range topographic variability (i.e. roughness) and can benefit from pre-processing the DEM
with a smoothing filter to reduce the effect of surface roughness and emphasize the longer-range
topographic signal. The <a href="./geomorphometric_analysis.html#featurepreservingdenoise"><strong>FeaturePreservingDenoise</strong></a> and <a href="./geomorphometric_analysis.html#drainagepreservingsmoothing"><strong>DrainagePreservingSmoothing</strong></a> tools
offer excellent performance in smoothing DEMs without removing the sharpness of breaks-in-slope.</p>
<p><em>Reference</em>:</p>
<p>Pennock, D.J., Zebarth, B.J., and DeJong, E. (1987) Landform classification and soil distribution
in hummocky terrain, Saskatchewan, Canada. Geoderma, 40: 297-315.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--slope            </td><td> Slope threshold value, in degrees (default is 3.0)</td></tr>
<tr><td>--prof             </td><td> Profile curvature threshold value (default is 0.1)</td></tr>
<tr><td>--plan             </td><td> Plan curvature threshold value (default is 0.0)</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.pennock_landform_class(
    dem, 
    output, 
    slope=3.0, 
    prof=0.1, 
    plan=0.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PennockLandformClass -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --slope=3.0 ^
--prof=0.1 --plan=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/pennock_landform_class.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 12, 2017</p>
<p><a name="PercentElevRange"></a></p>
<a class="header" href="#percentelevrange" id="percentelevrange"><h1>PercentElevRange</h1></a>
<p>Percent elevation range (PER) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentage of the
elevation range within the neighbourhood filter window, such that:</p>
<blockquote>
<p>PER = z<sub>0</sub> / (z<sub>max</sub> - z<sub>min</sub>) x 100</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>max</sub> is the maximum
neighbouring elevation, and z<sub>min</sub> is the minimum neighbouring elevation.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>Compared with <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a> and <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, PER is a less robust measure of LTP that is susceptible
to outliers in neighbouring elevations (e.g. the presence of off-terrain objects in the DEM).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_elev_range(
    dem, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentElevRange -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/percent_elev_range.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="PlanCurvature"></a></p>
<a class="header" href="#plancurvature" id="plancurvature"><h1>PlanCurvature</h1></a>
<p>This tool calculates the plan curvature (i.e. contour curvature), or the rate of change in
aspect along a contour line, from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Plan curvature characterizes the
degree of flow convergence or divergence within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Plan curvature is negative for diverging flow along ridges and positive for
convergent areas, e.g. along valley bottoms.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.plan_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PlanCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/plan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/06/2017</p>
<p><a name="Profile"></a></p>
<a class="header" href="#profile" id="profile"><h1>Profile</h1></a>
<p>This tool can be used to plot the data profile, along a set of one or more vector lines (<code>--lines</code>), in
an input (<code>--surface</code>) digital elevation model (DEM), or other surface model. The data profile plots
surface height (y-axis) against distance along profile (x-axis). The tool outputs an interactive SVG line
graph embedded in an HTML document (<code>--output</code>). If the vector lines file contains multiple line features,
the output plot will contain each of the input profiles.</p>
<p>If you want to extract the <a href="http://www.fao.org/docrep/003/X6841E/X6841E02.HTM">longitudinal profile</a> of a river,
use the <a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a>, <a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--lines            </td><td> Input vector line file</td></tr>
<tr><td>--surface          </td><td> Input raster surface file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile(
    lines, 
    surface, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Profile -v --wd=&quot;/path/to/data/&quot; ^
--lines=profile.shp --surface=dem.tif -o=profile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/profile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/02/2018</p>
<p><a name="ProfileCurvature"></a></p>
<a class="header" href="#profilecurvature" id="profilecurvature"><h1>ProfileCurvature</h1></a>
<p>This tool calculates the profile curvature, or the rate of change in slope along a flow line,
from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Profile curvature characterizes the
degree of downslope acceleration or deceleration within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation because
curvature values are typically very small. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Profile curvature is negative for slope increasing downhill (convex flow profile,
typical of upper slopes) and positive for slope decreasing downhill (concave, typical of lower slopes).</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ProfileCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/prof_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/062017</p>
<p><a name="RelativeAspect"></a></p>
<a class="header" href="#relativeaspect" id="relativeaspect"><h1>RelativeAspect</h1></a>
<p>This tool creates a new raster in which each grid cell is assigned the terrain aspect relative to a user-specified
direction (<code>--azimuth</code>). Relative terrain aspect is the angular distance (measured in degrees) between the land-surface
aspect and the assumed regional wind azimuth (Bohner and Antonic, 2007). It is bound between 0-degrees (windward direction)
and 180-degrees (leeward direction). Relative terrain aspect is the simplest of the measures of topographic exposure to
wind, taking into account terrain orientation only and neglecting the influences of topographic shadowing by distant
landforms and the deflection of wind by topography.</p>
<p>The user must specify the name of a digital elevation model (DEM) (<code>--dem</code>) and an azimuth (i.e. a wind direction). The
Z Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the same in the DEM.
When this is the case, the algorithm will multiply each elevation in the DEM by the Z Conversion Factor.</p>
<p><em>Reference</em>:</p>
<p>Böhner, J., and Antonić, O. (2009). Land-surface parameters specific to topo-climatology. Developments in Soil
Science, 33, 195-226.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Illumination source azimuth</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_aspect(
    dem, 
    output, 
    azimuth=0.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeAspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --azimuth=180.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/06/2017</p>
<p><a name="RelativeStreamPowerIndex"></a></p>
<a class="header" href="#relativestreampowerindex" id="relativestreampowerindex"><h1>RelativeStreamPowerIndex</h1></a>
<p>This tool can be used to calculate the relative stream power (<em>RSP</em>) index. This index is directly related
to the stream power if the assumption can be made that discharge is directly proportional to upslope
contributing area (<em>A<sub>s</sub></em>; <code>--sca</code>). The index is calculated as:</p>
<blockquote>
<p><em>RSP</em> = <em>A<sub>s</sub></em><sup><em>p</em></sup> × tan(β)</p>
</blockquote>
<p>where <em>A<sub>s</sub></em> is the specific catchment area (i.e. the upslope contributing area per unit
contour length) estimated using one of the available flow accumulation algorithms; β is the local
slope gradient in degrees (<code>--slope</code>); and, <em>p</em> (<code>--exponent</code>) is a user-defined exponent term that
controls the location-specific relation between contributing area and discharge. Notice that
<em>A<sub>s</sub></em> must not be log-transformed prior to being used; <em>A<sub>s</sub></em> is commonly
log-transformed to enhance visualization of the data. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a> <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--exponent         </td><td> SCA exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_stream_power_index(
    sca, 
    slope, 
    output, 
    exponent=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeStreamPowerIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --exponent=1.1 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_stream_power_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="RelativeTopographicPosition"></a></p>
<a class="header" href="#relativetopographicposition" id="relativetopographicposition"><h1>RelativeTopographicPosition</h1></a>
<p>Relative topographic position (RTP) is an index of local topographic position (i.e. how
elevated or low-lying a site is relative to its surroundings) and is a modification of percent
elevation range (PER; <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a>) and accounts for the elevation distribution. Rather than
positioning the central cell's elevation solely between the filter extrema, RTP is a piece-wise
function that positions the central elevation relative to the minimum (z<sub>min</sub>), mean (μ),
and maximum values (z<sub>max</sub>), within a local neighbourhood of a user-specified size (<code>--filterx</code>,
<code>--filtery</code>), such that:</p>
<blockquote>
<p>RTP = (z<sub>0</sub> − μ) / (μ − z<sub>min</sub>), if z<sub>0</sub> &lt; μ</p>
<p>OR</p>
<p>RTP = (z<sub>0</sub> − μ) / (z<sub>max</sub> - μ), if z<sub>0</sub> &gt;= μ
</p>
</blockquote>
<p>The resulting index is bound by the interval [−1, 1], where the sign indicates if the cell is above or below
than the filter mean. Although RTP uses the mean to define two linear functions, the reliance on the filter
extrema is expected to result in sensitivity to outliers. Furthermore, the use of the mean implies assumptions
of unimodal and symmetrical elevation distribution.</p>
<p>In many cases, Elevation Percentile (<a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>) and deviation from mean elevation (<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>)
provide more suitable and robust measures of relative topographic position.</p>
<p><em>Reference</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic
position for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_topographic_position(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeTopographicPosition -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_topographic_position.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><a name="RemoveOffTerrainObjects"></a></p>
<a class="header" href="#removeoffterrainobjects" id="removeoffterrainobjects"><h1>RemoveOffTerrainObjects</h1></a>
<p>This tool can be used to create a bare-earth DEM from a fine-resolution digital surface model. The
tool is typically applied to LiDAR DEMs which frequently contain numerous off-terrain objects (OTOs) such
as buildings, trees and other vegetation, cars, fences and other anthropogenic objects. The algorithm
works by finding and removing steep-sided peaks within the DEM. All peaks within a sub-grid, with a
dimension of the user-specified maximum OTO size (<code>--filter</code>), in pixels, are identified and removed.
Each of the edge cells of the peaks are then examined to see if they have a slope that is less than the
user-specified minimum OTO edge slope (<code>--slope</code>) and a back-filling procedure is used. This ensures that
OTOs are distinguished from natural topographic features such as hills. The DEM is preprocessed using a
white top-hat transform, such that elevations are normalized for the underlying ground surface.</p>
<p>Note that this tool is appropriate to apply to rasterized LiDAR DEMs. Use the <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a>
tool to remove or classify OTOs within a LiDAR point-cloud.</p>
<p><em>Reference</em>:</p>
<p>J.B. Lindsay (2018) A new method for the removal of off-terrain objects from LiDAR-derived raster surface
models. Available online, DOI: <a href="https://www.researchgate.net/publication/323003064_A_new_method_for_the_removal_of_off-terrain_objects_from_LiDAR-derived_raster_surface_models">10.13140/RG.2.2.21226.62401</a></p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a>, <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Filter size (cells)</td></tr>
<tr><td>--slope            </td><td> Slope threshold value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_off_terrain_objects(
    dem, 
    output, 
    filter=11, 
    slope=15.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemoveOffTerrainObjects -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=bare_earth_DEM.tif ^
--filter=25 --slope=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/remove_off_terrain_objects.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><a name="RuggednessIndex"></a></p>
<a class="header" href="#ruggednessindex" id="ruggednessindex"><h1>RuggednessIndex</h1></a>
<p>The terrain ruggedness index (TRI) is a measure of local topographic relief. The TRI calculates
the root-mean-square-deviation (RMSD) for each grid cell in a digital elevation model (DEM),
calculating the residuals (i.e. elevation differences) between a grid cell and its eight neighbours.
Notice that, unlike the output of this tool, the original Riley et al. (1999) TRI did not normalize
for the number of cells in the local window (i.e. it is a root-square-deviation only). However,
using the mean has the advantage of allowing for the varying number of neighbouring cells along
the grid edges and in areas bordering NoData cells. This modification does however imply that the
ouput of this tool cannot be directly compared with the index ranges of level to extremely rugged
terrain provided in Riley et al. (1999)</p>
<p><em>Reference</em>:</p>
<p>Riley, S. J., DeGloria, S. D., and Elliot, R. (1999). Index that quantifies topographic heterogeneity.
<em>Intermountain Journal of Sciences</em>, 5(1-4), 23-27.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ruggedness_index(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RuggednessIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/ruggedness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="SedimentTransportIndex"></a></p>
<a class="header" href="#sedimenttransportindex" id="sedimenttransportindex"><h1>SedimentTransportIndex</h1></a>
<p>This tool calculates the sediment transport index, or sometimes, length-slope (<em>LS</em>)
factor, based on input specific contributing area (<em>A<sub>s</sub></em>, i.e. the upslope
contributing area per unit contour length; <code>--sca</code>) and slope gradient
(β, measured in degrees; <code>--slope</code>) rasters. Moore et al. (1991) state that the physical potential for
sheet and rill erosion in upland catchments can be evaluated by the product <em>R K LS</em>,
a component of the Universal Soil Loss Equation (USLE), where <em>R</em> is a rainfall and
runoff erosivity factor, <em>K</em> is a soil erodibility factor, and <em>LS</em> is the length-slope
factor that accounts for the effects of topography on erosion. To predict erosion at a
point in the landscape the LS factor can be written as:</p>
<blockquote>
<p><em>LS</em> = (<em>n</em> + 1)(<em>A<sub>s</sub></em> / 22.13)<sup><em>n</em></sup>(sin(β) / 0.0896)<sup><em>m</em></sup></p>
</blockquote>
<p>where <em>n</em> = 0.4 (<code>--sca_exponent</code>) and <em>m</em> = 1.3 (<code>--slope_exponent</code>) in its original formulation.</p>
<p>This index is derived from unit stream-power theory and is sometimes used in place of the
length-slope factor in the revised universal soil loss equation (RUSLE) for slope lengths
less than 100 m and slope less than 14 degrees. Like many hydrological land-surface
parameters <a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a> assumes that contributing area is directly related to
discharge. Notice that <em>A<sub>s</sub></em> must not be log-transformed prior to being used;
<em>A<sub>s</sub></em> is commonly log-transformed to enhance visualization of the data. Also,
<em>A<sub>s</sub></em> can be derived using any of the available flow accumulation tools, alghough
better results usually result from application of multiple-flow direction algorithms such
as <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a> and <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a>. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#relativestreampowerindex"><strong>RelativeStreamPowerIndex</strong></a>, <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sca_exponent     </td><td> SCA exponent value</td></tr>
<tr><td>--slope_exponent   </td><td> Slope exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sediment_transport_index(
    sca, 
    slope, 
    output, 
    sca_exponent=0.4, 
    slope_exponent=1.3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SedimentTransportIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --sca_exponent=0.5 ^
--slope_exponent=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/sediment_transport_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="Slope"></a></p>
<a class="header" href="#slope" id="slope"><h1>Slope</h1></a>
<p>This tool calculates slope gradient (i.e. slope steepness in degrees) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>slope = arctan(f<sub>x</sub><sup>2</sup> + f<sub>y</sub><sup>2</sup>)<sup>0.5</sup></p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Slope -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="SlopeVsElevationPlot"></a></p>
<a class="header" href="#slopevselevationplot" id="slopevselevationplot"><h1>SlopeVsElevationPlot</h1></a>
<p>This tool can be used to create a slope versus average elevation plot for one or more digital elevation models (DEMs).
Similary to a hypsometric analysis (<a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a>), the slope-elevation relation can reveal the basic
topographic character of a site. The output of this analysis is an HTML document (<code>--output</code>) that contains the
slope-elevation chart. The tool can plot multiple slope-elevation analyses on the same chart by specifying multiple
input DEM files (<code>--inputs</code>). Each input DEM can have an optional watershed in which the slope-elevation analysis is
confined by specifying the optional <code>--watershed</code> flag. If multiple input DEMs are used, and a watershed is used to
confine the analysis to a sub-area, there must be the same number of input raster watershed files as input DEM files.
The order of the DEM and watershed files must the be same (i.e. the first DEM file must correspond to the first
watershed file, the second DEM file to the second watershed file, etc.). Each watershed file may contain one or more
watersheds, designated by unique identifiers.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input DEM files</td></tr>
<tr><td>--watershed        </td><td> Input watershed files (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope_vs_elevation_plot(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SlopeVsElevationPlot -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/slope_vs_elev_plot.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/02/2018</p>
<p><a name="SphericalStdDevOfNormals"></a></p>
<a class="header" href="#sphericalstddevofnormals" id="sphericalstddevofnormals"><h1>SphericalStdDevOfNormals</h1></a>
<p>This tool can be used to calculate the spherical standard deviation of the distribution of surface normals
for an input digital elevation model (DEM; <code>--dem</code>). This is a measure of the angular dispersion of the surface
normal vectors within a local neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>
is therefore a measure of surface shape complexity, texture, and roughness. The <a href="https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread">
spherical standard deviation</a> (<em>s</em>) is defined as:</p>
<blockquote>
<p><em>s</em> = √[-2ln(<em>R</em> / <em>N</em>)] × 180 / π</p>
</blockquote>
<p>where <em>R</em> is the resultant vector length and <em>N</em> is the number of unit normal vectors
within the local neighbourhood. <em>s</em> is measured in degrees and is zero for simple planes and increases
infinitely with increasing surface complexity or roughness.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular dispersion, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, <em>s</em> should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <strong><em>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</em></strong> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <em>R</em>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p>Hodgson, M. E., and Gaile, G. L. (1999). A cartographic modeling approach for surface orientation-related applications.
<em>Photogrammetric Engineering and Remote Sensing</em>, 65(1), 85-95.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.spherical_std_dev_of_normals(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SphericalStdDevOfNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/spherical_std_dev_of_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/05/2019</p>
<p><a name="StandardDeviationOfSlope"></a></p>
<a class="header" href="#standarddeviationofslope" id="standarddeviationofslope"><h1>StandardDeviationOfSlope</h1></a>
<p>Calculates the standard deviation of slope from an input DEM, a metric of
roughness described by Grohmann et al., (2011).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster DEM file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.standard_deviation_of_slope(
    i, 
    output, 
    zfactor=1.0, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationOfSlope -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/standard_deviation_of_slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Anthony Francioni</p>
<p><em>Created</em>: May 26, 2018</p>
<p><a name="SurfaceAreaRatio"></a></p>
<a class="header" href="#surfacearearatio" id="surfacearearatio"><h1>SurfaceAreaRatio</h1></a>
<p>This tool calculates the ratio between the surface area and planar area of grid cells within digital elevation models (DEMs).
The tool uses the method of Jenness (2004) to estimate the surface area of a DEM grid cell based on the elevations
contained within the 3 x 3 neighbourhood surrounding each cell. The surface area ratio has a lower bound of 1.0 for
perfectly flat grid cells and is greater than 1.0 for other conditions. In particular, surface area ratio is a measure of
neighbourhood surface shape complexity (texture) and elevation variability (local slope).</p>
<p><em>Reference</em>:</p>
<p>Jenness, J. S. (2004). Calculating landscape surface area from digital elevation models. Wildlife Society
Bulletin, 32(3), 829-839.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.surface_area_ratio(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SurfaceAreaRatio -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/surface_area_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/01/2019</p>
<p><a name="TangentialCurvature"></a></p>
<a class="header" href="#tangentialcurvature" id="tangentialcurvature"><h1>TangentialCurvature</h1></a>
<p>This tool calculates the tangential curvature, which is the curvature of an inclined plan perpendicular
to both the direction of flow and the surface (Gallant and Wilson, 2000). Curvature is a second
derivative of the topographic surface defined by a digital elevation model (DEM). The user must specify
the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tangential_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TangentialCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/tan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="TotalCurvature"></a></p>
<a class="header" href="#totalcurvature" id="totalcurvature"><h1>TotalCurvature</h1></a>
<p>This tool calculates the total curvature, which measures the curvature of the topographic surface rather
than the curvature of a line across the surface in some direction (Gallant and Wilson, 2000). Total
curvature can be positive or negative, with zero curvature indicating that the surface is either flat
or the convexity in one direction is balanced by the concavity in another direction, as would occur at
a saddle point. Curvature is a second derivative of the topographic surface defined by a digital elevation
model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.total_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TotalCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/total_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="Viewshed"></a></p>
<a class="header" href="#viewshed" id="viewshed"><h1>Viewshed</h1></a>
<p>This tool can be used to calculate the viewshed (i.e. the visible area) from a
location (i.e. viewing station) or group of locations based on the topography defined
by an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>), a viewing station input vector file (<code>--stations</code>), the output file name
(<code>--output</code>), and the viewing height (<code>--height</code>).
Viewing station locations are specified as points within an input shapefile. The output
image indicates the number of stations visible from each grid cell. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation from which the viewshed is calculated.</p>
<p><a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a> should be used when there are a relatively small number of target sites
for which visibility needs to be assessed. If you need to assess general landscape
visibility as a land-surface parameter, the <a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a> tool should be used
instead.</p>
<p>Viewshed analysis is a very
computationally intensive task. Depending on the size of the input DEM grid and the
number of viewing stations, this operation may take considerable time to complete. Also,
this implementation of the viewshed algorithm does not account for the curvature of the
Earth. This should be accounted for if viewsheds are being calculated over very
extensive areas.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>--stations         </td><td> Input viewing station vector file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--height           </td><td> Viewing station height, in z units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.viewshed(
    dem, 
    stations, 
    output, 
    height=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Viewshed -v --wd=&quot;/path/to/data/&quot; ^
--dem='dem.tif' --stations='stations.shp' -o=output.tif ^
--height=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/viewshed.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/01/2018</p>
<p><a name="VisibilityIndex"></a></p>
<a class="header" href="#visibilityindex" id="visibilityindex"><h1>VisibilityIndex</h1></a>
<p>This tool can be used to calculate a measure of landscape visibility based on the
topography of an input digital elevation model (DEM). The user must specify the name of
the input DEM (<code>--dem</code>), the output file name (<code>--output</code>), the viewing height (<code>--height</code>),
and a resolution factor (<code>--res_factor</code>).
Viewsheds are calcuated for a subset of grid cells in the DEM based on the resolution
factor. The visibility index value (0.0-1.0) indicates the proportion of tested stations
(determined by the resolution factor) that each cell is visible from. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation. Each tested grid cell's viewshed will be calculated in parallel. However, visibility
index is one of the most computationally intensive geomorphometric indices to calculate.
Depending on the size of the input DEM grid and the resolution factor, this operation may take
considerable time to complete. If the task is too long-running, it is advisable to raise the
resolution factor. A resolution factor of 2 will skip every second row and every second column
(effectively evaluating the viewsheds of a quarter of the DEM's grid cells). Increasing this
value decreases the number of calculated viewshed but will result in a lower accuracy estimate
of overall visibility. In addition to the high computational costs of this index, the tool
also requires substantial memory resources to operate. Each of these limitations should be
considered before running this tool on a particular data set. This tool is best to apply
on computer systems with high core-counts and plenty of memory.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--height           </td><td> Viewing station height, in z units</td></tr>
<tr><td>--res_factor       </td><td> The resolution factor determines the density of measured viewsheds</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.visibility_index(
    dem, 
    output, 
    height=2.0, 
    res_factor=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VisibilityIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=dem.tif -o=output.tif ^
--height=10.0 --res_factor=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/visibility_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/04/2018</p>
<p><a name="WetnessIndex"></a></p>
<a class="header" href="#wetnessindex" id="wetnessindex"><h1>WetnessIndex</h1></a>
<p>Calculates the topographic wetness index, Ln(A / tan(slope)).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.wetness_index(
    sca, 
    slope, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WetnessIndex -v --wd=&quot;/path/to/data/&quot; ^
--sca='flow_accum.tif' --slope='slope.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/wetness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 2, 2017</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../available_tools/data_tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../available_tools/gis_analysis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../available_tools/data_tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../available_tools/gis_analysis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
