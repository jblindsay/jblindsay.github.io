<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GIS analysis - WhiteboxTools User Manual</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Setting Up WhiteboxTools</a></li><li class="chapter-item expanded "><a href="../using_whiteboxtools.html"><strong aria-hidden="true">3.</strong> Using WhiteboxTools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python_scripting/scripting.html"><strong aria-hidden="true">3.1.</strong> Interfacing with Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python_scripting/using_whitebox_tools.html"><strong aria-hidden="true">3.1.1.</strong> Using whitebox_tools.py</a></li><li class="chapter-item expanded "><a href="../python_scripting/tool_output.html"><strong aria-hidden="true">3.1.2.</strong> Handling tool output</a></li><li class="chapter-item expanded "><a href="../python_scripting/additional_functions.html"><strong aria-hidden="true">3.1.3.</strong> Additional functions</a></li><li class="chapter-item expanded "><a href="../python_scripting/example.html"><strong aria-hidden="true">3.1.4.</strong> An example Python project</a></li></ol></li><li class="chapter-item expanded "><a href="../r_interface.html"><strong aria-hidden="true">3.2.</strong> Interfacing with R</a></li><li class="chapter-item expanded "><a href="../nim_scripting.html"><strong aria-hidden="true">3.3.</strong> Interfacing with Nim</a></li><li class="chapter-item expanded "><a href="../whitebox_tools_runner.html"><strong aria-hidden="true">3.4.</strong> WhiteboxTools Runner</a></li><li class="chapter-item expanded "><a href="../qgis_plugin.html"><strong aria-hidden="true">3.5.</strong> QGIS plugin</a></li><li class="chapter-item expanded "><a href="../arcgis_plugin.html"><strong aria-hidden="true">3.6.</strong> ArcGIS plugin</a></li><li class="chapter-item expanded "><a href="../command_prompt.html"><strong aria-hidden="true">3.7.</strong> Command-line interface</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/index.html"><strong aria-hidden="true">4.</strong> Tools Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/data_tools.html"><strong aria-hidden="true">4.1.</strong> Data tools</a></li><li class="chapter-item expanded "><a href="../available_tools/geomorphometric_analysis.html"><strong aria-hidden="true">4.2.</strong> Geomorphometric analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis.html" class="active"><strong aria-hidden="true">4.3.</strong> GIS analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_distance_tools.html"><strong aria-hidden="true">4.3.1.</strong> Distance tools</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_overlay_tools.html"><strong aria-hidden="true">4.3.2.</strong> Overlay tools</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_patch_shape_tools.html"><strong aria-hidden="true">4.3.3.</strong> Patch shape tools</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/hydrological_analysis.html"><strong aria-hidden="true">4.4.</strong> Hydrological analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools.html"><strong aria-hidden="true">4.5.</strong> Image processing tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools_filters.html"><strong aria-hidden="true">4.5.1.</strong> Filters</a></li><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools_image_enhancement.html"><strong aria-hidden="true">4.5.2.</strong> Image enchancement</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/lidar_tools.html"><strong aria-hidden="true">4.6.</strong> LiDAR tools</a></li><li class="chapter-item expanded "><a href="../available_tools/mathand_stats_tools.html"><strong aria-hidden="true">4.7.</strong> Mathematical and statistical analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/stream_network_analysis.html"><strong aria-hidden="true">4.8.</strong> Stream network analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">5.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/mosaic.html"><strong aria-hidden="true">5.1.</strong> How can I mosaic hundreds of rasters?</a></li><li class="chapter-item expanded "><a href="../tutorials/lidar.html"><strong aria-hidden="true">5.2.</strong> Processing LiDAR data</a></li></ol></li><li class="chapter-item expanded "><a href="../supported_formats.html"><strong aria-hidden="true">6.</strong> Supported Data Formats</a></li><li class="chapter-item expanded "><a href="../contributing.html"><strong aria-hidden="true">7.</strong> Contributing and Reporting Bugs</a></li><li class="chapter-item expanded "><a href="../limitations.html"><strong aria-hidden="true">8.</strong> Limitations and Memory</a></li><li class="chapter-item expanded "><a href="../license.html"><strong aria-hidden="true">9.</strong> License</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">10.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="../tool_index.html"><strong aria-hidden="true">11.</strong> Tool Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">WhiteboxTools User Manual</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="gis-analysis"><a class="header" href="#gis-analysis">GIS Analysis</a></h1>
<ul>
<li><a href="#AggregateRaster">AggregateRaster</a></li>
<li><a href="#BlockMaximumGridding">BlockMaximumGridding</a></li>
<li><a href="#BlockMinimumGridding">BlockMinimumGridding</a></li>
<li><a href="#Centroid">Centroid</a></li>
<li><a href="#CentroidVector">CentroidVector</a></li>
<li><a href="#Clump">Clump</a></li>
<li><a href="#ConstructVectorTin">ConstructVectorTin</a></li>
<li><a href="#CreateHexagonalVectorGrid">CreateHexagonalVectorGrid</a></li>
<li><a href="#CreatePlane">CreatePlane</a></li>
<li><a href="#CreateRectangularVectorGrid">CreateRectangularVectorGrid</a></li>
<li><a href="#Dissolve">Dissolve</a></li>
<li><a href="#EliminateCoincidentPoints">EliminateCoincidentPoints</a></li>
<li><a href="#ExtendVectorLines">ExtendVectorLines</a></li>
<li><a href="#ExtractNodes">ExtractNodes</a></li>
<li><a href="#ExtractRasterValuesAtPoints">ExtractRasterValuesAtPoints</a></li>
<li><a href="#FilterRasterFeaturesByArea">FilterRasterFeaturesByArea</a></li>
<li><a href="#FindLowestOrHighestPoints">FindLowestOrHighestPoints</a></li>
<li><a href="#IdwInterpolation">IdwInterpolation</a></li>
<li><a href="#LayerFootprint">LayerFootprint</a></li>
<li><a href="#Medoid">Medoid</a></li>
<li><a href="#MinimumBoundingBox">MinimumBoundingBox</a></li>
<li><a href="#MinimumBoundingCircle">MinimumBoundingCircle</a></li>
<li><a href="#MinimumBoundingEnvelope">MinimumBoundingEnvelope</a></li>
<li><a href="#MinimumConvexHull">MinimumConvexHull</a></li>
<li><a href="#NaturalNeighbourInterpolation">NaturalNeighbourInterpolation</a></li>
<li><a href="#NearestNeighbourGridding">NearestNeighbourGridding</a></li>
<li><a href="#PolygonArea">PolygonArea</a></li>
<li><a href="#PolygonLongAxis">PolygonLongAxis</a></li>
<li><a href="#PolygonPerimeter">PolygonPerimeter</a></li>
<li><a href="#PolygonShortAxis">PolygonShortAxis</a></li>
<li><a href="#RadialBasisFunctionInterpolation">RadialBasisFunctionInterpolation</a></li>
<li><a href="#RasterArea">RasterArea</a></li>
<li><a href="#RasterCellAssignment">RasterCellAssignment</a></li>
<li><a href="#RasterPerimeter">RasterPerimeter</a></li>
<li><a href="#Reclass">Reclass</a></li>
<li><a href="#ReclassEqualInterval">ReclassEqualInterval</a></li>
<li><a href="#ReclassFromFile">ReclassFromFile</a></li>
<li><a href="#SmoothVectors">SmoothVectors</a></li>
<li><a href="#TinGridding">TinGridding</a></li>
<li><a href="#VectorHexBinning">VectorHexBinning</a></li>
<li><a href="#VoronoiDiagram">VoronoiDiagram</a></li>
</ul>
<p><a name="AggregateRaster"></a></p>
<h1 id="aggregateraster"><a class="header" href="#aggregateraster">AggregateRaster</a></h1>
<p>This tool can be used to reduce the grid resolution of a raster by a user specified amount. For example, using
an aggregation factor (<code>--agg_factor</code>) of 2 would result in a raster with half the number of rows and columns.
The grid cell values (<code>--type</code>) in the output image will consist of the mean, sum, maximum, minimum, or range
of the overlapping grid cells in the input raster (four cells in the case of an aggregation factor of 2).</p>
<p><em>See Also</em>:
<a href="./image_processing_tools.html#resample"><strong>Resample</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--agg_factor</td><td>Aggregation factor, in pixels</td></tr>
<tr><td>--type</td><td>Statistic used to fill output pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.aggregate_raster(
    i, 
    output, 
    agg_factor=2, 
    type=&quot;mean&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AggregateRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--output_text 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/aggregate_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/12/2017</p>
<p><em>Last Modified</em>: 20/01/2019</p>
<p><a name="BlockMaximumGridding"></a></p>
<h1 id="blockmaximumgridding"><a class="header" href="#blockmaximumgridding">BlockMaximumGridding</a></h1>
<p>Creates a raster grid based on a set of vector points and assigns grid values using a block maximum scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector Points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.block_maximum_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BlockMaximumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=BlockMaximumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/block_maximum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><em>Last Modified</em>: 09/12/2019</p>
<p><a name="BlockMinimumGridding"></a></p>
<h1 id="blockminimumgridding"><a class="header" href="#blockminimumgridding">BlockMinimumGridding</a></h1>
<p>Creates a raster grid based on a set of vector points and assigns grid values using a block minimum scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector Points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.block_minimum_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BlockMinimumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=BlockMinimumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/block_minimum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><em>Last Modified</em>: 09/12/2019</p>
<p><a name="Centroid"></a></p>
<h1 id="centroid"><a class="header" href="#centroid">Centroid</a></h1>
<p>This tool calculates the centroid, or average location, of raster polygon objects.
For vector features, use the <a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a> tool instead.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--text_output</td><td>Optional text output</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.centroid(
    i, 
    output, 
    text_output=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Centroid -v --wd=&quot;/path/to/data/&quot; ^
-i=polygons.tif -o=output.tif
&gt;&gt;./whitebox_tools -r=Centroid ^
-v --wd=&quot;/path/to/data/&quot; -i=polygons.tif -o=output.tif ^
--text_output 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/centroid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/07/2017</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="CentroidVector"></a></p>
<h1 id="centroidvector"><a class="header" href="#centroidvector">CentroidVector</a></h1>
<p>This can be used to identify the centroid point of a vector polyline or polygon feature or a group of
vector points. The output is a vector shapefile of points. For multi-part polyline or polygon features,
the user can optionally specify whether to identify the centroid of each part. The default is to treat
multi-part features a single entity.</p>
<p>For raster features, use the <a href="./gis_analysis.html#centroid"><strong>Centroid</strong></a> tool instead.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#centroid"><strong>Centroid</strong></a>, <a href="./gis_analysis.html#medoid"><strong>Medoid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.centroid_vector(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CentroidVector -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/centroid_vector.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><em>Last Modified</em>: 24/07/2020</p>
<p><a name="Clump"></a></p>
<h1 id="clump"><a class="header" href="#clump">Clump</a></h1>
<p>This tool re-categorizes data in a raster image by grouping cells that form
discrete, contiguous areas into unique categories. Essentially this will produce
a patch map from an input categorical raster, assigning each feature unique
identifiers. The input raster should either be
Boolean (1's and 0's) or categorical. The input raster could be created using
the <a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a> tool or one of the comparison operators (<a href="./mathand_stats_tools.html#greaterthan"><strong>GreaterThan</strong></a>, <a href="./mathand_stats_tools.html#lessthan"><strong>LessThan</strong></a>,
<a href="./mathand_stats_tools.html#equalto"><strong>EqualTo</strong></a>, <a href="./mathand_stats_tools.html#notequalto"><strong>NotEqualTo</strong></a>). Use the <em>treat zeros as background cells</em> options
(<code>--zero_back</code>) if you would like to only assigned contiguous groups of non-zero
values in the raster unique identifiers. Additionally, inter-cell connectivity
can optionally include diagonally neighbouring cells if the <code>--diag</code> flag is
specified.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./mathand_stats_tools.html#greaterthan"><strong>GreaterThan</strong></a>, <a href="./mathand_stats_tools.html#lessthan"><strong>LessThan</strong></a>, <a href="./mathand_stats_tools.html#equalto"><strong>EqualTo</strong></a>, <a href="./mathand_stats_tools.html#notequalto"><strong>NotEqualTo</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--diag</td><td>Flag indicating whether diagonal connections should be considered</td></tr>
<tr><td>--zero_back</td><td>Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clump(
    i, 
    output, 
    diag=True, 
    zero_back=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Clump -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --diag 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/clump.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="ConstructVectorTin"></a></p>
<h1 id="constructvectortin"><a class="header" href="#constructvectortin">ConstructVectorTin</a></h1>
<p>This tool creates a vector triangular irregular network (TIN) for a set of vector points (<code>--input</code>)
using a 2D <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> algorithm.
TIN vertex heights can be assigned based on either a field in the vector's attribute table (<code>--field</code>),
or alternatively, if the vector is of a z-dimension <em>ShapeTypeDimension</em>, the point z-values may be
used for vertex heights (<code>--use_z</code>). For LiDAR points, use the <a href="./thread&#x27;main&#x27;panickedat&#x27;_unrecognizedtoolname_lidarconstructvectortin.&#x27;,whitebox-tools-appsrcmain.rs:72:21note:runwith%60rust_backtrace=1%60environmentvariabletodisplayabacktrace.html#lidarconstructvectortin"><strong>LidarConstructVectorTIN</strong></a> tool instead.</p>
<p>Triangulation often creates very long, narrow triangles near the edges of the data coverage, particularly
in convex regions along the data boundary. To avoid these spurious triangles, the user may optionally
specify the maximum allowable edge length of a triangular facet (<code>--max_triangle_edge_length</code>).</p>
<p><em>See Also</em>:
<a href="./thread&#x27;main&#x27;panickedat&#x27;_unrecognizedtoolname_lidarconstructvectortin.&#x27;,whitebox-tools-appsrcmain.rs:72:21note:runwith%60rust_backtrace=1%60environmentvariabletodisplayabacktrace.html#lidarconstructvectortin"><strong>LidarConstructVectorTIN</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--max_triangle_edge_length</td><td>Optional maximum triangle edge length; triangles larger than this size will not be gridded</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.construct_vector_tin(
    i, 
    output, 
    field=None, 
    use_z=False, 
    max_triangle_edge_length=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConstructVectorTIN -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=HEIGHT ^
-o=tin.shp
&gt;&gt;./whitebox_tools -r=ConstructVectorTIN -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=tin.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/construct_vector_tin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/09/2018</p>
<p><em>Last Modified</em>: 07/12/2019</p>
<p><a name="CreateHexagonalVectorGrid"></a></p>
<h1 id="createhexagonalvectorgrid"><a class="header" href="#createhexagonalvectorgrid">CreateHexagonalVectorGrid</a></h1>
<p>This tool can be used to create a hexagonal vector grid. The extent of the hexagonal
grid is based on the extent of a user-specified base file (any supported raster format,
shapefiles, or LAS files). The user must also specify the hexagonal cell width (<code>--width</code>)
and whether the hexagonal orientation (<code>--orientation</code>) is <code>horizontal</code> or <code>vertical</code>.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#createrectangularvectorgrid"><strong>CreateRectangularVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base, --input</td><td>Input base file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--width</td><td>The grid cell width</td></tr>
<tr><td>--orientation</td><td>Grid Orientation, 'horizontal' or 'vertical'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_hexagonal_vector_grid(
    i, 
    output, 
    width, 
    orientation=&quot;horizontal&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreateHexagonalVectorGrid -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--orientation=vertical 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/create_hexagonal_vector_grid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><em>Last Modified</em>: 19/05/2020</p>
<p><a name="CreatePlane"></a></p>
<h1 id="createplane"><a class="header" href="#createplane">CreatePlane</a></h1>
<p>This tool can be used to create a new raster with values that are determined by the equation of a simple plane. The user
must specify the name of a base raster (<code>--base</code>) from which the output raster coordinate and dimensional information
will be taken. In addition the user must specify the values of the planar slope gradient (S; <code>--gradient</code>; <code>--aspect</code>)
in degrees, the planar slope direction or aspect (A; 0 to 360 degrees), and an constant value (k; <code>--constant</code>). The
equation of the plane is as follows:</p>
<blockquote>
<p>Z = tan(S) × sin(A - 180) × X + tan(S) × cos(A - 180) × Y + k</p>
</blockquote>
<p>where X and Y are the X and Y coordinates of each grid cell in the grid. Notice that A is the direction,
or azimuth, that the plane is facing</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--base</td><td>Input base raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--gradient</td><td>Slope gradient in degrees (-85.0 to 85.0)</td></tr>
<tr><td>--aspect</td><td>Aspect (direction) in degrees clockwise from north (0.0-360.0)</td></tr>
<tr><td>--constant</td><td>Constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_plane(
    base, 
    output, 
    gradient=15.0, 
    aspect=90.0, 
    constant=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreatePlane -v --wd=&quot;/path/to/data/&quot; ^
--base=base.tif -o=NewRaster.tif --gradient=15.0 ^
--aspect=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/create_plane.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="CreateRectangularVectorGrid"></a></p>
<h1 id="createrectangularvectorgrid"><a class="header" href="#createrectangularvectorgrid">CreateRectangularVectorGrid</a></h1>
<p>This tool can be used to create a rectangular vector grid. The extent of the rectangular
grid is based on the extent of a user-specified base file (any supported raster format,
shapefiles, or LAS files). The user must also specify the origin of the grid (<code>--xorig</code>
and <code>--yorig</code>) and the grid cell width and height (<code>--width</code> and <code>--height</code>).</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base, --input</td><td>Input base file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--width</td><td>The grid cell width</td></tr>
<tr><td>--height</td><td>The grid cell height</td></tr>
<tr><td>--xorig</td><td>The grid origin x-coordinate</td></tr>
<tr><td>--yorig</td><td>The grid origin y-coordinate</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_rectangular_vector_grid(
    i, 
    output, 
    width, 
    height, 
    xorig=0, 
    yorig=0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreateRectangularVectorGrid -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--height=10.0 --xorig=0.0 --yorig=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/create_rectangular_vector_grid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><em>Last Modified</em>: 19/05/2020</p>
<p><a name="Dissolve"></a></p>
<h1 id="dissolve"><a class="header" href="#dissolve">Dissolve</a></h1>
<p>This tool can be used to remove the interior, or shared, boundaries within a vector
polygon coverage. You can either dissolve all interior boundaries or dissolve those
boundaries along polygons with the same value of a user-specified attribute within
the vector's attribute table. It may be desirable to use the <code>VectorCleaning</code> tool
to correct any topological errors resulting from the slight misalignment of nodes
along shared boundaries in the vector coverage before performing the <a href="./gis_analysis.html#dissolve"><strong>Dissolve</strong></a> operation.</p>
<p><em>See Also</em>:
<a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a>, <a href="./gis_analysis_overlay_tools.html#polygonize"><strong>Polygonize</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>--field</td><td>Dissolve field attribute (optional)</td></tr>
<tr><td>-o, --output</td><td>Output vector file</td></tr>
<tr><td>--snap</td><td>Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.dissolve(
    i, 
    output, 
    field=None, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Dissolve -v --wd=&quot;/path/to/data/&quot; ^
-input=layer1.shp --field=SIZE -o=out_file.shp ^
--snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/dissolve.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/11/2018</p>
<p><em>Last Modified</em>: 22/11/2018</p>
<p><a name="EliminateCoincidentPoints"></a></p>
<h1 id="eliminatecoincidentpoints"><a class="header" href="#eliminatecoincidentpoints">EliminateCoincidentPoints</a></h1>
<p>This tool can be used to remove any coincident, or nearly coincident, points
from a vector points file. The user must specify the name of the input file,
which must be of a POINTS ShapeType, the output file name, and the tolerance
distance. All points that are within the specified tolerance distance will be
eliminated from the output file. A tolerance distance of 0.0 indicates that
points must be exactly coincident to be removed.</p>
<p><em>See Also</em>:
<a href="./lidar_tools.html#lidarremoveduplicates"><strong>LidarRemoveDuplicates</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--tolerance</td><td>The distance tolerance for points</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.eliminate_coincident_points(
    i, 
    output, 
    tolerance, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EliminateCoincidentPoints -v ^
--wd=&quot;/path/to/data/&quot; -i=input_file.shp -o=out_file.shp ^
--tolerance=0.01 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/eliminate_coincident_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="ExtendVectorLines"></a></p>
<h1 id="extendvectorlines"><a class="header" href="#extendvectorlines">ExtendVectorLines</a></h1>
<p>This tool can be used to extend vector lines by a specified distance. The user must
input the names of the input and output shapefiles, the distance to extend features
by, and whether to extend both ends, line starts, or line ends. The input shapefile
must be of a POLYLINE base shape type and should be in a projected coordinate system.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector polyline file</td></tr>
<tr><td>-o, --output</td><td>Output vector polyline file</td></tr>
<tr><td>--dist</td><td>The distance to extend</td></tr>
<tr><td>--extend</td><td>Extend direction, 'both ends' (default), 'line start', 'line end'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extend_vector_lines(
    i, 
    output, 
    dist, 
    extend=&quot;both ends&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtendVectorLines -v ^
--wd=&quot;/path/to/data/&quot; -i=in_file.shp -o=out_file.shp ^
--dist=10.0 --extend='both ends' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/extend_vector_lines.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="ExtractNodes"></a></p>
<h1 id="extractnodes"><a class="header" href="#extractnodes">ExtractNodes</a></h1>
<p>This tool converts vector lines or polygons into vertex points. The user must specify the
name of the input vector, which must be of a polyline or polygon base shape type, and
the name of the output point-type vector.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector lines or polygon file</td></tr>
<tr><td>-o, --output</td><td>Output vector points file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_nodes(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractNodes -v --wd=&quot;/path/to/data/&quot; ^
-i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/extract_nodes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="ExtractRasterValuesAtPoints"></a></p>
<h1 id="extractrastervaluesatpoints"><a class="header" href="#extractrastervaluesatpoints">ExtractRasterValuesAtPoints</a></h1>
<p>This tool can be used to extract the values of one or more rasters (<code>--inputs</code>) at the sites of a set of vector points.
By default, the data is output to the attribute table of the input points (<code>--points</code>) vector; however,
if the <code>--out_text</code> parameter is specified, the tool will additionally output point values as text data
to standard output (<em>stdout</em>). Attribute fields will be added to the table of the points file, with field
names, <em>VALUE1</em>, <em>VALUE2</em>, <em>VALUE3</em>, etc. each corresponding to the order of input rasters.</p>
<p>If you need to plot a chart of values from a raster stack at a set of points, the <a href="./image_processing_tools.html#imagestackprofile"><strong>ImageStackProfile</strong></a> may be
more suitable for this application.</p>
<p><em>See Also</em>:
<a href="./image_processing_tools.html#imagestackprofile"><strong>ImageStackProfile</strong></a>, <a href="./gis_analysis.html#findlowestorhighestpoints"><strong>FindLowestOrHighestPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs</td><td>Input raster files</td></tr>
<tr><td>--points</td><td>Input vector points file</td></tr>
<tr><td>--out_text</td><td>Output point values as text? Otherwise, the only output is to to the points file's attribute table</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_raster_values_at_points(
    inputs, 
    points, 
    out_text=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractRasterValuesAtPoints -v ^
--wd=&quot;/path/to/data/&quot; -i='image1.tif;image2.tif;image3.tif' ^
-points=points.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/extract_raster_values_at_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/06/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="FilterRasterFeaturesByArea"></a></p>
<h1 id="filterrasterfeaturesbyarea"><a class="header" href="#filterrasterfeaturesbyarea">FilterRasterFeaturesByArea</a></h1>
<p>This tool takes an input raster (<code>--input</code>) containing integer-labelled features, such as the output of the <a href="./gis_analysis.html#clump"><strong>Clump</strong></a> tool,
and removes all features that are smaller than a user-specified size (<code>--threshold</code>), measured in grid cells. The
user must specify the replacement value for removed features using the <code>--background</code> parameter, which can be either
<code>zero</code> or <code>nodata</code>.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#clump"><strong>Clump</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--threshold</td><td>Remove features with fewer grid cells than this threshold value</td></tr>
<tr><td>--background</td><td>Background value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.filter_raster_features_by_area(
    i, 
    output, 
    threshold, 
    background=&quot;zero&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FilterRasterFeaturesByArea -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--background=zero 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/filter_raster_features_by_area.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="FindLowestOrHighestPoints"></a></p>
<h1 id="findlowestorhighestpoints"><a class="header" href="#findlowestorhighestpoints">FindLowestOrHighestPoints</a></h1>
<p>This tool locates the lowest and/or highest cells in a raster and outputs these locations to a vector
points file. The user must specify the name of the input raster (<code>--input</code>) and the name of the output
vector file (<code>--output</code>). The user also has the option (<code>--out_type</code>) to locate either the lowest value,
highest value, or both values. The output vector's attribute table will contain fields for the points
XY coordinates and their values.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#extractrastervaluesatpoints"><strong>ExtractRasterValuesAtPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output vector points file</td></tr>
<tr><td>--out_type</td><td>Output type; one of 'area' (default) and 'volume'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_lowest_or_highest_points(
    i, 
    output, 
    out_type=&quot;lowest&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindLowestOrHighestPoints -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tif -o=out.shp ^
--out_type=highest 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/find_lowest_or_highest_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/06/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="IdwInterpolation"></a></p>
<h1 id="idwinterpolation"><a class="header" href="#idwinterpolation">IdwInterpolation</a></h1>
<p>points or a fixed neighbourhood size. This tool is currently configured to perform the later
only, using a FixedRadiusSearch structure. Using a fixed number of neighbours will require
use of a KD-tree structure. I've been testing one Rust KD-tree library but its performance
does not appear to be satisfactory compared to the FixedRadiusSearch. I will need to explore
other options here.</p>
<p>Another change that will need to be implemented is the use of a nodal function. The original
Whitebox GAT tool allows for use of a constant or a quadratic. This tool only allows the
former.
This tool interpolates vector points into a raster surface using an inverse-distance weighted scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector Points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--weight</td><td>IDW weight value</td></tr>
<tr><td>--radius</td><td>Search Radius in map units</td></tr>
<tr><td>--min_points</td><td>Minimum number of points</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.idw_interpolation(
    i, 
    field, 
    output, 
    use_z=False, 
    weight=2.0, 
    radius=None, 
    min_points=None, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IdwInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--weight=2.0 --radius=4.0 --min_points=3 ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=IdwInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--weight=2.0 --radius=4.0 --min_points=3 ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/idw_interpolation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/05/2018</p>
<p><em>Last Modified</em>: 9/12/2019</p>
<p><a name="LayerFootprint"></a></p>
<h1 id="layerfootprint"><a class="header" href="#layerfootprint">LayerFootprint</a></h1>
<p>This tool creates a vector polygon footprint of the area covered by a raster grid or vector
layer. It will create a vector rectangle corresponding to the bounding box. The user must
specify the name of the input file, which may be either a Whitebox raster or a vector, and
the name of the output file.</p>
<p>If an input raster grid is specified which has an irregular shape, i.e. it contains NoData
values at the edges, the resulting vector will still correspond to the full grid extent,
ignoring the irregular boundary. If this is not the desired effect, you should reclass the
grid such that all cells containing valid values are assigned some positive, non-zero value,
and then use the <a href="./data_tools.html#rastertovectorpolygons"><strong>RasterToVectorPolygons</strong></a> tool to vectorize the irregular-shaped extent
boundary.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <a href="./data_tools.html#rastertovectorpolygons"><strong>RasterToVectorPolygons</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster or vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.layer_footprint(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LayerFootprint -v --wd=&quot;/path/to/data/&quot; ^
-i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/layer_footprint.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="Medoid"></a></p>
<h1 id="medoid"><a class="header" href="#medoid">Medoid</a></h1>
<p>This tool calculates the medoid for a series of vector features contained in a shapefile. The medoid
of a two-dimensional feature is conceptually similar its centroid, or mean position, but the medoid
is always a members of the input feature data set. Thus, the medoid is a measure of central tendency
that is robust in the presence of outliers. If the input vector is of a POLYLINE or POLYGON ShapeType,
the nodes of each feature will be used to estimate the feature medoid. If the input vector is of a
POINT base ShapeType, the medoid will be calculated for the collection of points. While there are
more than one competing method of calculating the medoid, this tool uses an algorithm that works as follows:</p>
<ol>
<li>The x-coordinate and y-coordinate of each point/node are placed into two arrays.</li>
<li>The x- and y-coordinate arrays are then sorted and the median x-coordinate (Med X) and median
y-coordinate (Med Y) are calculated.</li>
<li>The point/node in the dataset that is nearest the point (Med X, Med Y) is identified as the medoid.</li>
</ol>
<p><em>See Also</em>:
<a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.medoid(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Medoid -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/medoid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><em>Last Modified</em>: 24/07/2020</p>
<p><a name="MinimumBoundingBox"></a></p>
<h1 id="minimumboundingbox"><a class="header" href="#minimumboundingbox">MinimumBoundingBox</a></h1>
<p>This tool delineates the minimum bounding box (MBB) for a group of vectors. The MBB is the smallest box to
completely enclose a feature. The algorithm works by rotating the feature, calculating the axis-aligned
bounding box for each rotation, and finding the box with the smallest area, length, width, or perimeter. The
MBB is needed to compute several shape indices, such as the Elongation Ratio. The <code>MinimumBoundingEnvelop</code>
tool can be used to calculate the axis-aligned bounding rectangle around each feature in a vector file.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--criterion</td><td>Minimization criterion; options include 'area' (default), 'length', 'width', and 'perimeter'</td></tr>
<tr><td>--features</td><td>Find the minimum bounding rectangles around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_box(
    i, 
    output, 
    criterion=&quot;area&quot;, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingBox -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp ^
--criterion=length --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/minimum_bounding_box.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="MinimumBoundingCircle"></a></p>
<h1 id="minimumboundingcircle"><a class="header" href="#minimumboundingcircle">MinimumBoundingCircle</a></h1>
<p>This tool delineates the minimum bounding circle (MBC) for a group of vectors. The MBC is the smallest enclosing
circle to completely enclose a feature.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--features</td><td>Find the minimum bounding circle around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_circle(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingCircle -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/minimum_bounding_circle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="MinimumBoundingEnvelope"></a></p>
<h1 id="minimumboundingenvelope"><a class="header" href="#minimumboundingenvelope">MinimumBoundingEnvelope</a></h1>
<p>This tool delineates the minimum bounding axis-aligned box for a group of vector features. The is the smallest
rectangle to completely enclose a feature, in which the sides of the envelope are aligned with the x and y
axis of the coordinate system. The <a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a> can be used instead to find the smallest possible
non-axis aligned rectangular envelope.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--features</td><td>Find the minimum bounding envelop around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_envelope(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingEnvelope -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/minimum_bounding_envelope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/09/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="MinimumConvexHull"></a></p>
<h1 id="minimumconvexhull"><a class="header" href="#minimumconvexhull">MinimumConvexHull</a></h1>
<p>This tool creates a vector convex polygon around vector features. The convex hull
is a convex closure of a set of points or polygon verticies and can be may be
conceptualized as the shape enclosed by a rubber band stretched around the point
set. The convex hull has many applications and is most notably used in various
shape indices. The Delaunay triangulation of a point set and its dual, the
Voronoi diagram, are mathematically related to convex hulls.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--features</td><td>Find the hulls around each vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_convex_hull(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumConvexHull -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/minimum_convex_hull.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/09/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="NaturalNeighbourInterpolation"></a></p>
<h1 id="naturalneighbourinterpolation"><a class="header" href="#naturalneighbourinterpolation">NaturalNeighbourInterpolation</a></h1>
<p>This tool can be used to interpolate a set of input vector points (<code>--input</code>) onto a raster grid using
Sibson's (1981) natural neighbour method. Similar to inverse-distance-weight interpolation (<a href="./gis_analysis.html#idwinterpolation"><strong>IdwInterpolation</strong></a>),
the natural neighbour method performs a weighted averaging of nearby point values to estimate the attribute
(<code>--field</code>) value at grid cell intersections in the output raster (<code>--output</code>). However, the two methods differ
quite significantly in the way that neighbours are identified and in the weighting scheme. First, natural neigbhour
identifies neighbours to be used in the interpolation of a point by finding the points connected to the
estimated value location in a <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a>, that
is, the so-called <em>natural neighbours</em>. This approach has the main advantage of not having to specify an arbitrary
search distance or minimum number of nearest neighbours like many other interpolators do. Weights in the natural
neighbour scheme are determined using an area-stealing approach, whereby the weight assigned to a neighbour's value
is determined by the proportion of its <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi polygon</a> that would
be lost by inserting the interpolation point into the Voronoi diagram. That is, inserting the interpolation point into
the Voronoi diagram results in the creation of a new polygon and shrinking the sizes of the Voronoi polygons associated
with each of the natural neighbours. The larger the area by which a neighbours polygon is reduced through the
insertion, relative to the polygon of the interpolation point, the greater the weight given to the neighbour point's
value in the interpolation. Interpolation weights sum to one because the sum of the reduced polygon areas must
account for the entire area of the interpolation points polygon.</p>
<p>The user must specify the attribute field containing point values (<code>--field</code>). Alternatively, if the input Shapefile
contains z-values, the interpolation may be based on these values (<code>--use_z</code>). Either an output grid resolution
(<code>--cell_size</code>) must be specified or alternatively an existing base file (<code>--base</code>) can be used to determine the
output raster's (<code>--output</code>) resolution and spatial extent. Natural neighbour interpolation generally produces a
satisfactorily smooth surface within the region of data points but can produce spurious breaks in the surface
outside of this region. Thus, it is recommended that the output surface be clipped to the convex hull of the input
points (<code>--clip</code>).</p>
<p><em>Reference</em>:</p>
<p>Sibson, R. (1981). &quot;A brief description of natural neighbor interpolation (Chapter 2)&quot;. In V. Barnett (ed.).
Interpolating Multivariate Data. Chichester: John Wiley. pp. 21–36.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#idwinterpolation"><strong>IdwInterpolation</strong></a>, <a href="./gis_analysis.html#nearestneighbourgridding"><strong>NearestNeighbourGridding</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
<tr><td>--clip</td><td>Clip the data to the convex hull of the points?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.natural_neighbour_interpolation(
    i, 
    output, 
    field=None, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    clip=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NaturalNeighbourInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=HEIGHT ^
-o=surface.tif --resolution=10.0 --clip 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/natural_neighbour_interpolation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 08/12/2019</p>
<p><em>Last Modified</em>: 10/12/2019</p>
<p><a name="NearestNeighbourGridding"></a></p>
<h1 id="nearestneighbourgridding"><a class="header" href="#nearestneighbourgridding">NearestNeighbourGridding</a></h1>
<p>Creates a raster grid based on a set of vector points and assigns grid values using the nearest neighbour.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector Points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
<tr><td>--max_dist</td><td>Maximum search distance (optional)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.nearest_neighbour_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NearestNeighbourGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=NearestNeighbourGridding ^
-v --wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif --max_dist=5.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/nearest_neighbour_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><em>Last Modified</em>: 09/12/2019</p>
<p><a name="PolygonArea"></a></p>
<h1 id="polygonarea"><a class="header" href="#polygonarea">PolygonArea</a></h1>
<p>This tool calculates the area of vector polygons, adding the result to the
vector's attribute table (AREA field). The area calculation will account
for any holes contained within polygons. The vector should be in a
projected coordinate system.</p>
<p>To calculate the area of raster polygons, use the <a href="./gis_analysis.html#rasterarea"><strong>RasterArea</strong></a> tool instead.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#rasterarea"><strong>RasterArea</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_area(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonArea -v --wd=&quot;/path/to/data/&quot; ^
--input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/polygon_area.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="PolygonLongAxis"></a></p>
<h1 id="polygonlongaxis"><a class="header" href="#polygonlongaxis">PolygonLongAxis</a></h1>
<p>This tool can be used to map the long axis of polygon features. The long axis is the
longer of the two primary axes of the minimum bounding box (MBB), i.e. the smallest box
to completely enclose a feature. The long axis is drawn for each polygon in the input
vector file such that it passes through the centre point of the MBB. The output file is
therefore a vector of simple two-point polylines forming a vector field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector polygons file</td></tr>
<tr><td>-o, --output</td><td>Output vector polyline file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_long_axis(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonLongAxis -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/polygon_long_axis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><em>Last Modified</em>: 03/03/2020</p>
<p><a name="PolygonPerimeter"></a></p>
<h1 id="polygonperimeter"><a class="header" href="#polygonperimeter">PolygonPerimeter</a></h1>
<p>This tool calculates the perimeter of vector polygons, adding the result
to the vector's attribute table (PERIMETER field). The area calculation will
account for any holes contained within polygons. The vector should be in a
a projected coordinate system.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_perimeter(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonPerimeter -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/polygon_perimeter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="PolygonShortAxis"></a></p>
<h1 id="polygonshortaxis"><a class="header" href="#polygonshortaxis">PolygonShortAxis</a></h1>
<p>This tool can be used to map the short axis of polygon features. The short axis is the
shorter of the two primary axes of the minimum bounding box (MBB), i.e. the smallest box
to completely enclose a feature. The short axis is drawn for each polygon in the input
vector file such that it passes through the centre point of the MBB. The output file is
therefore a vector of simple two-point polylines forming a vector field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector polygons file</td></tr>
<tr><td>-o, --output</td><td>Output vector polyline file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_short_axis(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonShortAxis -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/polygon_short_axis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><em>Last Modified</em>: 03/03/2020</p>
<p><a name="RadialBasisFunctionInterpolation"></a></p>
<h1 id="radialbasisfunctioninterpolation"><a class="header" href="#radialbasisfunctioninterpolation">RadialBasisFunctionInterpolation</a></h1>
<p>This tool interpolates vector points into a raster surface using a radial basis function (RBF) scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--radius</td><td>Search Radius (in map units)</td></tr>
<tr><td>--min_points</td><td>Minimum number of points</td></tr>
<tr><td>--func_type</td><td>Radial basis function type; options are 'ThinPlateSpline' (default), 'PolyHarmonic', 'Gaussian', 'MultiQuadric', 'InverseMultiQuadric'</td></tr>
<tr><td>--poly_order</td><td>Polynomial order; options are 'none' (default), 'constant', 'affine'</td></tr>
<tr><td>--weight</td><td>Weight parameter used in basis function</td></tr>
<tr><td>--cell_size</td><td>Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.radial_basis_function_interpolation(
    i, 
    field, 
    output, 
    use_z=False, 
    radius=None, 
    min_points=None, 
    func_type=&quot;ThinPlateSpline&quot;, 
    poly_order=&quot;none&quot;, 
    weight=0.1, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RadialBasisFunctionInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--weight=2.0 --radius=4.0 --min_points=3 --cell_size=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/radial_basis_function_interpolation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/12/2019</p>
<p><em>Last Modified</em>: 10/12/2019</p>
<p><a name="RasterArea"></a></p>
<h1 id="rasterarea"><a class="header" href="#rasterarea">RasterArea</a></h1>
<p>This tools estimates the area of each category, polygon, or patch in an input raster. The input raster must be categorical
in data scale. Rasters with floating-point cell values are not good candidates for an area analysis. The user must specify
whether the output is given in <code>grid cells</code> or <code>map units</code> (<code>--units</code>). Map Units are physical units, e.g. if the rasters's
scale is in metres, areas will report in square-metres. Notice that square-metres can be converted into hectares by dividing
by 10,000 and into square-kilometres by dividing by 1,000,000. If the input raster is in geographic coordinates (i.e.
latitude and longitude) a warning will be issued and areas will be estimated based on per-row calculated degree lengths.</p>
<p>The tool can be run with a raster output (<code>--output</code>), a text output (<code>--out_text</code>), or both. If niether outputs are specified,
the tool will automatically output a raster named <code>area.tif</code>.</p>
<p>Zero values in the input raster may be excluded from the area analysis if the <code>--zero_back</code> flag is used.</p>
<p>To calculate the area of vector polygons, use the <a href="./gis_analysis.html#polygonarea"><strong>PolygonArea</strong></a> tool instead.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#polygonarea"><strong>PolygonArea</strong></a>, <a href="./mathand_stats_tools.html#rasterhistogram"><strong>RasterHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--out_text</td><td>Would you like to output polygon areas to text?</td></tr>
<tr><td>--units</td><td>Area units; options include 'grid cells' and 'map units'</td></tr>
<tr><td>--zero_back</td><td>Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_area(
    i, 
    output=None, 
    out_text=False, 
    units=&quot;grid cells&quot;, 
    zero_back=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterArea -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --out_text --units='grid cells' ^
--zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/raster_area.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/02/2019</p>
<p><em>Last Modified</em>: 04/12/2019</p>
<p><a name="RasterCellAssignment"></a></p>
<h1 id="rastercellassignment"><a class="header" href="#rastercellassignment">RasterCellAssignment</a></h1>
<p>This tool can be used to create a new raster with the same coordinates and dimensions
(i.e. rows and columns) as an existing base image. Grid cells in the new raster will be
assigned either the row or column number or the x- or y-coordinate, depending on the
selected option (<code>--assign</code> flag). The user must also specify the name of the base
image (<code>--input</code>).</p>
<p><em>See Also</em>:
<a href="./data_tools.html#newrasterfrombase"><strong>NewRasterFromBase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>-a, --assign</td><td>Which variable would you like to assign to grid cells? Options include 'column', 'row', 'x', and 'y'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_cell_assignment(
    i, 
    output, 
    assign=&quot;column&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterCellAssignment -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--assign='column' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/raster_cell_assignment.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Daniel Newman</p>
<p><em>Created</em>: August 10, 2017</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="RasterPerimeter"></a></p>
<h1 id="rasterperimeter"><a class="header" href="#rasterperimeter">RasterPerimeter</a></h1>
<p>This tool can be used to measure the length of the perimeter of polygon features in a raster layer. The user must
specify the name of the input raster file (<code>--input</code>) and optionally an output raster (<code>--output</code>), which is the
raster layer containing the input features assigned the perimeter length. The user may also optionally choose to output text
data (<code>--out_text</code>). Raster-based perimeter estimation uses the accurate, anti-aliasing algorithm of
Prashker (2009).</p>
<p>The input file must be of a categorical data type, containing discrete polygon features that have been assigned unique identifiers.
Such rasters are often created by region-grouping (<a href="./gis_analysis.html#clump"><strong>Clump</strong></a>) a classified raster.</p>
<p><em>Reference</em>:</p>
<p>Prashker, S. (2009) An anti-aliasing algorithm for calculating the perimeter of raster polygons. Geotec, Ottawa and
Geomtics Atlantic, Wolfville, NS.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#rasterarea"><strong>RasterArea</strong></a>, <a href="./gis_analysis.html#clump"><strong>Clump</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--out_text</td><td>Would you like to output polygon areas to text?</td></tr>
<tr><td>--units</td><td>Area units; options include 'grid cells' and 'map units'</td></tr>
<tr><td>--zero_back</td><td>Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_perimeter(
    i, 
    output=None, 
    out_text=False, 
    units=&quot;grid cells&quot;, 
    zero_back=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterPerimeter -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --out_text ^
--units='grid cells' --zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/raster_perimeter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/12/2019</p>
<p><em>Last Modified</em>: 18/12/2019</p>
<p><a name="Reclass"></a></p>
<h1 id="reclass"><a class="header" href="#reclass">Reclass</a></h1>
<p>This tool creates a new raster in which the value of each grid cell is determined by an input raster (<code>--input</code>) and a
collection of user-defined classes. The user must specify the <em>New</em> value, the <em>From</em> value, and the <em>To Just Less Than</em>
value of each class triplet of the reclass string. Classes must be mutually exclusive, i.e. non-overlapping. For example:</p>
<blockquote>
<p>--reclass_vals='0.0;0.0;1.0;1.0;1.0;2.0'</p>
</blockquote>
<p>The above reclass string assigns 0.0 to all grid cells in the input image with values from 0.0-1.0 and an output
value of 1.0 from to inputs from 1.0-2.0. Alternatively, if the <code>--assign_mode</code> flag is specified, <a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a> will
operate in assign mode, using a reclass string composed of paired values:</p>
<blockquote>
<p>--reclass_vals='0.0;1.0;1.0;2.0'</p>
</blockquote>
<p>Here, 0.0 is assigned to input grid cell values of 1.0 and 1.0 is output for all input cells with a value of 2.0. Users
may add the text strings <em>min</em> and <em>max</em> in the class definitions to stand in for the raster's minimum and maximum values.
For example:</p>
<blockquote>
<p>--reclass_vals='0.0;min;1.0;1.0;1.0;max'</p>
</blockquote>
<p>Any values in the input raster that do not fall within one of the classes will be assigned its original value in the
output raster. NoData values in the input raster will be assigned NoData values in the output raster, unless NoData is
used in one of the user-defined reclass ranges (notice that it is valid to enter 'NoData' in these ranges).</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#reclassequalinterval"><strong>ReclassEqualInterval</strong></a>, <a href="./gis_analysis.html#reclassfromfile"><strong>ReclassFromFile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--reclass_vals</td><td>Reclassification triplet values (new value; from value; to less than), e.g. '0.0;0.0;1.0;1.0;1.0;2.0'</td></tr>
<tr><td>--assign_mode</td><td>Optional Boolean flag indicating whether to operate in assign mode, reclass_vals values are interpreted as new value; old value pairs</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass(
    i, 
    output, 
    reclass_vals, 
    assign_mode=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Reclass -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif ^
--reclass_vals='0.0;0.0;1.0;1.0;1.0;2.0'
&gt;&gt;./whitebox_tools ^
-r=Reclass -v --wd=&quot;/path/to/data/&quot; -i='input.tif' ^
-o=output.tif --reclass_vals='10;1;20;2;30;3;40;4' ^
--assign_mode 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/reclass.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/09/2017</p>
<p><em>Last Modified</em>: 13/02/2020</p>
<p><a name="ReclassEqualInterval"></a></p>
<h1 id="reclassequalinterval"><a class="header" href="#reclassequalinterval">ReclassEqualInterval</a></h1>
<p>This tool reclassifies the values in an input raster (<code>--input</code>) file based on an equal-interval scheme, where the
user must specify the reclass interval value (<code>--interval</code>), the starting value (<code>--start_val</code>), and optionally,
the ending value (<code>--end_val</code>). Grid cells containing values that fall outside of the range defined by the starting
and ending values, will be assigned their original values in the output grid. If the user does not specify an ending
value, the tool will assign a very large positive value.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./gis_analysis.html#reclassfromfile"><strong>ReclassFromFile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--interval</td><td>Class interval size</td></tr>
<tr><td>--start_val</td><td>Optional starting value (default is input minimum value)</td></tr>
<tr><td>--end_val</td><td>Optional ending value (default is input maximum value)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass_equal_interval(
    i, 
    output, 
    interval=10.0, 
    start_val=None, 
    end_val=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ReclassEqualInterval -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--interval=10.0 --start_val=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/reclass_equal_interval.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/07/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="ReclassFromFile"></a></p>
<h1 id="reclassfromfile"><a class="header" href="#reclassfromfile">ReclassFromFile</a></h1>
<p>This tool creates a new raster image in which the value of each grid cell is determined by the values in an
input raster image (<code>--input</code>) and a reclass file (<code>--reclass_file</code>). The reclass file is a text file
containing two or three columns, delimited (i.e. separated) by either a space, tab, or comma. The columns
describe respectively the <em>New</em> value, the <em>From</em> value, and the <em>To Just Less Than</em> value. Classes must be
mutually exclusive, i.e. non-overlapping. Users may add the text strings <em>min</em> and <em>max</em> in the class definitions
to stand in for the raster's minimum and maximum values.</p>
<p>If only two columns are present in the reclass file, i.e. the <em>From</em> column is left blank, the tool will
operate in assign mode. That is, any cell in the input image that is equal to the <em>From</em> value (contained
in the second column) will be assigned the <em>New</em> value (contained in the first column) in the output image.</p>
<p>Any values in the input raster that do not fall within one of the classes will be assigned its original
value in the output raster. NoData values in the input raster will be assigned NoData values in the output
raster.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./gis_analysis.html#reclassequalinterval"><strong>ReclassEqualInterval</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>--reclass_file</td><td>Input text file containing reclass ranges</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass_from_file(
    i, 
    reclass_file, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ReclassFromFile -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' ^
--reclass_file='reclass.txt' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/reclass_from_file.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/09/2017</p>
<p><em>Last Modified</em>: 13/02/2020</p>
<p><a name="SmoothVectors"></a></p>
<h1 id="smoothvectors"><a class="header" href="#smoothvectors">SmoothVectors</a></h1>
<p>This tool smooths a vector coverage of either a POLYLINE or POLYGON base ShapeType. The algorithm
uses a simple moving average method for smoothing, where the size of the averaging window is specified
by the user. The default filter size is 3 and can be any odd integer larger than or equal to 3. The
larger the averaging window, the greater the degree of line smoothing.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector POLYLINE or POLYGON file</td></tr>
<tr><td>-o, --output</td><td>Output vector file</td></tr>
<tr><td>--filter</td><td>The filter size, any odd integer greater than or equal to 3; default is 3</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.smooth_vectors(
    i, 
    output, 
    filter=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SmoothVectors -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp --filter=9 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/smooth_vectors.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/10/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="TinGridding"></a></p>
<h1 id="tingridding"><a class="header" href="#tingridding">TinGridding</a></h1>
<p>Creates a raster grid based on a triangular irregular network (TIN) fitted to vector points
and linear interpolation within each triangular-shaped plane. The TIN creation algorithm is based on
<a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a>.</p>
<p>The user must specify the attribute field containing point values (<code>--field</code>). Alternatively, if the input Shapefile
contains z-values, the interpolation may be based on these values (<code>--use_z</code>). Either an output grid resolution
(<code>--cell_size</code>) must be specified or alternatively an existing base file (<code>--base</code>) can be used to determine the
output raster's (<code>--output</code>) resolution and spatial extent. Natural neighbour interpolation generally produces a
satisfactorily smooth surface within the region of data points but can produce spurious breaks in the surface
outside of this region. Thus, it is recommended that the output surface be clipped to the convex hull of the input
points (<code>--clip</code>).</p>
<p><em>See Also</em>:
<a href="./lidar_tools.html#lidartingridding"><strong>LidarTINGridding</strong></a>, <a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a>, <a href="./gis_analysis.html#naturalneighbourinterpolation"><strong>NaturalNeighbourInterpolation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--resolution</td><td>Output raster's grid resolution</td></tr>
<tr><td>--base</td><td>Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
<tr><td>--max_triangle_edge_length</td><td>Optional maximum triangle edge length; triangles larger than this size will not be gridded</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tin_gridding(
    i, 
    output, 
    field=None, 
    use_z=False, 
    resolution=None, 
    base=None, 
    max_triangle_edge_length=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TINGridding -v --wd=&quot;/path/to/data/&quot; ^
-i=points.shp --field=HEIGHT -o=tin.shp ^
--resolution=10.0
&gt;&gt;./whitebox_tools -r=TINGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=tin.shp ^
--resolution=5.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/tin_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/09/2018</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="VectorHexBinning"></a></p>
<h1 id="vectorhexbinning"><a class="header" href="#vectorhexbinning">VectorHexBinning</a></h1>
<p>The practice of binning point data to form a type of 2D histogram, density plot,
or what is sometimes called a heatmap, is quite useful as an alternative for the
cartographic display of of very dense points sets. This is particularly the case
when the points experience significant overlap at the displayed scale. The
<code>PointDensity</code> tool can be used to perform binning based on a regular grid (raster
output). This tool, by comparison, bases the binning on a hexagonal grid.</p>
<p>The tool is similar to the <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a> tool, however instead will
create an output hexagonal grid in which each hexagonal cell possesses a <code>COUNT</code>
attribute which specifies the number of points from an input points file (Shapefile
vector) that are contained within the hexagonal cell.</p>
<p>In addition to the names of the input points file and the output Shapefile, the user
must also specify the desired hexagon width (w), which is the distance between opposing
sides of each hexagon. The size (s) each side of the hexagon can then be calculated as,
s = w / [2 x cos(PI / 6)]. The area of each hexagon (A) is, A = 3s(w / 2). The user must
also specify the orientation of the grid with options of horizontal (pointy side up) and
vertical (flat side up).</p>
<p><em>See Also</em>:
<a href="./lidar_tools.html#lidarhexbinning"><strong>LidarHexBinning</strong></a>, <code>PointDensity</code>, <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input base file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
<tr><td>--width</td><td>The grid cell width</td></tr>
<tr><td>--orientation</td><td>Grid Orientation, 'horizontal' or 'vertical'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.vector_hex_binning(
    i, 
    output, 
    width, 
    orientation=&quot;horizontal&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VectorHexBinning -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--orientation=vertical 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/vector_hex_bin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/09/2018</p>
<p><em>Last Modified</em>: 13/10/2018</p>
<p><a name="VoronoiDiagram"></a></p>
<h1 id="voronoidiagram"><a class="header" href="#voronoidiagram">VoronoiDiagram</a></h1>
<p>This tool creates a vector Voronoi diagram for a set of vector points. The
Voronoi diagram is the dual graph of the Delaunay triangulation. The tool
operates by first constructing the Delaunay triangulation and then
connecting the circumcenters of each triangle. Each Voronoi cell contains
one point of the input vector points. All locations within the cell are
nearer to the contained point than any other input point.</p>
<p>A dense frame of 'ghost' (hidden) points is inserted around the input point
set to limit the spatial extent of the diagram. The frame is set back from
the bounding box of the input points by 2 x the average point  spacing. The
polygons of these ghost points are not output, however, points that are
situated along the edges of the data will have somewhat rounded (paraboloic)
exterior boundaries as a result of this edge condition. If this property is
unacceptable for application, clipping the Voronoi diagram to the convex
hull may be a better alternative.</p>
<p>This tool works on vector input data only. If a Voronoi diagram is needed
to tesselate regions associated with a set of raster points, use the
<a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a> tool instead. To use Voronoi diagrams for gridding
data (i.e. raster interpolation), use the <a href="./gis_analysis.html#nearestneighbourgridding"><strong>NearestNeighbourGridding</strong></a> tool.</p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a>, <a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a>, <a href="./gis_analysis.html#nearestneighbourgridding"><strong>NearestNeighbourGridding</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>-o, --output</td><td>Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.voronoi_diagram(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VoronoiDiagram -v --wd=&quot;/path/to/data/&quot; ^
-i=points.shp -o=tin.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/whitebox-tools-app/src/tools/gis_analysis/voronoi_diagram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/10/2018</p>
<p><em>Last Modified</em>: 16/06/2020</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../available_tools/geomorphometric_analysis.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../available_tools/gis_analysis_distance_tools.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../available_tools/geomorphometric_analysis.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../available_tools/gis_analysis_distance_tools.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
