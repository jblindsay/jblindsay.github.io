<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Geomorphometric analysis - WhiteboxTools User Manual</title>
        <meta http-equiv="refresh" content="0; url=https://www.whiteboxgeo.com/manual/wbt_book/intro.html" />
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../preface.html">Preface</a></li><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../install.html"><strong aria-hidden="true">2.</strong> Setting Up WhiteboxTools</a></li><li class="chapter-item expanded "><a href="../using_whiteboxtools.html"><strong aria-hidden="true">3.</strong> Using WhiteboxTools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python_scripting/scripting.html"><strong aria-hidden="true">3.1.</strong> Interfacing with Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python_scripting/using_whitebox_tools.html"><strong aria-hidden="true">3.1.1.</strong> Using whitebox_tools.py</a></li><li class="chapter-item expanded "><a href="../python_scripting/tool_output.html"><strong aria-hidden="true">3.1.2.</strong> Handling tool output</a></li><li class="chapter-item expanded "><a href="../python_scripting/additional_functions.html"><strong aria-hidden="true">3.1.3.</strong> Additional functions</a></li><li class="chapter-item expanded "><a href="../python_scripting/example.html"><strong aria-hidden="true">3.1.4.</strong> An example Python project</a></li></ol></li><li class="chapter-item expanded "><a href="../r_interface.html"><strong aria-hidden="true">3.2.</strong> Interfacing with R</a></li><li class="chapter-item expanded "><a href="../nim_scripting.html"><strong aria-hidden="true">3.3.</strong> Interfacing with Nim</a></li><li class="chapter-item expanded "><a href="../whitebox_tools_runner.html"><strong aria-hidden="true">3.4.</strong> WhiteboxTools Runner</a></li><li class="chapter-item expanded "><a href="../qgis_plugin.html"><strong aria-hidden="true">3.5.</strong> QGIS plugin</a></li><li class="chapter-item expanded "><a href="../arcgis_plugin.html"><strong aria-hidden="true">3.6.</strong> ArcGIS plugin</a></li><li class="chapter-item expanded "><a href="../command_prompt.html"><strong aria-hidden="true">3.7.</strong> Command-line interface</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/index.html"><strong aria-hidden="true">4.</strong> Tools Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/data_tools.html"><strong aria-hidden="true">4.1.</strong> Data tools</a></li><li class="chapter-item expanded "><a href="../available_tools/geomorphometric_analysis.html" class="active"><strong aria-hidden="true">4.2.</strong> Geomorphometric analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis.html"><strong aria-hidden="true">4.3.</strong> GIS analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_distance_tools.html"><strong aria-hidden="true">4.3.1.</strong> Distance tools</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_overlay_tools.html"><strong aria-hidden="true">4.3.2.</strong> Overlay tools</a></li><li class="chapter-item expanded "><a href="../available_tools/gis_analysis_patch_shape_tools.html"><strong aria-hidden="true">4.3.3.</strong> Patch shape tools</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/hydrological_analysis.html"><strong aria-hidden="true">4.4.</strong> Hydrological analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools.html"><strong aria-hidden="true">4.5.</strong> Image processing tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools_classification.html"><strong aria-hidden="true">4.5.1.</strong> Classification</a></li><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools_filters.html"><strong aria-hidden="true">4.5.2.</strong> Filters</a></li><li class="chapter-item expanded "><a href="../available_tools/image_processing_tools_image_enhancement.html"><strong aria-hidden="true">4.5.3.</strong> Image enchancement</a></li></ol></li><li class="chapter-item expanded "><a href="../available_tools/lidar_tools.html"><strong aria-hidden="true">4.6.</strong> LiDAR tools</a></li><li class="chapter-item expanded "><a href="../available_tools/mathand_stats_tools.html"><strong aria-hidden="true">4.7.</strong> Mathematical and statistical analysis</a></li><li class="chapter-item expanded "><a href="../available_tools/precision_agriculture.html"><strong aria-hidden="true">4.8.</strong> Precision agriculture</a></li><li class="chapter-item expanded "><a href="../available_tools/stream_network_analysis.html"><strong aria-hidden="true">4.9.</strong> Stream network analysis</a></li></ol></li><li class="chapter-item expanded "><a href="../tutorials/index.html"><strong aria-hidden="true">5.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/mosaic.html"><strong aria-hidden="true">5.1.</strong> How can I mosaic hundreds of rasters?</a></li><li class="chapter-item expanded "><a href="../tutorials/lidar.html"><strong aria-hidden="true">5.2.</strong> Processing LiDAR data</a></li></ol></li><li class="chapter-item expanded "><a href="../supported_formats.html"><strong aria-hidden="true">6.</strong> Supported Data Formats</a></li><li class="chapter-item expanded "><a href="../contributing.html"><strong aria-hidden="true">7.</strong> Contributing and Reporting Bugs</a></li><li class="chapter-item expanded "><a href="../limitations.html"><strong aria-hidden="true">8.</strong> Limitations and Memory</a></li><li class="chapter-item expanded "><a href="../license.html"><strong aria-hidden="true">9.</strong> License</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">10.</strong> Frequently Asked Questions</a></li><li class="chapter-item expanded "><a href="../tool_index.html"><strong aria-hidden="true">11.</strong> Tool Index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">WhiteboxTools User Manual</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="geomorphometric-analysis"><a class="header" href="#geomorphometric-analysis">Geomorphometric Analysis</a></h1>
<ul>
<li><a href="#Aspect">Aspect</a></li>
<li><a href="#AssessRoute">AssessRoute</a></li>
<li><a href="#AverageNormalVectorAngularDeviation">AverageNormalVectorAngularDeviation</a></li>
<li><a href="#CircularVarianceOfAspect">CircularVarianceOfAspect</a></li>
<li><a href="#ContoursFromPoints">ContoursFromPoints</a></li>
<li><a href="#ContoursFromRaster">ContoursFromRaster</a></li>
<li><a href="#DevFromMeanElev">DevFromMeanElev</a></li>
<li><a href="#DiffFromMeanElev">DiffFromMeanElev</a></li>
<li><a href="#DirectionalRelief">DirectionalRelief</a></li>
<li><a href="#DownslopeIndex">DownslopeIndex</a></li>
<li><a href="#EdgeDensity">EdgeDensity</a></li>
<li><a href="#ElevAbovePit">ElevAbovePit</a></li>
<li><a href="#ElevPercentile">ElevPercentile</a></li>
<li><a href="#ElevRelativeToMinMax">ElevRelativeToMinMax</a></li>
<li><a href="#ElevRelativeToWatershedMinMax">ElevRelativeToWatershedMinMax</a></li>
<li><a href="#EmbankmentMapping">EmbankmentMapping</a></li>
<li><a href="#FeaturePreservingSmoothing">FeaturePreservingSmoothing</a></li>
<li><a href="#FetchAnalysis">FetchAnalysis</a></li>
<li><a href="#FillMissingData">FillMissingData</a></li>
<li><a href="#FindRidges">FindRidges</a></li>
<li><a href="#Hillshade">Hillshade</a></li>
<li><a href="#HorizonAngle">HorizonAngle</a></li>
<li><a href="#HypsometricAnalysis">HypsometricAnalysis</a></li>
<li><a href="#HypsometricallyTintedHillshade">HypsometricallyTintedHillshade</a></li>
<li><a href="#MapOffTerrainObjects">MapOffTerrainObjects</a></li>
<li><a href="#MaxAnisotropyDev">MaxAnisotropyDev</a></li>
<li><a href="#MaxAnisotropyDevSignature">MaxAnisotropyDevSignature</a></li>
<li><a href="#MaxBranchLength">MaxBranchLength</a></li>
<li><a href="#MaxDifferenceFromMean">MaxDifferenceFromMean</a></li>
<li><a href="#MaxDownslopeElevChange">MaxDownslopeElevChange</a></li>
<li><a href="#MaxElevDevSignature">MaxElevDevSignature</a></li>
<li><a href="#MaxElevationDeviation">MaxElevationDeviation</a></li>
<li><a href="#MinDownslopeElevChange">MinDownslopeElevChange</a></li>
<li><a href="#MultidirectionalHillshade">MultidirectionalHillshade</a></li>
<li><a href="#MultiscaleElevationPercentile">MultiscaleElevationPercentile</a></li>
<li><a href="#MultiscaleRoughness">MultiscaleRoughness</a></li>
<li><a href="#MultiscaleRoughnessSignature">MultiscaleRoughnessSignature</a></li>
<li><a href="#MultiscaleStdDevNormals">MultiscaleStdDevNormals</a></li>
<li><a href="#MultiscaleStdDevNormalsSignature">MultiscaleStdDevNormalsSignature</a></li>
<li><a href="#MultiscaleTopographicPositionImage">MultiscaleTopographicPositionImage</a></li>
<li><a href="#NumDownslopeNeighbours">NumDownslopeNeighbours</a></li>
<li><a href="#NumUpslopeNeighbours">NumUpslopeNeighbours</a></li>
<li><a href="#Openness">Openness</a></li>
<li><a href="#PennockLandformClass">PennockLandformClass</a></li>
<li><a href="#PercentElevRange">PercentElevRange</a></li>
<li><a href="#PlanCurvature">PlanCurvature</a></li>
<li><a href="#Profile">Profile</a></li>
<li><a href="#ProfileCurvature">ProfileCurvature</a></li>
<li><a href="#RelativeAspect">RelativeAspect</a></li>
<li><a href="#RelativeTopographicPosition">RelativeTopographicPosition</a></li>
<li><a href="#RemoveOffTerrainObjects">RemoveOffTerrainObjects</a></li>
<li><a href="#RuggednessIndex">RuggednessIndex</a></li>
<li><a href="#SedimentTransportIndex">SedimentTransportIndex</a></li>
<li><a href="#ShadowAnimation">ShadowAnimation</a></li>
<li><a href="#Slope">Slope</a></li>
<li><a href="#SlopeVsElevationPlot">SlopeVsElevationPlot</a></li>
<li><a href="#SmoothVegetationResidual">SmoothVegetationResidual</a></li>
<li><a href="#SphericalStdDevOfNormals">SphericalStdDevOfNormals</a></li>
<li><a href="#StandardDeviationOfSlope">StandardDeviationOfSlope</a></li>
<li><a href="#StreamPowerIndex">StreamPowerIndex</a></li>
<li><a href="#SurfaceAreaRatio">SurfaceAreaRatio</a></li>
<li><a href="#TangentialCurvature">TangentialCurvature</a></li>
<li><a href="#TimeInDaylight">TimeInDaylight</a></li>
<li><a href="#TopographicPositionAnimation">TopographicPositionAnimation</a></li>
<li><a href="#TotalCurvature">TotalCurvature</a></li>
<li><a href="#Viewshed">Viewshed</a></li>
<li><a href="#VisibilityIndex">VisibilityIndex</a></li>
<li><a href="#WetnessIndex">WetnessIndex</a></li>
</ul>
<p><a name="Aspect"></a></p>
<h1 id="aspect"><a class="header" href="#aspect">Aspect</a></h1>
<p>This tool calculates slope aspect (i.e. slope orientation in degrees clockwise from north) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>aspect = 180 - arctan(f<sub>y</sub> / f<sub>x</sub>) + 90(f<sub>x</sub> / |f<sub>x</sub>|)</p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / 8 * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.aspect(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Aspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 01/03/2021</p>
<p><a name="AssessRoute"></a></p>
<h1 id="assessroute"><a class="header" href="#assessroute">AssessRoute</a></h1>
<blockquote>
<p>Note this tool is part of a WhiteboxTools extension toolset. Please contact
<a href="https://www.whiteboxgeo.com">Whitebox Geospatial Inc.</a> for information about purchasing a license
activation key (<a href="https://www.whiteboxgeo.com">https://www.whiteboxgeo.com</a>).</p>
</blockquote>
<p>This tool assesses the variability in slope, elevation, and visibility along a line vector, which may
be a footpath, road, river or any other route. The user must specify the name of the input line vector
(<code>--routes</code>), the input raster digital elevation model file (<code>--dem</code>), and the output line vector
(<code>--output</code>). The algorithm initially splits the input line vector in equal-length segments (<code>--length</code>).
For each line segment, the tool then calculates the average slope (<strong>AVG_SLOPE</strong>), minimum and maximum
elevations (<strong>MIN_ELEV</strong>, <strong>MAX_ELEV</strong>), the elevation range or relief (<strong>RELIEF</strong>), the path sinuosity
(<strong>SINUOSITY</strong>), the number of changes in slope direction or breaks-in-slope (<strong>CHG_IN_SLP</strong>), and the
maximum visibility (<strong>VISIBILITY</strong>). Each of these metrics are output to the attribute table of the output
vector, along with the feature identifier (<strong>FID</strong>); any attributes associated with the input parent
feature will also be copied into the output table. Slope and elevation metrics are measured along the
2D path based on the elevations of each of the row and column intersection points of the raster with
the path, estimated from linear-interpolation using the two neighbouring elevations on either side of
the path. Sinuosity is calculated as the ratio of the along-surface (i.e. 3D) path length, divided by
the 3D distance between the start and end points of the segment. CHG_IN_SLP can be thought of as a crude
measure of path roughness, although this will be very sensitive to the quality of the DEM. The visibility
metric is based on the Yokoyama et al. (2002) <a href="./geomorphometric_analysis.html#openness"><strong>Openness</strong></a> index, which calculates the average horizon
angle in the eight cardal directions to a maximum search distance (<code>--dist</code>), measured in grid cells.</p>
<p>Note that the input DEM must be in a projected coordinate system. The DEM and the input routes vector
must be also share the same coordinate system. This tool also works best when the input DEM is of high
quality and fine spatial resolution, such as those derived from LiDAR data sets.</p>
<p>Maximum segment visibility:
<img src="../img/AssessRoute_visibility.png" alt="" /></p>
<p>Average segment slope:
<img src="../img/AssessRoute_avg_slope.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./gis_analysis.html#splitvectorlines"><strong>SplitVectorLines</strong></a>, <a href="./geomorphometric_analysis.html#openness"><strong>Openness</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--routes</td><td>Name of the input routes vector file</td></tr>
<tr><td>--dem</td><td>Name of the input DEM raster file</td></tr>
<tr><td>-o, --output</td><td>Name of the output lines shapefile</td></tr>
<tr><td>--length</td><td>Maximum segment length (m)</td></tr>
<tr><td>--dist</td><td>Search distance, in grid cells, used in visibility analysis</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.assess_route(
    routes, 
    dem, 
    output, 
    length=&quot;&quot;, 
    dist=20, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt; ./whitebox_tools -r=AssessRoute --routes=footpath.shp ^
--dem=DEM.tif -o=assessedRoutes.shp --length=50.0 --dist=200 
</code></pre>
<p>Source code is unavailable due to proprietary license.</p>
<p><em>Author</em>: Whitebox Geospatial Inc. (c)</p>
<p><em>Created</em>: 16/05/2021</p>
<p><em>Last Modified</em>: 16/05/2021</p>
<p><a name="AverageNormalVectorAngularDeviation"></a></p>
<h1 id="averagenormalvectorangulardeviation"><a class="header" href="#averagenormalvectorangulardeviation">AverageNormalVectorAngularDeviation</a></h1>
<p>This tool characterizes the spatial distribution of the average normal vector angular deviation, a measure of
surface roughness. Working in the field of 3D printing, Ko et al. (2016) defined a measure of surface roughness
based on quantifying the angular deviations in the direction of the normal vector of a real surface from its ideal
(i.e. smoothed) form. This measure of surface complexity is therefore in units of degrees. Specifically, roughness
is defined in this study as the neighborhood-averaged difference in the normal vectors of the original DEM and a
smoothed DEM surface. Smoothed surfaces are derived by applying a Gaussian blur of the same size as the
neighborhood (<code>--filter</code>).</p>
<p>The <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a> tool calculates the same measure of surface roughness, except that it is designed to
work with multiple spatial scales.</p>
<p><em>Reference</em>:</p>
<p>Ko, M., Kang, H., ulrim Kim, J., Lee, Y., &amp; Hwang, J. E. (2016, July). How to measure quality of affordable 3D
printing: Cultivating quantitative index in the user community. In International Conference on Human-Computer
Interaction (pp. 116-121). Springer, Cham.</p>
<p>Lindsay, J. B., &amp; Newman, D. R. (2018). Hyper-scale analysis of surface roughness. PeerJ Preprints, 6, e27110v1.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_normal_vector_angular_deviation(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageNormalVectorAngularDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/average_normal_vector_angular_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="CircularVarianceOfAspect"></a></p>
<h1 id="circularvarianceofaspect"><a class="header" href="#circularvarianceofaspect">CircularVarianceOfAspect</a></h1>
<p>This tool can be used to calculate the circular variance (i.e. one minus the mean resultant length) of aspect
for an input digital elevation model (DEM). This is a measure of how variable slope aspect is within a local
neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a> is therefore a measure of <strong>surface
shape complexity</strong>, or texture. It will take a value of 0.0 for smooth sites and near 1.0 in areas of high surface
roughness or complex topography.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular variance, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, the metric should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <em><strong>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</strong></em> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.circular_variance_of_aspect(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CircularVarianceOfAspect -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/circular_variance_of_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="ContoursFromPoints"></a></p>
<h1 id="contoursfrompoints"><a class="header" href="#contoursfrompoints">ContoursFromPoints</a></h1>
<p>This tool creates a contour coverage from a set of input points (<code>--input</code>). The user must specify the contour
interval (<code>--interval</code>) and optionally, the base contour value (<code>--base</code>). The degree to which contours are
smoothed is controlled by the <strong>Smoothing Filter Size</strong> parameter (<code>--smooth</code>). This value, which determines
the size of a mean filter applied to the x-y position of vertices in each contour, should be an odd integer value, e.g.
3, 5, 7, 9, 11, etc. Larger values will result in smoother contour lines.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#contoursfromraster"><strong>ContoursFromRaster</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input vector points file</td></tr>
<tr><td>--field</td><td>Input field name in attribute table</td></tr>
<tr><td>--use_z</td><td>Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output</td><td>Output vector lines file</td></tr>
<tr><td>--max_triangle_edge_length</td><td>Optional maximum triangle edge length; triangles larger than this size will not be gridded</td></tr>
<tr><td>--interval</td><td>Contour interval</td></tr>
<tr><td>--base</td><td>Base contour height</td></tr>
<tr><td>--smooth</td><td>Smoothing filter size (in num. points), e.g. 3, 5, 7, 9, 11</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.contours_from_points(
    i, 
    output, 
    field=None, 
    use_z=False, 
    max_triangle_edge_length=None, 
    interval=10.0, 
    base=0.0, 
    smooth=5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ContoursFromPoints -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=HEIGHT ^
-o=contours.shp --max_triangle_edge_length=100.0 ^
--interval=100.0 --base=0.0 --smooth=11 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/contours_from_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/04/2020</p>
<p><em>Last Modified</em>: 26/04/2020</p>
<p><a name="ContoursFromRaster"></a></p>
<h1 id="contoursfromraster"><a class="header" href="#contoursfromraster">ContoursFromRaster</a></h1>
<p>This tool can be used to create a vector contour coverage from an input raster surface model (<code>--input</code>), such as a digital
elevation model (DEM). The user must specify the contour interval (<code>--interval</code>) and optionally, the base contour value (<code>--base</code>).
The degree to which contours are smoothed is controlled by the <strong>Smoothing Filter Size</strong> parameter (<code>--smooth</code>). This value, which
determines the size of a mean filter applied to the x-y position of vertices in each contour, should be an odd integer value, e.g.
3, 5, 7, 9, 11, etc. Larger values will result in smoother contour lines. The tolerance parameter (<code>--tolerance</code>) controls the
amount of line generalization. That is, vertices in a contour line will be selectively removed from the line if they do not result in
an angular deflection in the line's path of at least this threshold value. Increasing this value can significantly decrease the size
of the output contour vector file, at the cost of generating straighter contour line segments.</p>
<p><em>See Also</em>:
<a href="./data_tools.html#rastertovectorpolygons"><strong>RasterToVectorPolygons</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input surface raster file</td></tr>
<tr><td>-o, --output</td><td>Output vector contour file</td></tr>
<tr><td>--interval</td><td>Contour interval</td></tr>
<tr><td>--base</td><td>Base contour height</td></tr>
<tr><td>--smooth</td><td>Smoothing filter size (in num. points), e.g. 3, 5, 7, 9, 11</td></tr>
<tr><td>--tolerance</td><td>Tolerance factor, in degrees (0-45); determines generalization level</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.contours_from_raster(
    i, 
    output, 
    interval=10.0, 
    base=0.0, 
    smooth=9, 
    tolerance=10.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ContoursFromRaster -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tif -o=contours.shp ^
--interval=100.0 --base=0.0 --smooth=11 --tolerance=20.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/contours_from_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/02/2020</p>
<p><em>Last Modified</em>: 04/03/2020</p>
<p><a name="DevFromMeanElev"></a></p>
<h1 id="devfrommeanelev"><a class="header" href="#devfrommeanelev">DevFromMeanElev</a></h1>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood, normalized by standard
deviation. Therefore, this index of topographic residual is essentially equivalent to a
local z-score. This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the deviation from mean elevation (DEV) at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool can be used to output the per-pixel maximum DEV
value across a range of input scales.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.dev_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DevFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/dev_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/06/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="DiffFromMeanElev"></a></p>
<h1 id="difffrommeanelev"><a class="header" href="#difffrommeanelev">DiffFromMeanElev</a></h1>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood. This is similar to what a high-pass
filter calculates for imagery data, but is intended to work with DEM data instead. This attribute
measures the <em>relative topographic position</em>. <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the DIFF at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a> tool can be used to output the per-pixel maximum DIFF
value across a range of input scales.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.diff_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiffFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/diff_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="DirectionalRelief"></a></p>
<h1 id="directionalrelief"><a class="header" href="#directionalrelief">DirectionalRelief</a></h1>
<p>This tool calculates the relief for each grid cell in a digital elevation model (DEM) in a specified direction.
Directional relief is an index of the degree to which a DEM grid cell is higher or lower than its surroundings.
It is calculated by subtracting the elevation of a DEM grid cell from the average elevation of those cells which
lie between it and the edge of the DEM in a specified compass direction. Thus, positive values indicate that a
grid cell is lower than the average elevation of the grid cells in a specific direction (i.e. relatively sheltered),
whereas a negative directional relief indicates that the grid cell is higher (i.e. relatively exposed). The
algorithm is based on a modification of the procedure described by Lapen and Martz (1993). The modifications
include: (1) the ability to specify any direction between 0-degrees and 360-degrees (<code>--azimuth</code>), and (2) the ability to use
a distance-limited search (<code>--max_dist</code>), such that the ray-tracing procedure terminates before the DEM edge is
reached for longer search paths. The algorithm works by tracing a ray from each grid cell in the direction of
interest and evaluating the average elevation along the ray. Linear interpolation is used to estimate the elevation
of the surface where a ray does not intersect the DEM grid precisely at one of its nodes. The user must specify the
name of an input DEM raster file, the output raster name, and a hypothetical wind direction. Furthermore, the user
is able to constrain the maximum search distance for the ray tracing. If no maximum search distance is specified,
each ray will be traced to the edge of the DEM. The units of the output image are the same as the input DEM.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate
for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued grid cells in the
input image will be assigned NoData values in the output image. The output raster is of the float data type and
continuous data scale. Directional relief is best displayed using the blue-white-red bipolar palette to distinguish
between the positive and negative values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#fetchanalysis"><strong>FetchAnalysis</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--azimuth</td><td>Wind azimuth in degrees</td></tr>
<tr><td>--max_dist</td><td>Optional maximum search distance (unspecified if none; in xy units)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.directional_relief(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DirectionalRelief -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/directional_relief.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="DownslopeIndex"></a></p>
<h1 id="downslopeindex"><a class="header" href="#downslopeindex">DownslopeIndex</a></h1>
<p>This tool can be used to calculate the downslope index described by Hjerdt et al. (2004).
The downslope index is a measure of the slope gradient between a grid cell and some
downslope location (along the flowpath passing through the upslope grid cell) that
represents a specified vertical drop (i.e. a potential head drop). The index has been
shown to be useful for hydrological, geomorphological, and biogeochemical applications.</p>
<p>The user must specify the name of a digital elevaton model (DEM) raster. This DEM
should be have been pre-processed to remove artifact topographic depressions and flat
areas. The user must also specify the head potential drop (d), and the output type. The
output type can be either '<code>tangent</code>', '<code>degrees</code>', '<code>radians</code>', or '<code>distance</code>'. If
'<code>distance</code>' is selected as the output type, the output grid actually represents the
downslope flowpath length required to drop d meters from each grid cell. Linear
interpolation is used when the specified drop value is encountered between two adjacent
grid cells along a flowpath traverse.</p>
<p>Notice that this algorithm is affected by edge contamination. That is, for some grid cells,
the edge of the grid will be encountered along a flowpath traverse before the specified
vertical drop occurs. In these cases, the value of the downslope index is approximated by
replacing d with the actual elevation drop observed along the flowpath. To avoid this problem,
the entire watershed containing an area of interest should be contained in the DEM.</p>
<p>Grid cells containing NoData values in any of the input images are assigned the NoData
value in the output raster. The output raster is of the float data type and continuous
data scale.</p>
<p><em>Reference</em>:</p>
<p>Hjerdt, K.N., McDonnell, J.J., Seibert, J. Rodhe, A. (2004) <em>A new topographic index to
quantify downslope controls on local drainage</em>, <strong>Water Resources Research</strong>, 40, W05602,
doi:10.1029/2004WR003130.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--drop</td><td>Vertical drop value (default is 2.0)</td></tr>
<tr><td>--out_type</td><td>Output type, options include 'tangent', 'degrees', 'radians', 'distance' (default is 'tangent')</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.downslope_index(
    dem, 
    output, 
    drop=2.0, 
    out_type=&quot;tangent&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DownslopeIndex -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=dsi.tif --drop=5.0 --out_type=distance 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/downslope_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 17, 2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="EdgeDensity"></a></p>
<h1 id="edgedensity"><a class="header" href="#edgedensity">EdgeDensity</a></h1>
<p>This tool calculates the density of edges, or breaks-in-slope within an input digital elevation model (DEM).
A break-in-slope occurs between two neighbouring grid cells if the angular difference between their normal
vectors is greater than a user-specified threshold value (<code>--norm_diff</code>). <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> calculates the proportion
of edge cells within the neighbouring window, of square filter dimension <code>--filter</code>, surrounding each grid cell.
Therefore, <code>EdgeDensity </code>is a measure of how complex the topographic surface is within a local neighbourhood.
It is therefore a measure of topographic texture. It will take a value near 0.0 for smooth sites and 1.0 in areas
of high surface roughness or complex topography.</p>
<p>The distribution of <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> is highly dependent upon the value of the <code>norm_diff</code> used in the calculation. This
threshold may require experimentation to find an appropriate value and is likely dependent upon the topography and
source data. Nonetheless, experience has shown that <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> provides one of the best measures of surface
texture of any of the available roughness tools.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Size of the filter kernel</td></tr>
<tr><td>--norm_diff</td><td>Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.edge_density(
    dem, 
    output, 
    filter=11, 
    norm_diff=5.0, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgeDensity -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=15 --norm_diff=20.0 ^
--num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/edge_density.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/01/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="ElevAbovePit"></a></p>
<h1 id="elevabovepit"><a class="header" href="#elevabovepit">ElevAbovePit</a></h1>
<p>This tool will calculate the elevation of each grid cell in a digital elevation model (DEM) above the nearest
downslope pit cell or grid edge cell, depending on which is encountered first during the flow-path traverse.
The resulting image is therefore a measure of relative landscape position. The user must specify the names of
a D8 flow pointer grid, a DEM file, and the output file. The flow pointer grid must be derived using the D8
flow algorithm.</p>
<p><em>See Also</em>:
<a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_above_pit(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevAbovePit -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/elev_above_pit.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="ElevPercentile"></a></p>
<h1 id="elevpercentile"><a class="header" href="#elevpercentile">ElevPercentile</a></h1>
<p>Elevation percentile (EP) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentile of the
elevation distribution within the filter window, such that:</p>
<blockquote>
<p>EP = count<sub>i∈C</sub>(z<sub>i</sub> &gt; z<sub>0</sub>) x (100 / n<sub>C</sub>)</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>i</sub> is the elevation
of cell <em>i</em> contained within the neighboring set C, and n<sub>C</sub> is the number
of grid cells contained within the window.</p>
<p>EP is unsigned and expressed as a percentage, bound between 0%
and 100%. Quantile-based estimates (e.g., the median and interquartile
range) are often used in nonparametric statistics to provide data
variability estimates without assuming the distribution is normal.
Thus, EP is largely unaffected by irregularly shaped elevation frequency
distributions or by outliers in the DEM, resulting in a highly robust metric
of LTP. In fact, elevation distributions within small to medium sized
neighborhoods often exhibit skewed, multimodal, and non-Gaussian
distributions, where the occurrence of elevation errors can often result
in distribution outliers. Thus, based on these statistical characteristics,
EP is considered one of the most robust representation of LTP.</p>
<p>The algorithm implemented by this tool uses the relatively efficient running-histogram filtering algorithm of Huang
et al. (1979). Because most DEMs contain floating point data, elevation values must be rounded to be binned. The
<code>--sig_digits</code> parameter is used to determine the level of precision preserved during this binning process. The
algorithm is parallelized to further aid with computational efficiency.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits</td><td>Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_percentile(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevPercentile -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/elev_percentile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 02/04/2019</p>
<p><a name="ElevRelativeToMinMax"></a></p>
<h1 id="elevrelativetominmax"><a class="header" href="#elevrelativetominmax">ElevRelativeToMinMax</a></h1>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a
percentage of the relief between the DEM minimum and maximum values. As such, it provides a basic
measure of relative topographic position.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#elevrelativetowatershedminmax"><strong>ElevRelativeToWatershedMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_min_max(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/elev_relative_to_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="ElevRelativeToWatershedMinMax"></a></p>
<h1 id="elevrelativetowatershedminmax"><a class="header" href="#elevrelativetowatershedminmax">ElevRelativeToWatershedMinMax</a></h1>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a percentage
of the relief between the watershed minimum and maximum values. As such, it provides a basic
measure of relative topographic position. The user must specify the names of DEM (<code>--dem</code>) and watersheds (<code>--watersheds</code>)
raster files.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#elevrelativetominmax"><strong>ElevRelativeToMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--watersheds</td><td>Input raster watersheds file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_watershed_min_max(
    dem, 
    watersheds, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToWatershedMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --watersheds=watershed.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/elev_relative_to_watershed_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="EmbankmentMapping"></a></p>
<h1 id="embankmentmapping"><a class="header" href="#embankmentmapping">EmbankmentMapping</a></h1>
<p>This tool can be used to map and/or remove road embankments from an input fine-resolution digital elevation
model (<code>--dem</code>). Fine-resolution LiDAR DEMs can represent surface features such as road and railway
embankments with high fidelity. However, transportation embankments are problematic for several
environmental modelling applications, including soil an vegetation distribution mapping, where the pre-embankment
topography is the contolling factor. The algorithm utilizes repositioned (<code>--search_dist</code>) transportation
network cells, derived from rasterizing a transportation vector (<code>--road_vec</code>), as seed points in a
region-growing operation. The embankment region grows based on derived morphometric parameters, including
road surface width (<code>--min_road_width</code>), embankment width (<code>--typical_width</code> and <code>--max_width</code>), embankment
height (<code>--max_height</code>), and absolute slope (<code>--spillout_slope</code>). The tool can be run in two modes. By default
the tool will simply map embankment cells, with a Boolean output raster. If, however, the <code>--remove_embankments</code>
flag is specified, the tool will instead output a DEM for which the mapped embankment grid cells have been
excluded and new surfaces have been interpolated based on the surrounding elevation values (see below).</p>
<p>Hillshade from original DEM:
<img src="../img/EmbankmentMapping1.png" alt="" /></p>
<p>Hillshade from embankment-removed DEM:
<img src="../img/EmbankmentMapping2.png" alt="" /></p>
<p><em>References</em>:</p>
<p>Van Nieuwenhuizen, N, Lindsay, JB, DeVries, B. 2021. <a href="https://www.mdpi.com/2072-4292/13/7/1308/htm">Automated mapping of transportation embankments in
fine-resolution LiDAR DEMs</a>. Remote Sensing. 13(7), 1308; https://doi.org/10.3390/rs13071308</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a>, <a href="./geomorphometric_analysis.html#smoothvegetationresidual"><strong>SmoothVegetationResidual</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--road_vec</td><td>Input vector polygons file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--search_dist</td><td>Search distance used to reposition transportation vectors onto road embankments (in map units)</td></tr>
<tr><td>--min_road_width</td><td>Minimum road width; this is the width of the paved road surface (in map units)</td></tr>
<tr><td>--typical_width</td><td>Typical embankment width; this is the maximum width of an embankment with roadside ditches (in map units)</td></tr>
<tr><td>--max_height</td><td>Typical embankment maximum height; this is the height a typical embankment with roadside ditches (in map units)</td></tr>
<tr><td>--max_width</td><td>Maximum embankment width, typically where embankments traverse steep-sided valleys (in map units)</td></tr>
<tr><td>--max_increment</td><td>Maximum upwards increment between neighbouring cells on an embankment (in elevation units)</td></tr>
<tr><td>--spillout_slope</td><td>Spillout slope (in degrees)</td></tr>
<tr><td>--remove_embankments</td><td>Optional flag indicating whether to output a DEM with embankments removed (true) or an embankment raster map (false)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.embankment_mapping(
    dem, 
    road_vec, 
    output, 
    search_dist=2.5, 
    min_road_width=6.0, 
    typical_width=30.0, 
    max_height=2.0, 
    max_width=60.0, 
    max_increment=0.05, 
    spillout_slope=4.0, 
    remove_embankments=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EmbankmentMapping -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif ^
--search_dist=1.0 --min_road_width=6.0 --typical_width=30.0 ^
--max_height=2.0 --max_width=60.0 --max_increment=0.05 ^
--spillout_slope=4.0 --remove_embankments=true 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/embankment_mapping.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay and Nigel Van Nieuwenhuizen</p>
<p><em>Created</em>: 21/09/2020</p>
<p><em>Last Modified</em>: 05/10/2020</p>
<p><a name="FeaturePreservingSmoothing"></a></p>
<h1 id="featurepreservingsmoothing"><a class="header" href="#featurepreservingsmoothing">FeaturePreservingSmoothing</a></h1>
<p>This tool implements a highly modified form of the DEM de-noising algorithm described
by Sun et al. (2007). It is very effective at removing surface roughness from digital
elevation models (DEMs), without significantly altering breaks-in-slope. As such,
this tool should be used for smoothing DEMs rather than either smoothing with
low-pass filters (e.g. mean, median, Gaussian filters) or grid size coarsening
by resampling. The algorithm works by 1) calculating the surface normal 3D vector
of each grid cell in the DEM, 2) smoothing the normal vector field using a
filtering scheme that applies more weight to neighbours with lower angular difference
in surface normal vectors, and 3) uses the smoothed normal vector field to update
the elevations in the input DEM.</p>
<p>Sun et al.'s (2007) original method was intended to work on input point clouds and
fitted triangular irregular networks (TINs). The algorithm has been modified to
work with input raster DEMs instead. In so doing, this algorithm calculates surface
normal vectors from the planes fitted to 3 x 3 neighbourhoods surrounding each
grid cell, rather than the triangular facet. The normal vector field smoothing and
elevation updating procedures are also based on raster filtering operations. These
modifications make this tool more efficient than Sun's original method, but will
also result in a slightly different output than what would be achieved with Sun's
method.</p>
<p>The user must specify the values of three key parameters, including the filter size
(<code>--filter</code>), the normal difference threshold (<code>--norm_diff</code>), and the number of
iterations (<code>--num_iter</code>). Lindsay et al. (2019) found that <strong>the degree of smoothing
was less impacted by the filter size than it was either the normal difference threshold
and the number of iterations</strong>. A filter size of 11, the default value, tends to work
well in many cases. To increase the level of smoothing applied to the DEM, consider
increasing the normal difference threshold, i.e. the angular difference in normal vectors
between the center cell of a filter window and a neighbouring cell. This parameter determines
which neighbouring values are included in a filtering operation and higher values will
result in a greater number of neighbouring cells included, and therefore smooother surfaces.
Similarly, increasing the number of iterations from the default value of 3 to upwards of
5-10 will result in significantly greater smoothing.</p>
<p>Before smoothing treatment:
<img src="../img/FeaturePreservingSmoothing_fig1.png" alt="" /></p>
<p>After smoothing treatment with FPS:
<img src="../img/FeaturePreservingSmoothing_fig2.png" alt="" /></p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Francioni A, Cockburn JMH. 2019. LiDAR DEM smoothing and the preservation of
drainage features. <em>Remote Sensing</em>, 11(16), 1926; DOI: 10.3390/rs11161926.</p>
<p>Sun, X., Rosin, P., Martin, R., &amp; Langbein, F. (2007). Fast and effective feature-preserving
mesh denoising. <em>IEEE Transactions on Visualization &amp; Computer Graphics</em>, (5), 925-938.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Size of the filter kernel</td></tr>
<tr><td>--norm_diff</td><td>Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--num_iter</td><td>Number of iterations</td></tr>
<tr><td>--max_diff</td><td>Maximum allowable absolute elevation change (optional)</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.feature_preserving_smoothing(
    dem, 
    output, 
    filter=11, 
    norm_diff=15.0, 
    num_iter=3, 
    max_diff=0.5, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FeaturePreservingSmoothing -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --filter=15 ^
--norm_diff=20.0 --num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/feature_preserving_smoothing.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/11/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="FetchAnalysis"></a></p>
<h1 id="fetchanalysis"><a class="header" href="#fetchanalysis">FetchAnalysis</a></h1>
<p>This tool creates a new raster in which each grid cell is assigned the distance, in meters, to the nearest
topographic obstacle in a specified direction. It is a modification of the algorithm described by Lapen and
Martz (1993). Unlike the original algorithm, Fetch Analysis is capable of analyzing fetch in any direction
from 0-360 degrees. The user must specify the name of an input digital elevation model (DEM) raster file, the
output raster name, a hypothetical wind direction, and a value for the height increment parameter. The algorithm
searches each grid cell in a path following the specified wind direction until the following condition is met:</p>
<blockquote>
<p><em>Z</em><sub>test</sub> &gt;= <em>Z</em><sub>core</sub> + <em>DI</em></p>
</blockquote>
<p>where <em>Z</em><sub>core</sub> is the elevation of the grid cell at which fetch is being determined, <em>Z</em><sub>test</sub>
is the elevation of the grid cell being tested as a topographic obstacle, <em>D</em> is the distance between the two
grid cells in meters, and <em>I</em> is the height increment in m/m. Lapen and Martz (1993) suggest values for <em>I</em> in
the range of 0.025 m/m to 0.1 m/m based on their study of snow re-distribution in low-relief agricultural
landscapes of the Canadian Prairies. If the directional search does not identify an obstacle grid cell before the
edge of the DEM is reached, the distance between the DEM edge and Zcore is entered. Edge distances are assigned
negative values to differentiate between these artificially truncated fetch values and those for which a valid
topographic obstacle was identified. Notice that linear interpolation is used to estimate the elevation of the
surface where a ray (i.e. the search path) does not intersect the DEM grid precisely at one of its nodes.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to
operate for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued
grid cells in the input image will be assigned NoData values in the output image. Fetch Analysis images are
best displayed using the blue-white-red bipolar palette to distinguish between the positive and negative
values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#directionalrelief"><strong>DirectionalRelief</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--azimuth</td><td>Wind azimuth in degrees in degrees</td></tr>
<tr><td>--hgt_inc</td><td>Height increment value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fetch_analysis(
    dem, 
    output, 
    azimuth=0.0, 
    hgt_inc=0.05, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FetchAnalysis -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/fetch_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="FillMissingData"></a></p>
<h1 id="fillmissingdata"><a class="header" href="#fillmissingdata">FillMissingData</a></h1>
<p>This tool can be used to fill in small gaps in a raster or digital elevation model (DEM). The gaps,
or holes, must have recognized NoData values. If gaps do not currently have this characteristic, use
the <a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a> tool and ensure that the data are stored using a raster format that supports NoData
values. All valid, non-NoData values in the input raster will be assigned the same value in the output image.</p>
<p>The algorithm uses an inverse-distance weighted (IDW) scheme based on the valid values on the edge of
NoData gaps to estimate gap values. The user must specify the filter size (<code>--filter</code>), which determines
the size of gap that is filled, and the IDW weight (<code>--weight</code>).</p>
<p>The filter size, specified in grid cells, is used to determine how far the algorithm will search for valid,
non-NoData values. Therefore, setting a larger filter size allows for the filling of larger gaps in the input
raster.</p>
<p>The <code>--no_edges</code> flag can be used to exclude NoData values that are connected to the edges of the raster. It is
usually the case that irregularly shaped DEMs have large regions of NoData values along the containing raster
edges. This flag can be used to exclude these regions from the gap-filling operation, leaving only interior gaps
for filling.</p>
<p><em>See Also</em>:
<a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Filter size (cells)</td></tr>
<tr><td>--weight</td><td>IDW weight value</td></tr>
<tr><td>--no_edges</td><td>Optional flag indicating whether to exclude NoData cells in edge regions</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_missing_data(
    i, 
    output, 
    filter=11, 
    weight=2.0, 
    no_edges=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillMissingData -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 ^
--weight=1.0 --no_edges 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/fill_missing_data.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/06/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="FindRidges"></a></p>
<h1 id="findridges"><a class="header" href="#findridges">FindRidges</a></h1>
<p>This tool can be used to identify ridge cells in a digital elevation model (DEM). Ridge cells are those that
have lower neighbours either to the north and south or the east and west. Line thinning can optionally be used
to create single-cell wide ridge networks by specifying the <code>--line_thin</code> parameter.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--line_thin</td><td>Optional flag indicating whether post-processing line-thinning should be performed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_ridges(
    dem, 
    output, 
    line_thin=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindRidges -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=out.tif --line_thin 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/find_ridges.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/12/2017</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="Hillshade"></a></p>
<h1 id="hillshade"><a class="header" href="#hillshade">Hillshade</a></h1>
<p>This tool performs a hillshade operation (also called shaded relief) on an input digital elevation model (DEM).
The user must specify the  name of the input DEM and the output hillshade image name. Other parameters that must
be specified include the illumination source azimuth (<code>--azimuth</code>), or sun direction (0-360 degrees), the
illumination source altitude (<code>--altitude</code>; i.e. the elevation of the sun above the horizon, measured as an angle
from 0 to 90 degrees) and the Z conversion factor (<code>--zfactor</code>). The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The hillshade value (<em>HS</em>) of a DEM grid cell is calculate as:</p>
<blockquote>
<p><em>HS</em> = tan(<em>s</em>) / [1 - tan(<em>s</em>)<sup>2</sup>]<sup>0.5</sup> x [sin(<em>Alt</em>) / tan(<em>s</em>) - cos(<em>Alt</em>) x sin(<em>Az</em> - <em>a</em>)]</p>
</blockquote>
<p>where <em>s</em> and <em>a</em> are the local slope gradient and aspect (orientation) respectively and <em>Alt</em> and <em>Az</em>
are the illumination source altitude and azimuth respectively. Slope and aspect are calculated using
Horn's (1981) 3rd-order finate difference method.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#hypsometricallytintedhillshade"><strong>HypsometricallyTintedHillshade</strong></a>, <a href="./geomorphometric_analysis.html#multidirectionalhillshade"><strong>MultidirectionalHillshade</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--azimuth</td><td>Illumination source azimuth in degrees</td></tr>
<tr><td>--altitude</td><td>Illumination source altitude in degrees</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hillshade(
    dem, 
    output, 
    azimuth=315.0, 
    altitude=30.0, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Hillshade -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --azimuth=315.0 --altitude=30.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="HorizonAngle"></a></p>
<h1 id="horizonangle"><a class="header" href="#horizonangle">HorizonAngle</a></h1>
<p>This tool calculates the horizon angle (<em>Sx</em>), i.e. the maximum slope along a specified azimuth (0-360 degrees) for
each grid cell in an input digital elevation model (DEM). Horizon angle is sometime referred to as the maximum upwind
slope in wind exposure/sheltering studies. Positive values can be considered sheltered with respect to the azimuth and
negative values are exposed. Thus, <em>Sx</em> is a measure of exposure to a wind from a specific direction. The algorithm works
by tracing a ray from each grid cell in the direction of interest and evaluating the slope for each location in which the
DEM grid is intersected by the ray. Linear interpolation is used to estimate the elevation of the surface where a ray does
not intersect the DEM grid precisely at one of its nodes.</p>
<p>The user is able to constrain the maximum search distance (<code>--max_dist</code>) for the ray tracing by entering a valid maximum
search distance value (in the same units as the X-Y coordinates of the input raster DEM). If the maximum search distance
is left blank, each ray will be traced to the edge of the DEM, which will add to the computational time.</p>
<p>Maximum upwind slope should not be calculated for very extensive areas over which the Earth's curvature must be taken into
account. Also, this index does not take into account the deflection of wind by topography. However, averaging the horizon
angle over a window of directions can yield a more robust measure of exposure, compensating for the deflection of wind from
its regional average by the topography. For example, if you are interested in measuring the exposure of a landscape to a
northerly wind, you could perform the following calculation:</p>
<blockquote>
<p>Sx(N) = [Sx(345)+Sx(350)+Sx(355)+Sx(0)+Sx(5)+Sx(10)+Sx(15)] / 7.0</p>
</blockquote>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate for
larger sized DEMs. Maximum upwind slope is best displayed using a Grey scale palette that is inverted.</p>
<p>Horizon angle is best visualized using a white-to-black palette and rescaled from approximately -10 to 70 (see below for
an example of horizon angle calculated at a 150-degree azimuth).</p>
<p><img src="../img/HorizonAngle.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#timeindaylight"><strong>TimeInDaylight</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--azimuth</td><td>Azimuth, in degrees</td></tr>
<tr><td>--max_dist</td><td>Optional maximum search distance (unspecified if none; in xy units). Minimum value is 5 x cell size</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.horizon_angle(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=100.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HorizonAngle -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/horizon_angle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="HypsometricAnalysis"></a></p>
<h1 id="hypsometricanalysis"><a class="header" href="#hypsometricanalysis">HypsometricAnalysis</a></h1>
<p>This tool can be used to derive the hypsometric curve, or area-altitude curve, of one or more
input digital elevation models (DEMs) (<code>--inputs</code>). A hypsometric curve is a histogram or cumulative
distribution function of elevations in a geographical area.</p>
<p><img src="../img/HypsometricAnalysis_fig1.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#slopevselevationplot"><strong>SlopeVsElevationPlot</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs</td><td>Input DEM files</td></tr>
<tr><td>--watershed</td><td>Input watershed files (optional)</td></tr>
<tr><td>-o, --output</td><td>Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hypsometric_analysis(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HypsometricAnalysis -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/hypsometric_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/01/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="HypsometricallyTintedHillshade"></a></p>
<h1 id="hypsometricallytintedhillshade"><a class="header" href="#hypsometricallytintedhillshade">HypsometricallyTintedHillshade</a></h1>
<p>This tool creates a hypsometrically tinted shaded relief (Swiss hillshading) image from an input digital elevation model (DEM).
The tool combines a colourized version of the DEM with varying illumination provided by a hillshade image, to
produce a composite relief model that can be used to visual topography for more effective interpretation of
landscapes. The output (<code>--output</code>) of the tool is a 24-bit red-green-blue (RGB) colour image.</p>
<p>The user must specify the name of the input DEM and the output image name. Other parameters that must
be specified include the illumination source azimuth (<code>--azimuth</code>), or sun direction (0-360 degrees), the
illumination source altitude (<code>--altitude</code>; i.e. the elevation of the sun above the horizon, measured as an angle
from 0 to 90 degrees), the hillshade weight (<code>--hs_weight</code>; 0-1), image brightness (<code>--brightness</code>; 0-1), and atmospheric
effects (<code>--atmospheric</code>; 0-1). The hillshade weight can be used to increase or subdue the relative prevalence of the
hillshading effect in the output image. The image brightness parameter is used to create an overall brighter or
darker version of the terrain rendering; note however, that very high values may over-saturate the well-illuminated
portions of the terrain. The atmospheric effects parameter can be used to introduce a haze or atmosphere effect to
the output image. It is intended to reproduce the effect of viewing mountain valley bottoms through a thicker and
more dense atmosphere. Values greater than zero will introduce a slightly blue tint, particularly at lower altitudes,
blur the hillshade edges slightly, and create a random haze-like speckle in lower areas. The user must also specify
the Z conversion factor (<code>--zfactor</code>). The <em>Z conversion factor</em> is only important when the vertical and horizontal
units are not the same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z conversion factor. If the DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p><img src="../img/hypsometricallyTintedHillshade_fig1.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#hillshade"><strong>Hillshade</strong></a>, <a href="./geomorphometric_analysis.html#multidirectionalhillshade"><strong>MultidirectionalHillshade</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--altitude</td><td>Illumination source altitude in degrees</td></tr>
<tr><td>--hs_weight</td><td>Weight given to hillshade relative to relief (0.0-1.0)</td></tr>
<tr><td>--brightness</td><td>Brightness factor (0.0-1.0)</td></tr>
<tr><td>--atmospheric</td><td>Atmospheric effects weight (0.0-1.0)</td></tr>
<tr><td>--palette</td><td>Options include 'atlas', 'high_relief', 'arid', 'soft', 'muted', 'purple', 'viridi', 'gn_yl', 'pi_y_g', 'bl_yl_rd', and 'deep'</td></tr>
<tr><td>--reverse</td><td>Optional flag indicating whether to use reverse the palette</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--full_mode</td><td>Optional flag indicating whether to use full 360-degrees of illumination sources</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hypsometrically_tinted_hillshade(
    dem, 
    output, 
    altitude=45.0, 
    hs_weight=0.5, 
    brightness=0.5, 
    atmospheric=0.0, 
    palette=&quot;atlas&quot;, 
    reverse=False, 
    zfactor=None, 
    full_mode=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HypsometricallyTintedHillshade -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --altitude=45.0 ^
--hs_weight=0.3 --brightness=0.6 --atmospheric=0.2 ^
--palette=arid --full_mode 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/hypsometrically_tinted_hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/07/2020</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MapOffTerrainObjects"></a></p>
<h1 id="mapoffterrainobjects"><a class="header" href="#mapoffterrainobjects">MapOffTerrainObjects</a></h1>
<p>This tool can be used to map off-terrain objects in a digital surface model (DSM) based on cell-to-cell differences
in elevations and local slopes. The algorithm works by using a region-growing operation to connect neighbouring grid
cells outwards from seed cells. Two neighbouring cells are considered connected if the slope between the two cells
is less than the user-specified maximum slope value (<code>--max_slope</code>). Mapped segments that are less than the minimum
feature size (<code>--min_size</code>), in grid cells, are assigned a common background value. Note that this method of mapping
off-terrain objects, and thereby separating ground cells from non-ground objects in DSMs, works best with fine-resolution
DSMs that have been interpolated using a non-smoothing method, such as triangulation (TINing) or nearest-neighbour
interpolation.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--max_slope</td><td>Maximum inter-cell absolute slope</td></tr>
<tr><td>--min_size</td><td>Minimum feature size, in grid cells</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.map_off_terrain_objects(
    dem, 
    output, 
    max_slope=40.0, 
    min_size=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MapOffTerrainObjects -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--max_diff=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/map_otos.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/07/2020</p>
<p><em>Last Modified</em>: 27/07/2020</p>
<p><a name="MaxAnisotropyDev"></a></p>
<h1 id="maxanisotropydev"><a class="header" href="#maxanisotropydev">MaxAnisotropyDev</a></h1>
<p>Calculates the maximum anisotropy (directionality) in elevation deviation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=3, 
    step=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_anisotropy_dev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: January 26, 2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MaxAnisotropyDevSignature"></a></p>
<h1 id="maxanisotropydevsignature"><a class="header" href="#maxanisotropydevsignature">MaxAnisotropyDevSignature</a></h1>
<p>Calculates the anisotropy in deviation from mean for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--points</td><td>Input vector points file</td></tr>
<tr><td>-o, --output</td><td>Output HTML file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_anisotropy_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: 27/03/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MaxBranchLength"></a></p>
<h1 id="maxbranchlength"><a class="header" href="#maxbranchlength">MaxBranchLength</a></h1>
<p>Maximum branch length (<code>Bmax</code>) is the longest branch length between a grid cell's flowpath
and the flowpaths initiated at each of its neighbours. It can be conceptualized as the
downslope distance that a volume of water that is split into two portions by a drainage
divide would travel before reuniting.</p>
<p>If the two flowpaths of neighbouring grid cells do not intersect, <code>Bmax</code> is simply the
flowpath length from the starting cell to its terminus at the edge of the grid or a cell
with undefined flow direction (i.e. a pit cell either in a topographic depression or at
the edge of a major body of water).</p>
<p>The pattern of <code>Bmax</code> derived from a DEM should be familiar to anyone who has interpreted
upslope contributing area images. In fact, <code>Bmax</code> can be thought of as the complement of
upslope contributing area. Whereas contributing area is greatest along valley bottoms and lowest at
drainage divides, <code>Bmax</code> is greatest at divides and lowest along channels. The two topographic
attributes are also distinguished by their units of measurements; <code>Bmax</code> is a length rather
than an area. The presence of a major drainage divide between neighbouring grid cells is apparent in
a <code>Bmax</code> image as a linear feature, often two grid cells wide, of relatively high values. This
property makes <code>Bmax</code> a useful land surface parameter for mapping ridges and divides.</p>
<p><code>Bmax</code> is useful in the study of landscape structure, particularly with respect to drainage patterns.
The index gives the relative significance of a specific location along a divide, with respect to the
dispersion of materials across the landscape, in much the same way that stream ordering can be used
to assess stream size.</p>
<p><img src="../img/MaxBranchLength_fig1.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./hydrological_analysis.html#flowlengthdiff"><strong>FlowLengthDiff</strong></a></p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Seibert J. 2013. Measuring the significance of a divide to local drainage patterns.
International Journal of Geographical Information Science, 27: 1453-1468. DOI:
10.1080/13658816.2012.705289</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--log</td><td>Optional flag to request the output be log-transformed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_branch_length(
    dem, 
    output, 
    log=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxBranchLength -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_branch_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/07/2017</p>
<p><em>Last Modified</em>: 18/10/2019</p>
<p><a name="MaxDifferenceFromMean"></a></p>
<h1 id="maxdifferencefrommean"><a class="header" href="#maxdifferencefrommean">MaxDifferenceFromMean</a></h1>
<p>Calculates the maximum difference from mean elevation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster DIFFmax magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster DIFFmax scale file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_difference_from_mean(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDifferenceFromMean -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_diff_from_mean.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/08/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MaxDownslopeElevChange"></a></p>
<h1 id="maxdownslopeelevchange"><a class="header" href="#maxdownslopeelevchange">MaxDownslopeElevChange</a></h1>
<p>This tool calculates the maximum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#mindownslopeelevchange"><strong>MinDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MaxElevDevSignature"></a></p>
<h1 id="maxelevdevsignature"><a class="header" href="#maxelevdevsignature">MaxElevDevSignature</a></h1>
<p>Calculates the maximum elevation deviation over a range of spatial scales and for a set of points.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--points</td><td>Input vector points file</td></tr>
<tr><td>-o, --output</td><td>Output HTML file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elev_dev_signature(
    dem, 
    points, 
    output, 
    min_scale, 
    max_scale, 
    step=10, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.tif ^
--output=topo_position.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_elev_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: March 1, 2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MaxElevationDeviation"></a></p>
<h1 id="maxelevationdeviation"><a class="header" href="#maxelevationdeviation">MaxElevationDeviation</a></h1>
<p>This tool can be used to calculate the maximum deviation from mean elevation, <em>DEVmax</em> (Lindsay et al. 2015) for each
grid cell in a digital elevation model (DEM) across a range specified spatial scales. <em>DEV</em>
is an elevation residual index and is essentially equivalent to a local elevation z-score.
This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. The multi-scaled calculation
of <em>DEVmax</em> utilizes an integral image approach (Crow, 1984) to ensure highly efficient
filtering that is invariant with filter size, which is the algorithm characteristic that allows for
this densely sampled multi-scale analysis. In this way, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> allows users
to estimate the locally optimal scale with which to estimate <em>DEV</em> on a pixel-by-pixel basis.
This multi-scaled version of local topographic position can reveal significant terrain
characteristics and can aid with soil, vegetation, landform, and other mapping applications
that depend on geomorphometric characterization.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM). The range of scales that are
evaluated in calculating <em>DEVmax</em> are determined by the user-specified <code>--min_scale</code>, <code>--max_scale</code>, and <code>--step</code>
parameters. All filter radii between the minimum and maximum scales, increasing by <code>step</code>, will be evaluated.
The scale parameters are in units of grid cells and specify kernel size &quot;radii&quot; (<em>r</em>), such that:</p>
<blockquote>
<p><em>d</em> = 2<em>r</em> + 1</p>
</blockquote>
<p>That is, a radii of 1, 2, 3... yields a square filters of dimension (<em>d</em>) 3 x 3, 5 x 5, 7 x 7...</p>
<p><em>DEV</em> is estimated at each tested filter size and every grid cell is assigned the maximum <em>DEV</em> value
across the evaluated scales.</p>
<p>The user must specify the file names of two output rasters, including the magnitude (<em>DEVmax</em>) and a
second raster the assigns each pixel the scale at which <em>DEVmax</em> is encountered (<em>DEVscale</em>). The
<em>DEVscale</em> raster can be very useful for revealing multi-scale landscape structure.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleelevationpercentile"><strong>MultiscaleElevationPercentile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elevation_deviation(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevationDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/max_elev_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 20, 2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MinDownslopeElevChange"></a></p>
<h1 id="mindownslopeelevchange"><a class="header" href="#mindownslopeelevchange">MinDownslopeElevChange</a></h1>
<p>This tool calculates the minimum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#maxdownslopeelevchange"><strong>MaxDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/min_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="MultidirectionalHillshade"></a></p>
<h1 id="multidirectionalhillshade"><a class="header" href="#multidirectionalhillshade">MultidirectionalHillshade</a></h1>
<p>This tool performs a hillshade operation (also called shaded relief) on an input digital elevation model (DEM)
with multiple sources of illumination. The user must specify the  name of the input DEM (<code>--dem</code>) and the output
hillshade image name (<code>--output</code>). Other parameters that must be specified include the altitude of the illumination
sources (<code>--altitude</code>; i.e. the elevation of the sun above the horizon, measured as an angle
from 0 to 90 degrees) and the Z conversion factor (<code>--zfactor</code>). The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians. The Z conversion factor can also be used
used to apply a vertical exageration to further emphasize landforms within the hillshade output.</p>
<p>The hillshade value (<em>HS</em>) of a DEM grid cell is calculate as:</p>
<blockquote>
<p><em>HS</em> = tan(<em>s</em>) / [1 - tan(<em>s</em>)<sup>2</sup>]<sup>0.5</sup> x [sin(<em>Alt</em>) / tan(<em>s</em>) - cos(<em>Alt</em>) x sin(<em>Az</em> - <em>a</em>)]</p>
</blockquote>
<p>where <em>s</em> and <em>a</em> are the local slope gradient and aspect (orientation) respectively and <em>Alt</em> and <em>Az</em>
are the illumination source altitude and azimuth respectively. Slope and aspect are calculated using
Horn's (1981) 3rd-order finate difference method.</p>
<p>Lastly, the user must specify whether or not to use full 360-degrees of illumination sources (<code>--full_mode</code>). When this
flag is not specified, the tool will perform a weighted summation of the hillshade images from four illumination azimuth
positions at 225, 270, 315, and 360 (0) degrees, given weights of 0.1, 0.4, 0.4, and 0.1 respectively. When run in the
full 360-degree mode, eight illumination source azimuths are used to calculate the output at 0, 45, 90, 135, 180, 225,
270, and 315 degrees, with weights of 0.15, 0.125, 0.1, 0.05, 0.1, 0.125, 0.15, and 0.2 respectively.</p>
<p>Classic hillshade (Azimuth=315, Altitude=45.0)
<img src="../img/MultidirectionalHillshade_fig1.png" alt="" /></p>
<p>Multi-directional hillshade (Altitude=45.0, Four-direction mode)
<img src="../img/MultidirectionalHillshade_fig2.png" alt="" /></p>
<p>Multi-directional hillshade (Altitude=45.0, 360-degree mode)
<img src="../img/MultidirectionalHillshade_fig3.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#hillshade"><strong>Hillshade</strong></a>, <a href="./geomorphometric_analysis.html#hypsometricallytintedhillshade"><strong>HypsometricallyTintedHillshade</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--altitude</td><td>Illumination source altitude in degrees</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--full_mode</td><td>Optional flag indicating whether to use full 360-degrees of illumination sources</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multidirectional_hillshade(
    dem, 
    output, 
    altitude=45.0, 
    zfactor=None, 
    full_mode=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultidirectionalHillshade -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif ^
--altitude=30.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multidirectional_hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2020</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MultiscaleElevationPercentile"></a></p>
<h1 id="multiscaleelevationpercentile"><a class="header" href="#multiscaleelevationpercentile">MultiscaleElevationPercentile</a></h1>
<p>This tool calculates the most elevation percentile (EP) across a range of spatial scales.
EP is a measure of local topographic position (LTP) and expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentile of the
elevation distribution within the filter window, such that:</p>
<blockquote>
<p>EP = count<sub>i∈C</sub>(z<sub>i</sub> &gt; z<sub>0</sub>) x (100 / n<sub>C</sub>)</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>i</sub> is the elevation
of cell <em>i</em> contained within the neighboring set C, and n<sub>C</sub> is the number
of grid cells contained within the window.</p>
<p>EP is unsigned and expressed as a percentage, bound between 0%
and 100%. This tool outputs two rasters, the multiscale EP magnitude (<code>--out_mag</code>) and
the scale at which the most extreme EP value occurs (<code>--out_scale</code>). <strong>The magnitude raster is
the most extreme EP value (i.e. the furthest from 50%) for each grid cell encountered within
the tested scales of EP.</strong></p>
<p>Quantile-based estimates (e.g., the median and interquartile
range) are often used in nonparametric statistics to provide data
variability estimates without assuming the distribution is normal.
Thus, EP is largely unaffected by irregularly shaped elevation frequency
distributions or by outliers in the DEM, resulting in a highly robust metric
of LTP. In fact, elevation distributions within small to medium sized
neighborhoods often exhibit skewed, multimodal, and non-Gaussian
distributions, where the occurrence of elevation errors can often result
in distribution outliers. Thus, based on these statistical characteristics,
EP is considered one of the most robust representation of LTP.</p>
<p>The algorithm implemented by this tool uses the relatively efficient running-histogram filtering algorithm of Huang
et al. (1979). Because most DEMs contain floating point data, elevation values must be rounded to be binned. The
<code>--sig_digits</code> parameter is used to determine the level of precision preserved during this binning process. The
algorithm is parallelized to further aid with computational efficiency.</p>
<p>Experience with multiscale EP has shown that it is highly variable at
shorter scales and changes more gradually at broader scales. Therefore, a nonlinear scale sampling
interval is used by this tool to ensure that the scale sampling density is higher for short scale
ranges and coarser at longer tested scales, such that:</p>
<blockquote>
<p><em>r<sub>i</sub></em> = <em>r<sub>L</sub></em> + [step × (i - <em>r<sub>L</sub></em>)]<sup><em>p</em></sup></p>
</blockquote>
<p>Where <em>ri</em> is the filter radius for step <em>i</em> and <em>p</em> is the nonlinear scaling factor (<code>--step_nonlinearity</code>)
and a step size (<code>--step</code>) of <em>step</em>.</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:
<code>ElevationPercentile</code>, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster roughness scale file</td></tr>
<tr><td>--sig_digits</td><td>Number of significant digits</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
<tr><td>--num_steps</td><td>Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td>Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_elevation_percentile(
    dem, 
    out_mag, 
    out_scale, 
    sig_digits=3, 
    min_scale=4, 
    step=1, 
    num_steps=10, 
    step_nonlinearity=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleElevationPercentile -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --step=5 ^
--num_steps=100 --step_nonlinearity=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_elev_percentile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/12/2019</p>
<p><em>Last Modified</em>: 22/12/2019</p>
<p><a name="MultiscaleRoughness"></a></p>
<h1 id="multiscaleroughness"><a class="header" href="#multiscaleroughness">MultiscaleRoughness</a></h1>
<p>Calculates surface roughness over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster roughness scale file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughness -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_roughness.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/02/2018</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MultiscaleRoughnessSignature"></a></p>
<h1 id="multiscaleroughnesssignature"><a class="header" href="#multiscaleroughnesssignature">MultiscaleRoughnessSignature</a></h1>
<p>Calculates the surface roughness for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--points</td><td>Input vector points file</td></tr>
<tr><td>-o, --output</td><td>Output HTML file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughnessSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_roughness_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/02/2018</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MultiscaleStdDevNormals"></a></p>
<h1 id="multiscalestddevnormals"><a class="header" href="#multiscalestddevnormals">MultiscaleStdDevNormals</a></h1>
<p>This tool can be used to map the spatial pattern of maximum spherical standard deviation
(σ<sub><em>s max</em></sub>; <code>--out_mag</code>), as well as the scale at which maximum spherical standard deviation occurs
(<em>r<sub>max</sub></em>; <code>--out_scale</code>), for each grid cell in an input DEM (<code>--dem</code>). This serves as a multi-scale measure
of surface roughness, or topographic complexity. The spherical standard deviation (σ<sub>s</sub>) is
a measure of the angular spread among <em>n</em> unit vectors and is defined as:</p>
<blockquote>
<p>σ<sub>s</sub> = √[-2ln(<em>R</em> / <em>N</em>)] × 180 / π</p>
</blockquote>
<p>Where <em>R</em> is the resultant vector length and is derived from the sum of the <em>x</em>, <em>y</em>, and <em>z</em> components
of each of the <em>n</em> normals contained within a filter kernel, which designates a tested spatial scale. Each
unit vector is a 3-dimensional measure of the surface orientation and slope at each grid cell center. The
maximum spherical standard deviation is:</p>
<blockquote>
<p>σ<sub><em>s max</em></sub>=<em>max</em>{σs(<em>r</em>):<em>r</em>=<em>r<sub>L</sub></em>...<em>r<sub>U</sub></em>},</p>
</blockquote>
<p>Experience with roughness scale signatures has shown that σ<sub><em>s max</em></sub> is highly variable at
shorter scales and changes more gradually at broader scales. Therefore, a nonlinear scale sampling
interval is used by this tool to ensure that the scale sampling density is higher for short scale
ranges and coarser at longer tested scales, such that:</p>
<blockquote>
<p><em>r<sub>i</sub></em> = <em>r<sub>L</sub></em> + [step × (i - <em>r<sub>L</sub></em>)]<sup><em>p</em></sup></p>
</blockquote>
<p>Where <em>ri</em> is the filter radius for step <em>i</em> and <em>p</em> is the nonlinear scaling factor (<code>--step_nonlinearity</code>)
and a step size (<code>--step</code>) of <em>step</em>.</p>
<p>Use the <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a> tool if you need to calculate σ<sub>s</sub> for a single scale.</p>
<p><em>Reference</em>:</p>
<p>JB Lindsay, DR Newman, and A  Francioni. 2019 Scale-Optimized Surface Roughness for Topographic Analysis.
<em>Geosciences</em>, 9(322) doi: 10.3390/geosciences9070322.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#multiscalestddevnormalssignature"><strong>MultiscaleStdDevNormalsSignature</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--out_mag</td><td>Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale</td><td>Output raster roughness scale file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
<tr><td>--num_steps</td><td>Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td>Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_std_dev_normals(
    dem, 
    out_mag, 
    out_scale, 
    min_scale=1, 
    step=1, 
    num_steps=10, 
    step_nonlinearity=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleStdDevNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --step=5 ^
--num_steps=100 --step_nonlinearity=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_std_dev_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/06/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MultiscaleStdDevNormalsSignature"></a></p>
<h1 id="multiscalestddevnormalssignature"><a class="header" href="#multiscalestddevnormalssignature">MultiscaleStdDevNormalsSignature</a></h1>
<p>Calculates the surface roughness for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--points</td><td>Input vector points file</td></tr>
<tr><td>-o, --output</td><td>Output HTML file</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step</td><td>Step size as any positive non-zero integer</td></tr>
<tr><td>--num_steps</td><td>Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td>Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_std_dev_normals_signature(
    dem, 
    points, 
    output, 
    min_scale=1, 
    step=1, 
    num_steps=10, 
    step_nonlinearity=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleStdDevNormalsSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --step=5 --num_steps=100 ^
--step_nonlinearity=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_std_dev_normals_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/06/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="MultiscaleTopographicPositionImage"></a></p>
<h1 id="multiscaletopographicpositionimage"><a class="header" href="#multiscaletopographicpositionimage">MultiscaleTopographicPositionImage</a></h1>
<p>This tool creates a multiscale topographic position (MTP) image (<a href="https://www.uoguelph.ca/%7Ehydrogeo/pubs/UpdatedPosterMapSm.png">see here for an
example</a>) from three DEV<sub>max</sub> rasters of differing
spatial scale ranges. Specifically, <a href="./geomorphometric_analysis.html#multiscaletopographicpositionimage"><strong>MultiscaleTopographicPositionImage</strong></a> takes three DEV<sub>max</sub> <em>magnitude</em>
rasters, created using the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool, as inputs. The three inputs should correspond to the elevation
deviations in the local (<code>--local</code>), meso (<code>--meso</code>), and broad (<code>--broad</code>) scale ranges and will be forced into the
blue, green, and red colour components of the colour composite output (<code>--output</code>) raster. The image lightness value
(<code>--lightness</code>) controls the overall brightness of the output image, as depending on the topography and scale ranges,
these images can appear relatively dark. Higher values result in brighter, more colourful output images.</p>
<p>The output images can take some training to interpret correctly and a detailed explanation can be found in Lindsay et al.
(2015). Sites within the landscape that occupy prominent topographic positions, either
low-lying or elevated, will be apparent by their bright colouring in the MTP image. Those that are coloured more strongly in
the blue are promient at the local scale range; locations that are more strongly green coloured are promient at the meso scale;
and bright reds in the MTP image are associated with broad-scale landscape prominence. Of course, combination colours are also possible when
topography is elevated or low-lying across multiple scale ranges. For example, a yellow area would indicated a site of prominent
topographic position across the meso and broadest scale ranges.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--local</td><td>Input local-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--meso</td><td>Input meso-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--broad</td><td>Input broad-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--lightness</td><td>Image lightness value (default is 1.2)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_topographic_position_image(
    local, 
    meso, 
    broad, 
    output, 
    lightness=1.2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleTopographicPositionImage -v ^
--wd=&quot;/path/to/data/&quot; --local=DEV_local.tif --meso=DEV_meso.tif ^
--broad=DEV_broad.tif -o=output.tif --lightness=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/multiscale_topographic_position_image.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="NumDownslopeNeighbours"></a></p>
<h1 id="numdownslopeneighbours"><a class="header" href="#numdownslopeneighbours">NumDownslopeNeighbours</a></h1>
<p>This tool calculates the number of downslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output image can therefore have values raning from 0 to 8. A
raster grid cell with eight downslope neighbours is a peak and a cell with zero downslope neighbours is a pit. This
tool can be used with the <a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a> tool to assess the degree of local flow divergence/convergence.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_downslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumDownslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/num_downslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="NumUpslopeNeighbours"></a></p>
<h1 id="numupslopeneighbours"><a class="header" href="#numupslopeneighbours">NumUpslopeNeighbours</a></h1>
<p>This tool calculates the number of upslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output raster can therefore have values ranging from 0 to 8, although
in a DEM that has been hydrologically conditioned (i.e. depressions and flats removed), the values of the output will
not exceed seven. This tool can be used with the <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a> tool to assess the degree of local flow
divergence/convergence.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_upslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumUpslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/num_upslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="Openness"></a></p>
<h1 id="openness"><a class="header" href="#openness">Openness</a></h1>
<blockquote>
<p>Note this tool is part of a WhiteboxTools extension toolset. Please contact
<a href="https://www.whiteboxgeo.com">Whitebox Geospatial Inc.</a> for information about purchasing a license
activation key (<a href="https://www.whiteboxgeo.com">https://www.whiteboxgeo.com</a>).</p>
</blockquote>
<p>This tool calculates the Yokoyama et al. (2002) topographic openness index from an input DEM (<code>--input</code>).
Openness has two viewer perspectives, which correspond with positive and negative openness outputs (<code>--pos_output</code>
and <code>--neg_output</code>). Positive values, expressing openness above the surface, are high for convex forms,
whereas negative values describe this attribute below the surface and are high for concave forms. Openness
is an angular value that is an average of the horizon angle in the eight cardinal directions to a maximum
search distance (<code>--dist</code>), measured in grid cells. Openness rasters are best visualized using a greyscale palette.</p>
<p>Positive Openness:
<img src="../img/Openness_pos.png" alt="" /></p>
<p>Negative Openness:
<img src="../img/Openness_neg.png" alt="" /></p>
<p><em>References</em>:</p>
<p>Yokoyama, R., Shirasawa, M., &amp; Pike, R. J. (2002). Visualizing topography by openness: a new
application of image processing to digital elevation models. Photogrammetric engineering and
remote sensing, 68(3), 257-266.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#timeindaylight"><strong>TimeInDaylight</strong></a>, <a href="./geomorphometric_analysis.html#hillshade"><strong>Hillshade</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Name of the input raster image file</td></tr>
<tr><td>--pos_output</td><td>Name of the positive openness output raster file</td></tr>
<tr><td>--neg_output</td><td>Name of the negative openness output raster file</td></tr>
<tr><td>--dist</td><td>Search distance, in grid cells</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.openness(
    i, 
    pos_output, 
    neg_output, 
    dist=20, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt; ./whitebox_tools -r=Openness --input=DEM.tif ^
--pos_output=positive_openness.tif ^
--neg_output=negative_openness.tif --dist=500 
</code></pre>
<p>Source code is unavailable due to proprietary license.</p>
<p><em>Author</em>: Whitebox Geospatial Inc. (c)</p>
<p><em>Created</em>: 30/03/2021</p>
<p><em>Last Modified</em>: 30/03/2021</p>
<p><a name="PennockLandformClass"></a></p>
<h1 id="pennocklandformclass"><a class="header" href="#pennocklandformclass">PennockLandformClass</a></h1>
<p>Tool can be used to perform a simple landform classification based on measures of slope gradient
and curvature derived from a user-specified digital elevation model (DEM). The classification
scheme is based on the method proposed by Pennock, Zebarth, and DeJong (1987). The scheme divides
a landscape into seven element types, including: convergent footslopes (CFS), divergent footslopes
(DFS), convergent shoulders (CSH), divergent shoulders (DSH), convergent backslopes (CBS), divergent
backslopes (DBS), and level terrain (L). The output raster image will record each of these base element
types as:</p>
<table><thead><tr><th>Element Type</th><th>Code</th></tr></thead><tbody>
<tr><td>CFS</td><td>1</td></tr>
<tr><td>DFS</td><td>2</td></tr>
<tr><td>CSH</td><td>3</td></tr>
<tr><td>DSH</td><td>4</td></tr>
<tr><td>CBS</td><td>5</td></tr>
<tr><td>DBS</td><td>6</td></tr>
<tr><td>L</td><td>7</td></tr>
</tbody></table>
<p>The definition of each of the elements, based on the original Pennock et al. (1987) paper, is
as follows:</p>
<table><thead><tr><th align="left">PROFILE</th><th align="left">GRADIENT</th><th align="left">PLAN</th><th align="left">Element</th></tr></thead><tbody>
<tr><td align="left">Concave ( -0.10)</td><td align="left">High &gt;3.0</td><td align="left">Concave 0.0</td><td align="left">CFS</td></tr>
<tr><td align="left">Concave ( -0.10)</td><td align="left">High &gt;3.0</td><td align="left">Convex &gt;0.0</td><td align="left">DFS</td></tr>
<tr><td align="left">Convex (&gt;0.10)</td><td align="left">High &gt;3.0</td><td align="left">Concave 0.0</td><td align="left">CSH</td></tr>
<tr><td align="left">Convex (&gt;0.10)</td><td align="left">High &gt;3.0</td><td align="left">Convex &gt;0.0</td><td align="left">DSH</td></tr>
<tr><td align="left">Linear (-0.10...0.10)</td><td align="left">High &gt;3.0</td><td align="left">Concave 0.0</td><td align="left">CBS</td></tr>
<tr><td align="left">Linear (-0.10...0.10)</td><td align="left">High &gt;3.0</td><td align="left">Convex &gt;0.0</td><td align="left">DBS</td></tr>
<tr><td align="left">--</td><td align="left">Low 3.0</td><td align="left">--</td><td align="left">L</td></tr>
</tbody></table>
<p>Where PROFILE is profile curvature, GRADIENT is the slope gradient, and PLAN is the plan curvature.
Note that these values are likely landscape and data specific and can be adjusted by the user.
Landscape classification schemes that are based on terrain attributes are highly sensitive to
short-range topographic variability (i.e. roughness) and can benefit from pre-processing the DEM
with a smoothing filter to reduce the effect of surface roughness and emphasize the longer-range
topographic signal. The <a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a> tool
offers excellent performance in smoothing DEMs without removing the sharpness of breaks-in-slope.</p>
<p><em>Reference</em>:</p>
<p>Pennock, D.J., Zebarth, B.J., and DeJong, E. (1987) Landform classification and soil distribution
in hummocky terrain, Saskatchewan, Canada. Geoderma, 40: 297-315.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--slope</td><td>Slope threshold value, in degrees (default is 3.0)</td></tr>
<tr><td>--prof</td><td>Profile curvature threshold value (default is 0.1)</td></tr>
<tr><td>--plan</td><td>Plan curvature threshold value (default is 0.0)</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.pennock_landform_class(
    dem, 
    output, 
    slope=3.0, 
    prof=0.1, 
    plan=0.0, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PennockLandformClass -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --slope=3.0 ^
--prof=0.1 --plan=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/pennock_landform_class.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="PercentElevRange"></a></p>
<h1 id="percentelevrange"><a class="header" href="#percentelevrange">PercentElevRange</a></h1>
<p>Percent elevation range (PER) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentage of the
elevation range within the neighbourhood filter window, such that:</p>
<blockquote>
<p>PER = z<sub>0</sub> / (z<sub>max</sub> - z<sub>min</sub>) x 100</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>max</sub> is the maximum
neighbouring elevation, and z<sub>min</sub> is the minimum neighbouring elevation.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>Compared with <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a> and <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, PER is a less robust measure of LTP that is susceptible
to outliers in neighbouring elevations (e.g. the presence of off-terrain objects in the DEM).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_elev_range(
    dem, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentElevRange -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/percent_elev_range.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="PlanCurvature"></a></p>
<h1 id="plancurvature"><a class="header" href="#plancurvature">PlanCurvature</a></h1>
<p>This tool calculates the plan curvature (i.e. contour curvature), or the rate of change in
aspect along a contour line, from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Plan curvature characterizes the
degree of flow convergence or divergence within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Plan curvature is negative for diverging flow along ridges and positive for
convergent areas, e.g. along valley bottoms.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.plan_curvature(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PlanCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/plan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/06/2017</p>
<p><em>Last Modified</em>: 01/03/2021</p>
<p><a name="Profile"></a></p>
<h1 id="profile"><a class="header" href="#profile">Profile</a></h1>
<p>This tool can be used to plot the data profile, along a set of one or more vector lines (<code>--lines</code>), in
an input (<code>--surface</code>) digital elevation model (DEM), or other surface model. The data profile plots
surface height (y-axis) against distance along profile (x-axis). The tool outputs an interactive SVG line
graph embedded in an HTML document (<code>--output</code>). If the vector lines file contains multiple line features,
the output plot will contain each of the input profiles.</p>
<p>If you want to extract the <a href="http://www.fao.org/docrep/003/X6841E/X6841E02.HTM">longitudinal profile</a> of a river,
use the <a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a> tool instead.</p>
<p><em>See Also</em>:
<a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a>, <a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--lines</td><td>Input vector line file</td></tr>
<tr><td>--surface</td><td>Input raster surface file</td></tr>
<tr><td>-o, --output</td><td>Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile(
    lines, 
    surface, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Profile -v --wd=&quot;/path/to/data/&quot; ^
--lines=profile.shp --surface=dem.tif -o=profile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/profile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/02/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="ProfileCurvature"></a></p>
<h1 id="profilecurvature"><a class="header" href="#profilecurvature">ProfileCurvature</a></h1>
<p>This tool calculates the profile curvature, or the rate of change in slope along a flow line,
from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Profile curvature characterizes the
degree of downslope acceleration or deceleration within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation because
curvature values are typically very small. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Profile curvature is negative for slope increasing downhill (convex flow profile,
typical of upper slopes) and positive for slope decreasing downhill (concave, typical of lower slopes).</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile_curvature(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ProfileCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/prof_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/062017</p>
<p><em>Last Modified</em>: 01/03/2021</p>
<p><a name="RelativeAspect"></a></p>
<h1 id="relativeaspect"><a class="header" href="#relativeaspect">RelativeAspect</a></h1>
<p>This tool creates a new raster in which each grid cell is assigned the terrain aspect relative to a user-specified
direction (<code>--azimuth</code>). Relative terrain aspect is the angular distance (measured in degrees) between the land-surface
aspect and the assumed regional wind azimuth (Bohner and Antonic, 2007). It is bound between 0-degrees (windward direction)
and 180-degrees (leeward direction). Relative terrain aspect is the simplest of the measures of topographic exposure to
wind, taking into account terrain orientation only and neglecting the influences of topographic shadowing by distant
landforms and the deflection of wind by topography.</p>
<p>The user must specify the name of a digital elevation model (DEM) (<code>--dem</code>) and an azimuth (i.e. a wind direction). The
Z Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the same in the DEM.
When this is the case, the algorithm will multiply each elevation in the DEM by the Z Conversion Factor.</p>
<p><em>Reference</em>:</p>
<p>Böhner, J., and Antonić, O. (2009). Land-surface parameters specific to topo-climatology. Developments in Soil
Science, 33, 195-226.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--azimuth</td><td>Illumination source azimuth</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_aspect(
    dem, 
    output, 
    azimuth=0.0, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeAspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --azimuth=180.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/relative_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/06/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="RelativeTopographicPosition"></a></p>
<h1 id="relativetopographicposition"><a class="header" href="#relativetopographicposition">RelativeTopographicPosition</a></h1>
<p>Relative topographic position (RTP) is an index of local topographic position (i.e. how
elevated or low-lying a site is relative to its surroundings) and is a modification of percent
elevation range (PER; <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a>) and accounts for the elevation distribution. Rather than
positioning the central cell's elevation solely between the filter extrema, RTP is a piece-wise
function that positions the central elevation relative to the minimum (z<sub>min</sub>), mean (μ),
and maximum values (z<sub>max</sub>), within a local neighbourhood of a user-specified size (<code>--filterx</code>,
<code>--filtery</code>), such that:</p>
<blockquote>
<p>RTP = (z<sub>0</sub> − μ) / (μ − z<sub>min</sub>), if z<sub>0</sub> &lt; μ</p>
<p>OR</p>
<p>RTP = (z<sub>0</sub> − μ) / (z<sub>max</sub> - μ), if z<sub>0</sub> &gt;= μ
</p>
</blockquote>
<p>The resulting index is bound by the interval [−1, 1], where the sign indicates if the cell is above or below
than the filter mean. Although RTP uses the mean to define two linear functions, the reliance on the filter
extrema is expected to result in sensitivity to outliers. Furthermore, the use of the mean implies assumptions
of unimodal and symmetrical elevation distribution.</p>
<p>In many cases, Elevation Percentile (<a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>) and deviation from mean elevation (<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>)
provide more suitable and robust measures of relative topographic position.</p>
<p><em>Reference</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic
position for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_topographic_position(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeTopographicPosition -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/relative_topographic_position.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="RemoveOffTerrainObjects"></a></p>
<h1 id="removeoffterrainobjects"><a class="header" href="#removeoffterrainobjects">RemoveOffTerrainObjects</a></h1>
<p>This tool can be used to create a bare-earth DEM from a fine-resolution digital surface model. The
tool is typically applied to LiDAR DEMs which frequently contain numerous off-terrain objects (OTOs) such
as buildings, trees and other vegetation, cars, fences and other anthropogenic objects. The algorithm
works by finding and removing steep-sided peaks within the DEM. All peaks within a sub-grid, with a
dimension of the user-specified maximum OTO size (<code>--filter</code>), in pixels, are identified and removed.
Each of the edge cells of the peaks are then examined to see if they have a slope that is less than the
user-specified minimum OTO edge slope (<code>--slope</code>) and a back-filling procedure is used. This ensures that
OTOs are distinguished from natural topographic features such as hills. The DEM is preprocessed using a
white top-hat transform, such that elevations are normalized for the underlying ground surface.</p>
<p>Note that this tool is appropriate to apply to rasterized LiDAR DEMs. Use the <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a>
tool to remove or classify OTOs within a LiDAR point-cloud.</p>
<p><em>Reference</em>:</p>
<p>J.B. Lindsay (2018) A new method for the removal of off-terrain objects from LiDAR-derived raster surface
models. Available online, DOI: <a href="https://www.researchgate.net/publication/323003064_A_new_method_for_the_removal_of_off-terrain_objects_from_LiDAR-derived_raster_surface_models">10.13140/RG.2.2.21226.62401</a></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#mapoffterrainobjects"><strong>MapOffTerrainObjects</strong></a>, <a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a>, <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Filter size (cells)</td></tr>
<tr><td>--slope</td><td>Slope threshold value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_off_terrain_objects(
    dem, 
    output, 
    filter=11, 
    slope=15.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemoveOffTerrainObjects -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=bare_earth_DEM.tif ^
--filter=25 --slope=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/remove_off_terrain_objects.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><em>Last Modified</em>: 07/08/2020</p>
<p><a name="RuggednessIndex"></a></p>
<h1 id="ruggednessindex"><a class="header" href="#ruggednessindex">RuggednessIndex</a></h1>
<p>The terrain ruggedness index (TRI) is a measure of local topographic relief. The TRI calculates
the root-mean-square-deviation (RMSD) for each grid cell in a digital elevation model (DEM),
calculating the residuals (i.e. elevation differences) between a grid cell and its eight neighbours.
Notice that, unlike the output of this tool, the original Riley et al. (1999) TRI did not normalize
for the number of cells in the local window (i.e. it is a root-square-deviation only). However,
using the mean has the advantage of allowing for the varying number of neighbouring cells along
the grid edges and in areas bordering NoData cells. This modification does however imply that the
ouput of this tool cannot be directly compared with the index ranges of level to extremely rugged
terrain provided in Riley et al. (1999)</p>
<p><em>Reference</em>:</p>
<p>Riley, S. J., DeGloria, S. D., and Elliot, R. (1999). Index that quantifies topographic heterogeneity.
<em>Intermountain Journal of Sciences</em>, 5(1-4), 23-27.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ruggedness_index(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RuggednessIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/ruggedness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="SedimentTransportIndex"></a></p>
<h1 id="sedimenttransportindex"><a class="header" href="#sedimenttransportindex">SedimentTransportIndex</a></h1>
<p>This tool calculates the sediment transport index, or sometimes, length-slope (<em>LS</em>)
factor, based on input specific contributing area (<em>A<sub>s</sub></em>, i.e. the upslope
contributing area per unit contour length; <code>--sca</code>) and slope gradient
(β, measured in degrees; <code>--slope</code>) rasters. Moore et al. (1991) state that the physical potential for
sheet and rill erosion in upland catchments can be evaluated by the product <em>R K LS</em>,
a component of the Universal Soil Loss Equation (USLE), where <em>R</em> is a rainfall and
runoff erosivity factor, <em>K</em> is a soil erodibility factor, and <em>LS</em> is the length-slope
factor that accounts for the effects of topography on erosion. To predict erosion at a
point in the landscape the LS factor can be written as:</p>
<blockquote>
<p><em>LS</em> = (<em>n</em> + 1)(<em>A<sub>s</sub></em> / 22.13)<sup><em>n</em></sup>(sin(β) / 0.0896)<sup><em>m</em></sup></p>
</blockquote>
<p>where <em>n</em> = 0.4 (<code>--sca_exponent</code>) and <em>m</em> = 1.3 (<code>--slope_exponent</code>) in its original formulation.</p>
<p>This index is derived from unit stream-power theory and is sometimes used in place of the
length-slope factor in the revised universal soil loss equation (RUSLE) for slope lengths
less than 100 m and slope less than 14 degrees. Like many hydrological land-surface
parameters <a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a> assumes that contributing area is directly related to
discharge. Notice that <em>A<sub>s</sub></em> must not be log-transformed prior to being used;
<em>A<sub>s</sub></em> is commonly log-transformed to enhance visualization of the data. Also,
<em>A<sub>s</sub></em> can be derived using any of the available flow accumulation tools, alghough
better results usually result from application of multiple-flow direction algorithms such
as <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a> and <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a>. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#streampowerindex"><strong>StreamPowerIndex</strong></a>, <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca</td><td>Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope</td><td>Input raster slope file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--sca_exponent</td><td>SCA exponent value</td></tr>
<tr><td>--slope_exponent</td><td>Slope exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sediment_transport_index(
    sca, 
    slope, 
    output, 
    sca_exponent=0.4, 
    slope_exponent=1.3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SedimentTransportIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --sca_exponent=0.5 ^
--slope_exponent=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/sediment_transport_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="ShadowAnimation"></a></p>
<h1 id="shadowanimation"><a class="header" href="#shadowanimation">ShadowAnimation</a></h1>
<blockquote>
<p>Note this tool is part of a WhiteboxTools extension toolset. Please contact
<a href="https://www.whiteboxgeo.com">Whitebox Geospatial Inc.</a> for information about purchasing a license
activation key (<a href="https://www.whiteboxgeo.com">https://www.whiteboxgeo.com</a>).</p>
</blockquote>
<p>This tool creates an interactive animated GIF of shadows based on an input digital surface model (DSM).
The shadow model is based on the modelled positions of the sun throughout a user-specified date (<code>--date</code>)
sampling at a regular interval (<code>--interval</code>), in minutes. Similar to the <a href="./geomorphometric_analysis.html#timeindaylight"><strong>TimeInDaylight</strong></a> tool, this
tool uses calculated horizon angle (<a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>) values and a solar position model to determine which
grid cells are located in shadow areas due to distant obsticles. The calculation of horizon angle, requires
the user input a maximum search distance parameter (<code>--max_dist</code>).</p>
<p>The output (<code>--output</code>) of this tool is an HTML file, containing the interactive GIF animation. Users
are able to zoom and pan around the displayed DEV animation. The DSM may be rendered in one of several
available palettes (<code>--palette</code>) suitable for visualization topography. The user must also
specify the image height (<code>--height</code>) in the output file, the time delay (<code>--delay</code>, in milliseconds) used
in the GIF animation, and an optional label (<code>--label</code>), which will appear in the upper lefthand corner.
Note that the output is simply HTML, CSS, javascript code, and a GIF file, which can be readily embedded
in other documents.</p>
<p>Users should be aware that the outut GIF can be very large in size, depending on the size of the input
DEM file. To reduce the file size of the output, it may be desirable to coarsen the input DEM resolution using
image resampling (<a href="./image_processing_tools.html#resample"><strong>Resample</strong></a>).</p>
<p>The following is an example of what the output of this tool looks like. <strong>Click the image for
an interactive example.</strong></p>
<p><a href="https://jblindsay.github.io/ghrg/WhiteboxTools/samples/shadows/shadow_animation_Guelph_downtown.html"><img src="../img/ShadowAnimation.png" alt="" /></a></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#timeindaylight"><strong>TimeInDaylight</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Name of the input digital surface model (DSM) raster file</td></tr>
<tr><td>-p, --palette</td><td>DSM image palette; options are 'atlas', 'high_relief', 'arid', 'soft', 'muted', 'light_quant', 'purple', 'viridi', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', and 'none'</td></tr>
<tr><td>-o, --output</td><td>Name of the output HTML file (*.html)</td></tr>
<tr><td>--max_dist</td><td>Optional maximum search distance. Minimum value is 5 x cell size</td></tr>
<tr><td>-d, --date</td><td>Date in format DD/MM/YYYY</td></tr>
<tr><td>--interval</td><td>Time interval, in minutes (1-60)</td></tr>
<tr><td>--location</td><td>Location, defined as Lat/Long/UTC-offset (e.g. 43.5448/-80.2482/-4)</td></tr>
<tr><td>-h, --height</td><td>Image height, in pixels</td></tr>
<tr><td>--delay</td><td>GIF time delay in milliseconds</td></tr>
<tr><td>-l, --label</td><td>Label text (leave blank for none)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.shadow_animation(
    i, 
    output, 
    palette=&quot;atlas&quot;, 
    max_dist=&quot;&quot;, 
    date=&quot;21/06/2021&quot;, 
    interval=15, 
    location=&quot;43.5448/-80.2482/-4&quot;, 
    height=600, 
    delay=250, 
    label=&quot;&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt; ./whitebox_tools -r=ShadowAnimation -i=dsm.tif ^
-p='high_relief' -o=shadow_animation.html --max_dist=500 ^
--date='21/06/2021' --interval=20 --location='43.55/ -80.25/ ^
-4' --height=620 --delay=200 --label='Shadow Animation' 
</code></pre>
<p>Source code is unavailable due to proprietary license.</p>
<p><em>Author</em>: Whitebox Geospatial Inc. (c)</p>
<p><em>Created</em>: 01/05/2021</p>
<p><em>Last Modified</em>: 01/05/2021</p>
<p><a name="Slope"></a></p>
<h1 id="slope"><a class="header" href="#slope">Slope</a></h1>
<p>This tool calculates slope gradient (i.e. slope steepness in degrees, radians, or percent) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (111320.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>slope = arctan(f<sub>x</sub><sup>2</sup> + f<sub>y</sub><sup>2</sup>)<sup>0.5</sup></p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--units</td><td>Units of output raster; options include 'degrees', 'radians', 'percent'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope(
    dem, 
    output, 
    zfactor=None, 
    units=&quot;degrees&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Slope -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --units=&quot;radians&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 01/03/2021</p>
<p><a name="SlopeVsElevationPlot"></a></p>
<h1 id="slopevselevationplot"><a class="header" href="#slopevselevationplot">SlopeVsElevationPlot</a></h1>
<p>This tool can be used to create a slope versus average elevation plot for one or more digital elevation models (DEMs).
Similar to a hypsometric analysis (<a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a>), the slope-elevation relation can reveal the basic
topographic character of a site. The output of this analysis is an HTML document (<code>--output</code>) that contains the
slope-elevation chart. The tool can plot multiple slope-elevation analyses on the same chart by specifying multiple
input DEM files (<code>--inputs</code>). Each input DEM can have an optional watershed in which the slope-elevation analysis is
confined by specifying the optional <code>--watershed</code> flag. If multiple input DEMs are used, and a watershed is used to
confine the analysis to a sub-area, there must be the same number of input raster watershed files as input DEM files.
The order of the DEM and watershed files must the be same (i.e. the first DEM file must correspond to the first
watershed file, the second DEM file to the second watershed file, etc.). Each watershed file may contain one or more
watersheds, designated by unique identifiers.</p>
<p><img src="../img/SlopeVsElevationPlot_fig1.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs</td><td>Input DEM files</td></tr>
<tr><td>--watershed</td><td>Input watershed files (optional)</td></tr>
<tr><td>-o, --output</td><td>Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope_vs_elevation_plot(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SlopeVsElevationPlot -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/slope_vs_elev_plot.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/02/2018</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="SmoothVegetationResidual"></a></p>
<h1 id="smoothvegetationresidual"><a class="header" href="#smoothvegetationresidual">SmoothVegetationResidual</a></h1>
<blockquote>
<p>Note this tool is part of a WhiteboxTools extension toolset. Please contact
<a href="https://www.whiteboxgeo.com">Whitebox Geospatial Inc.</a> for information about purchasing a license
activation key (<a href="https://www.whiteboxgeo.com">https://www.whiteboxgeo.com</a>).</p>
</blockquote>
<p>This tool can smooth the roughness due to residual vegetation cover in LiDAR digital elevation models (DEMs).
Sometimes when LiDAR data are collected under heavy forest cover, particularly conifer species, the DEM
will contain substantial roughness, even if it is interpolated using last-return points only. This tool can
be used to reduce the roughness of the ground surface under these conditions. It works by identifying grid cells
that possess deviation in mean elevation (DEV, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>) values that are higher than a specified
threshold value (<code>--dev_threshold</code>) for tested scales less than a specified threshold (<code>--scale_threshold</code>).
DEV is measured for the input DEM (<code>--input</code>) using filter radii from 1 to a user-specified maximum (<code>--max_scale</code>).
The identified grid cells are then masked out and their elevations are re-interpolated using the surrounding,
non-masked values.</p>
<p>This method can work well under some conditions, and will further benefit from multiple passes of the tool, i.e.
run the tool using one set of parameters and then use the output (<code>--output</code>) as the input for the second pass.
Alternative approaches include use of the <a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a> tool, using low-pass filters such as the
<a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a> tool, or, if the point-cloud source data are available, classifying the ground
points using <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a> and excluding non-ground points from the interpolation.</p>
<p>The following image shows an image of a DEM that is badly impacted by heavy forest cover, with obvious vegetation
residual roughness.</p>
<p><img src="../img/SmoothVegetationResidual1.png" alt="" /></p>
<p>This image shows the impact of two-passes of the <a href="./geomorphometric_analysis.html#smoothvegetationresidual"><strong>SmoothVegetationResidual</strong></a> tool.</p>
<p><img src="../img/SmoothVegetationResidual2.png" alt="" />
<em>See Also</em>:
<a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a>, <a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a>, <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Name of the input digital elevation model (DEM) raster file</td></tr>
<tr><td>-o, --output</td><td>Name of the output raster file</td></tr>
<tr><td>--max_scale</td><td>Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--dev_threshold</td><td>DEVmax Threshold</td></tr>
<tr><td>--scale_threshold</td><td>DEVmax scale threshold</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.smooth_vegetation_residual(
    i, 
    output, 
    max_scale=30, 
    dev_threshold=1.0, 
    scale_threshold=5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>-./whitebox_tools -r=SmoothVegetationResidual -i=DEM.tif ^
-o=smoothed_DEM.tif --max_scale=50 --dev_threshold=0.5 ^
--scale_threshold=8 
</code></pre>
<p>Source code is unavailable due to proprietary license.</p>
<p><em>Author</em>: Whitebox Geospatial Inc. (c)</p>
<p><em>Created</em>: 09/05/2021</p>
<p><em>Last Modified</em>: 09/05/2021</p>
<p><a name="SphericalStdDevOfNormals"></a></p>
<h1 id="sphericalstddevofnormals"><a class="header" href="#sphericalstddevofnormals">SphericalStdDevOfNormals</a></h1>
<p>This tool can be used to calculate the spherical standard deviation of the distribution of surface normals
for an input digital elevation model (DEM; <code>--dem</code>). This is a measure of the angular dispersion of the surface
normal vectors within a local neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>
is therefore a measure of surface shape complexity, texture, and roughness. The <a href="https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread">
spherical standard deviation</a> (<em>s</em>) is defined as:</p>
<blockquote>
<p><em>s</em> = √[-2ln(<em>R</em> / <em>N</em>)] × 180 / π</p>
</blockquote>
<p>where <em>R</em> is the resultant vector length and <em>N</em> is the number of unit normal vectors
within the local neighbourhood. <em>s</em> is measured in degrees and is zero for simple planes and increases
infinitely with increasing surface complexity or roughness. Note that this formulation of the spherical
standard deviation assumes an underlying wrapped normal distribution.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular dispersion, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, <em>s</em> should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <em><strong>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</strong></em> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <em>R</em>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p>Hodgson, M. E., and Gaile, G. L. (1999). A cartographic modeling approach for surface orientation-related applications.
<em>Photogrammetric Engineering and Remote Sensing</em>, 65(1), 85-95.</p>
<p>Lindsay J. B., Newman* D. R., Francioni, A. 2019. Scale-optimized surface roughness for topographic analysis. <em>Geosciences</em>,
9(7) 322. DOI: 10.3390/geosciences9070322.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>--output</td><td>Output raster file</td></tr>
<tr><td>--filter</td><td>Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.spherical_std_dev_of_normals(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SphericalStdDevOfNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --output=roughness.tif ^
--filter=15 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/spherical_std_dev_of_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/05/2019</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="StandardDeviationOfSlope"></a></p>
<h1 id="standarddeviationofslope"><a class="header" href="#standarddeviationofslope">StandardDeviationOfSlope</a></h1>
<p>Calculates the standard deviation of slope from an input DEM, a metric of
roughness described by Grohmann et al., (2011).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster DEM file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--filterx</td><td>Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery</td><td>Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.standard_deviation_of_slope(
    i, 
    output, 
    zfactor=None, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationOfSlope -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--zfactor=1.0 --filterx=15 --filtery=15 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/standard_deviation_of_slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Anthony Francioni</p>
<p><em>Created</em>: 26/05/2018</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="StreamPowerIndex"></a></p>
<h1 id="streampowerindex"><a class="header" href="#streampowerindex">StreamPowerIndex</a></h1>
<p>This tool can be used to calculate the relative stream power (<em>RSP</em>) index. This index is directly related
to the stream power if the assumption can be made that discharge is directly proportional to upslope
contributing area (<em>A<sub>s</sub></em>; <code>--sca</code>). The index is calculated as:</p>
<blockquote>
<p><em>RSP</em> = <em>A<sub>s</sub></em><sup><em>p</em></sup> × tan(β)</p>
</blockquote>
<p>where <em>A<sub>s</sub></em> is the specific catchment area (i.e. the upslope contributing area per unit
contour length) estimated using one of the available flow accumulation algorithms; β is the local
slope gradient in degrees (<code>--slope</code>); and, <em>p</em> (<code>--exponent</code>) is a user-defined exponent term that
controls the location-specific relation between contributing area and discharge. Notice that
<em>A<sub>s</sub></em> must not be log-transformed prior to being used; <em>A<sub>s</sub></em> is commonly
log-transformed to enhance visualization of the data. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a> <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca</td><td>Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope</td><td>Input raster slope file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--exponent</td><td>SCA exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_power_index(
    sca, 
    slope, 
    output, 
    exponent=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamPowerIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --exponent=1.1 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/relative_stream_power_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><em>Last Modified</em>: 30/01/2020</p>
<p><a name="SurfaceAreaRatio"></a></p>
<h1 id="surfacearearatio"><a class="header" href="#surfacearearatio">SurfaceAreaRatio</a></h1>
<p>This tool calculates the ratio between the surface area and planar area of grid cells within digital elevation models (DEMs).
The tool uses the method of Jenness (2004) to estimate the surface area of a DEM grid cell based on the elevations
contained within the 3 x 3 neighbourhood surrounding each cell. The surface area ratio has a lower bound of 1.0 for
perfectly flat grid cells and is greater than 1.0 for other conditions. In particular, surface area ratio is a measure of
neighbourhood surface shape complexity (texture) and elevation variability (local slope).</p>
<p><em>Reference</em>:</p>
<p>Jenness, J. S. (2004). Calculating landscape surface area from digital elevation models. Wildlife Society
Bulletin, 32(3), 829-839.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.surface_area_ratio(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SurfaceAreaRatio -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/surface_area_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/01/2019</p>
<p><em>Last Modified</em>: 23/01/2019</p>
<p><a name="TangentialCurvature"></a></p>
<h1 id="tangentialcurvature"><a class="header" href="#tangentialcurvature">TangentialCurvature</a></h1>
<p>This tool calculates the tangential curvature, which is the curvature of an inclined plan perpendicular
to both the direction of flow and the surface (Gallant and Wilson, 2000). Curvature is a second
derivative of the topographic surface defined by a digital elevation model (DEM). The user must specify
the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tangential_curvature(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TangentialCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/tan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 01/03/2021</p>
<p><a name="TimeInDaylight"></a></p>
<h1 id="timeindaylight"><a class="header" href="#timeindaylight">TimeInDaylight</a></h1>
<p>This tool calculates the proportion of time a location is within daylight. That is, it calculates the
proportion of time, during a user-defined time frame, that a grid cell in an input digital elevation
model (<code>--dem</code>) is outside of an area of shadow cast by a local object. The input DEM should truly be
a digital surface model (DSM) that contains significant off-terrain objects. Such a model, for example,
could be created using the first-return points of a LiDAR data set, or using the <a href="./lidar_tools.html#lidardigitalsurfacemodel"><strong>LidarDigitalSurfaceModel</strong></a>
tool.</p>
<p>The tool operates by calculating a solar almanac, which estimates the sun's position for the location, in
latitude and longitude coordinate (<code>--lat</code>, <code>--long</code>), of the input DSM. The algorithm then calculates
horizon angle (see <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>) rasters from the DSM based on the user-specified azimuth fraction (<code>--az_fraction</code>).
For example, if an azimuth fraction of 15-degrees is specified, horizon angle rasters could be calculated for
the solar azimuths 0, 15, 30, 45... In reality, horizon angle rasters are only calculated for azimuths for which
the sun is above the horizon for some time during the tested time period. A horizon angle raster evaluates
the vertical angle between each grid cell in a DSM and a distant obstacle (e.g. a mountain ridge, building, tree, etc.) that
blocks the view along a specified direction. In calculating horizon angle, the user must specify the maximum search
distance (<code>--max_dist</code>) beyond which the query for higher, more distant objects will cease. This parameter strongly
impacts the performance of the tool, with larger values resulting in significantly longer run-times. Users are advised
to set the <code>--max_dist</code> based on the maximum shadow length expected in an area. For example, in a relatively flat
urban landscape, the tallest building will likely determine the longest shadow lengths. All grid cells for which the
calculated solar positions throughout the time frame are higher than the cell's horizon angle are deemed to be
illuminated during the time the sun is in the corresponding azimuth fraction.</p>
<p>By default, the tool calculates time-in-daylight for a time-frame spanning an entire year. That is, the solar almanac
is calculated for each hour, at 10-second intervals, and for each day of the year. Users may alternatively restrict the
time of year over which time-in-daylight is calculated by specifying a starting day (1-365; <code>--start_day</code>) and ending day
(1-365; <code>--end_day</code>). Similarly, by specifying start time (<code>--start_time</code>) and end time (<code>--end_time</code>) parameters,
the user is able to measure time-in-daylight for specific ranges of the day (e.g. for the morning or afternoon hours).
These time parameters must be specified in 24-hour time (HH:MM:SS), e.g. 15:30:00. <code>sunrise</code> and <code>sunset</code> are also
acceptable inputs for the start time and end time respectively. The timing of sunrise and sunset on each day in the
tested time-frame will be determined using the solar almanac.</p>
<p><img src="../img/TimeInDaylight.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./lidar_tools.html#lidardigitalsurfacemodel"><strong>LidarDigitalSurfaceModel</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--az_fraction</td><td>Azimuth fraction in degrees</td></tr>
<tr><td>--max_dist</td><td>Optional maximum search distance. Minimum value is 5 x cell size</td></tr>
<tr><td>--lat</td><td>Centre point latitude</td></tr>
<tr><td>--long</td><td>Centre point longitude</td></tr>
<tr><td>--utc_offset</td><td>UTC time offset, in hours (e.g. -04:00, +06:00)</td></tr>
<tr><td>--start_day</td><td>Start day of the year (1-365)</td></tr>
<tr><td>--end_day</td><td>End day of the year (1-365)</td></tr>
<tr><td>--start_time</td><td>Starting hour to track shadows (e.g. 5, 5:00, 05:00:00). Assumes 24-hour time: HH:MM:SS. 'sunrise' is also a valid time</td></tr>
<tr><td>--end_time</td><td>Starting hour to track shadows (e.g. 21, 21:00, 21:00:00). Assumes 24-hour time: HH:MM:SS. 'sunset' is also a valid time</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.time_in_daylight(
    dem, 
    output, 
    lat, 
    long, 
    az_fraction=10.0, 
    max_dist=100.0, 
    utc_offset=&quot;00:00&quot;, 
    start_day=1, 
    end_day=365, 
    start_time=&quot;00:00:00&quot;, 
    end_time=&quot;23:59:59&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TimeInDaylight -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --az_fraction=15.0 ^
--max_dist=100.0 --lat=43.545 --long= -80.248 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/time_in_daylight.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/07/2020</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="TopographicPositionAnimation"></a></p>
<h1 id="topographicpositionanimation"><a class="header" href="#topographicpositionanimation">TopographicPositionAnimation</a></h1>
<blockquote>
<p>Note this tool is part of a WhiteboxTools extension toolset. Please contact
<a href="https://www.whiteboxgeo.com">Whitebox Geospatial Inc.</a> for information about purchasing a license
activation key (<a href="https://www.whiteboxgeo.com">https://www.whiteboxgeo.com</a>).</p>
</blockquote>
<p>This tool creates an interactive animation that demonstrates the variation in deviation from mean
elevation (DEV, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>) as scale increases across a range for an input digital elevation
model (<code>--input</code>). DEV is calculated as the difference between the elevation of each grid cell and the
mean elevation of the centering local neighbourhood, normalized by standard deviation and is a measure
of local topographic position. DEV is useful for highlighting locally prominent (either elevated or
low-lying) locations within a landscape. Topographic position animations are extemely useful for
interpreting landscape geomorphic structure across a range of scales.</p>
<p>The set of scales for which DEV is measured (using varying filter sizes) is determined by the three
user-specified parameters, including <code>--min_scale</code>, <code>--num_steps</code>, and <code>--step_nonlinearity</code>. Experience
with DEV scale signatures has shown that it is highly variable at shorter scales and changes more
gradually at broader scales. Therefore, a nonlinear scale sampling interval is used by this tool to
ensure that the scale sampling density is higher for short scale ranges and coarser at longer tested
scales, such that:</p>
<blockquote>
<p><em>r<sub>i</sub></em> = <em>r<sub>L</sub></em> + (i - <em>r<sub>L</sub></em>)<sup><em>p</em></sup></p>
</blockquote>
<p>Where <em>ri</em> is the filter radius for step <em>i</em>, <em>r<sub>L</sub></em> is the lower range of filter sizes
(<code>--min_scale</code>), and <em>p</em> is the nonlinear scaling factor (<code>--step_nonlinearity</code>).</p>
<p>The tool can be run in one of two modes: using regular DEV calculations, or using DEV<sub>max</sub>
(<a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a>), a multiscale version of DEV that outputs the maximum absolute value of
DEV encountered across a range of tested scales. Use the <code>--dev_max</code> flag to run the tool in
DEV<sub>max</sub> mode.</p>
<p>The output (<code>--output</code>) of this tool is an HTML file, containing the interactive GIF animation. Users
are able to zoom and pan around the displayed DEV animation. The DEV images may be rendered in one of several
available palettes (<code>--palette</code>) suitable for visualization DEV. The output DEV/DEV<sub>max</sub>
animation will also be hillshaded to further enchance topographic interpretation. The user must also
specify the image height (<code>--height</code>) in the output file, the time delay (<code>--delay</code>, in milliseconds) used
in the GIF animation, and an optional label (<code>--label</code>), which will appear in the upper lefthand corner.
Note that the output is simply HTML, CSS, javascript code, and a GIF file, which can be readily embedded
in other documents.</p>
<p>Users should be aware that the outut GIF can be very large in size, depending on the size of the input
DEM file. To reduce the file size of the output, it may be desirable to coarsen the input DEM resolution using
image resampling (<a href="./image_processing_tools.html#resample"><strong>Resample</strong></a>).</p>
<p>The following is an example of what the output of this tool looks like. <strong>Click the image for
an interactive example.</strong></p>
<p><a href="https://jblindsay.github.io/ghrg/WhiteboxTools/samples/topo_pos/topo_position_animation.html"><img src="../img/TopographicPositionAnimation.png" alt="" /></a></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input</td><td>Name of the input digital elevation model (DEM) raster file</td></tr>
<tr><td>-p, --palette</td><td>Image palette; options are 'bl_yl_rd', 'bl_w_rd', 'purple', 'gn_yl', 'pi_y_g', and 'viridi'</td></tr>
<tr><td>-o, --output</td><td>Name of the output HTML file (*.html)</td></tr>
<tr><td>--min_scale</td><td>Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--num_steps</td><td>Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td>Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
<tr><td>--height</td><td>Image height, in pixels</td></tr>
<tr><td>--delay</td><td>GIF time delay in milliseconds</td></tr>
<tr><td>-l, --label</td><td>Label text (leave blank for none)</td></tr>
<tr><td>--dev_max</td><td>Do you want to use DEVmax instead of DEV for measuring local topographic position?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.topographic_position_animation(
    i, 
    output, 
    palette=&quot;bl_yl_rd&quot;, 
    min_scale=1, 
    num_steps=100, 
    step_nonlinearity=1.5, 
    height=600, 
    delay=250, 
    label=&quot;&quot;, 
    dev_max=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt; ./whitebox_tools -r=TopographicPositionAnimation -i=dem.tif ^
-p='bl_w_rd' -o=DEV_animation.html --min_scale=3 ^
--num_steps=100 --step_nonlinearity=1.2 --height=620 ^
--delay=200 --label='DEVmax for Catfish Watershed' --dev_max 
</code></pre>
<p>Source code is unavailable due to proprietary license.</p>
<p><em>Author</em>: Whitebox Geospatial Inc. (c)</p>
<p><em>Created</em>: 06/05/2021</p>
<p><em>Last Modified</em>: 06/05/2021</p>
<p><a name="TotalCurvature"></a></p>
<h1 id="totalcurvature"><a class="header" href="#totalcurvature">TotalCurvature</a></h1>
<p>This tool calculates the total curvature, which measures the curvature of the topographic surface rather
than the curvature of a line across the surface in some direction (Gallant and Wilson, 2000). Total
curvature can be positive or negative, with zero curvature indicating that the surface is either flat
or the convexity in one direction is balanced by the concavity in another direction, as would occur at
a saddle point. Curvature is a second derivative of the topographic surface defined by a digital elevation
model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--zfactor</td><td>Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.total_curvature(
    dem, 
    output, 
    zfactor=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TotalCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/total_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><em>Last Modified</em>: 03/09/2020</p>
<p><a name="Viewshed"></a></p>
<h1 id="viewshed"><a class="header" href="#viewshed">Viewshed</a></h1>
<p>This tool can be used to calculate the viewshed (i.e. the visible area) from a
location (i.e. viewing station) or group of locations based on the topography defined
by an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>), a viewing station input vector file (<code>--stations</code>), the output file name
(<code>--output</code>), and the viewing height (<code>--height</code>).
Viewing station locations are specified as points within an input shapefile. The output
image indicates the number of stations visible from each grid cell. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation from which the viewshed is calculated.</p>
<p><a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a> should be used when there are a relatively small number of target sites
for which visibility needs to be assessed. If you need to assess general landscape
visibility as a land-surface parameter, the <a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a> tool should be used
instead.</p>
<p>Viewshed analysis is a very
computationally intensive task. Depending on the size of the input DEM grid and the
number of viewing stations, this operation may take considerable time to complete. Also,
this implementation of the viewshed algorithm does not account for the curvature of the
Earth. This should be accounted for if viewsheds are being calculated over very
extensive areas.</p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem</td><td>Input raster DEM file</td></tr>
<tr><td>--stations</td><td>Input viewing station vector file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--height</td><td>Viewing station height, in z units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.viewshed(
    dem, 
    stations, 
    output, 
    height=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Viewshed -v --wd=&quot;/path/to/data/&quot; ^
--dem='dem.tif' --stations='stations.shp' -o=output.tif ^
--height=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/viewshed.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/01/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="VisibilityIndex"></a></p>
<h1 id="visibilityindex"><a class="header" href="#visibilityindex">VisibilityIndex</a></h1>
<p>This tool can be used to calculate a measure of landscape visibility based on the
topography of an input digital elevation model (DEM). The user must specify the name of
the input DEM (<code>--dem</code>), the output file name (<code>--output</code>), the viewing height (<code>--height</code>),
and a resolution factor (<code>--res_factor</code>).
Viewsheds are calcuated for a subset of grid cells in the DEM based on the resolution
factor. The visibility index value (0.0-1.0) indicates the proportion of tested stations
(determined by the resolution factor) that each cell is visible from. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation. Each tested grid cell's viewshed will be calculated in parallel. However, visibility
index is one of the most computationally intensive geomorphometric indices to calculate.
Depending on the size of the input DEM grid and the resolution factor, this operation may take
considerable time to complete. If the task is too long-running, it is advisable to raise the
resolution factor. A resolution factor of 2 will skip every second row and every second column
(effectively evaluating the viewsheds of a quarter of the DEM's grid cells). Increasing this
value decreases the number of calculated viewshed but will result in a lower accuracy estimate
of overall visibility. In addition to the high computational costs of this index, the tool
also requires substantial memory resources to operate. Each of these limitations should be
considered before running this tool on a particular data set. This tool is best to apply
on computer systems with high core-counts and plenty of memory.</p>
<p><img src="../img/VisiibilityIndex_fig1.png" alt="" /></p>
<p><em>See Also</em>:
<a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem</td><td>Input raster DEM file</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
<tr><td>--height</td><td>Viewing station height, in z units</td></tr>
<tr><td>--res_factor</td><td>The resolution factor determines the density of measured viewsheds</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.visibility_index(
    dem, 
    output, 
    height=2.0, 
    res_factor=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VisibilityIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=dem.tif -o=output.tif ^
--height=10.0 --res_factor=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/visibility_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/04/2018</p>
<p><em>Last Modified</em>: 12/10/2018</p>
<p><a name="WetnessIndex"></a></p>
<h1 id="wetnessindex"><a class="header" href="#wetnessindex">WetnessIndex</a></h1>
<p>This tool can be used to calculate the topographic wetness index, commonly used in the TOPMODEL rainfall-runoff framework.
The index describes the propensity for a site to be saturated to the surface given its contributing area and local slope
characteristics. It is calculated as:</p>
<blockquote>
<p>WI = Ln(As / tan(Slope))</p>
</blockquote>
<p>Where <code>As</code> is the specific catchment area (i.e. the upslope contributing area per unit contour length) estimated using one of
the available flow accumulation algorithms in the Hydrological Analysis toolbox. Notice that <code>As</code> must not be log-transformed
prior to being used; log-transformation of <code>As</code> is a common practice when visualizing the data. The slope image should be
measured in degrees and can be created from the base digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. Grid cells with a
slope of zero will be assigned <strong>NoData</strong> in the output image to compensate for the fact that division by zero is infinity.
These very flat sites likely coincide with the wettest parts of the landscape. The input images must have the same grid dimensions.</p>
<p>Grid cells possessing the NoData value in either of the input images are assigned NoData value in the output image. The output
raster is of the float data type and continuous data scale.</p>
<p>See Also
<a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#breachdepressionsleastcost"><strong>BreachDepressionsLeastCost</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca</td><td>Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope</td><td>Input raster slope file (in degrees)</td></tr>
<tr><td>-o, --output</td><td>Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.wetness_index(
    sca, 
    slope, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WetnessIndex -v --wd=&quot;/path/to/data/&quot; ^
--sca='flow_accum.tif' --slope='slope.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools/blob/master/whitebox-tools-app/src/tools/terrain_analysis/wetness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><em>Last Modified</em>: 21/01/2018</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../available_tools/data_tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../available_tools/gis_analysis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../available_tools/data_tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../available_tools/gis_analysis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
