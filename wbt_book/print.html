<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WhiteboxTools User Manual</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="preface.html">Preface</a></li><li><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="install.html"><strong aria-hidden="true">2.</strong> Setting Up WhiteboxTools</a></li><li><a href="using_whiteboxtools.html"><strong aria-hidden="true">3.</strong> Using WhiteboxTools</a></li><li><ol class="section"><li><a href="command_prompt.html"><strong aria-hidden="true">3.1.</strong> Command-line interface</a></li><li><a href="python_scripting/scripting.html"><strong aria-hidden="true">3.2.</strong> Interfacing with Python</a></li><li><ol class="section"><li><a href="python_scripting/using_whitebox_tools.html"><strong aria-hidden="true">3.2.1.</strong> Using whitebox_tools.py</a></li><li><a href="python_scripting/tool_output.html"><strong aria-hidden="true">3.2.2.</strong> Handling tool output</a></li><li><a href="python_scripting/additional_functions.html"><strong aria-hidden="true">3.2.3.</strong> Additional functions</a></li><li><a href="python_scripting/example.html"><strong aria-hidden="true">3.2.4.</strong> An example Python project</a></li></ol></li><li><a href="r_interface.html"><strong aria-hidden="true">3.3.</strong> Interfacing with R</a></li><li><a href="whitebox_tools_runner.html"><strong aria-hidden="true">3.4.</strong> WhiteboxTools Runner</a></li><li><a href="qgis_plugin.html"><strong aria-hidden="true">3.5.</strong> QGIS plugin</a></li><li><a href="arcgis_plugin.html"><strong aria-hidden="true">3.6.</strong> ArcGIS plugin</a></li></ol></li><li><a href="available_tools/index.html"><strong aria-hidden="true">4.</strong> Tools Reference</a></li><li><ol class="section"><li><a href="available_tools/data_tools.html"><strong aria-hidden="true">4.1.</strong> Data tools</a></li><li><a href="available_tools/geomorphometric_analysis.html"><strong aria-hidden="true">4.2.</strong> Geomorphometric analysis</a></li><li><a href="available_tools/gis_analysis.html"><strong aria-hidden="true">4.3.</strong> GIS analysis</a></li><li><ol class="section"><li><a href="available_tools/gis_analysis_distance_tools.html"><strong aria-hidden="true">4.3.1.</strong> Distance tools</a></li><li><a href="available_tools/gis_analysis_overlay_tools.html"><strong aria-hidden="true">4.3.2.</strong> Overlay tools</a></li><li><a href="available_tools/gis_analysis_patch_shape_tools.html"><strong aria-hidden="true">4.3.3.</strong> Patch shape tools</a></li></ol></li><li><a href="available_tools/hydrological_analysis.html"><strong aria-hidden="true">4.4.</strong> Hydrological analysis</a></li><li><a href="available_tools/image_processing_tools.html"><strong aria-hidden="true">4.5.</strong> Image processing tools</a></li><li><ol class="section"><li><a href="available_tools/image_processing_tools_filters.html"><strong aria-hidden="true">4.5.1.</strong> Filters</a></li><li><a href="available_tools/image_processing_tools_image_enhancement.html"><strong aria-hidden="true">4.5.2.</strong> Image enchancement</a></li></ol></li><li><a href="available_tools/lidar_tools.html"><strong aria-hidden="true">4.6.</strong> LiDAR tools</a></li><li><a href="available_tools/mathand_stats_tools.html"><strong aria-hidden="true">4.7.</strong> Mathematical and statistical analysis</a></li><li><a href="available_tools/stream_network_analysis.html"><strong aria-hidden="true">4.8.</strong> Stream network analysis</a></li></ol></li><li><a href="tutorials/index.html"><strong aria-hidden="true">5.</strong> Tutorials</a></li><li><ol class="section"><li><a href="tutorials/mosaic.html"><strong aria-hidden="true">5.1.</strong> How can I mosaic hundreds of rasters?</a></li><li><a href="tutorials/lidar.html"><strong aria-hidden="true">5.2.</strong> Processing LiDAR data</a></li></ol></li><li><a href="supported_formats.html"><strong aria-hidden="true">6.</strong> Supported Data Formats</a></li><li><a href="contributing.html"><strong aria-hidden="true">7.</strong> Contributing and Reporting Bugs</a></li><li><a href="limitations.html"><strong aria-hidden="true">8.</strong> Limitations</a></li><li><a href="license.html"><strong aria-hidden="true">9.</strong> License</a></li><li><a href="faq.html"><strong aria-hidden="true">10.</strong> Frequently Asked Questions</a></li><li><a href="tool_index.html"><strong aria-hidden="true">11.</strong> Tool Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">WhiteboxTools User Manual</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- <center>![](img/WhiteboxToolsLogoBlue.png)</center> -->
<center><img src="img/WhiteboxToolsLogoBlue.png" alt="drawing" height="120"/></center>
<!-- ![](img/WhiteboxToolsLogo_vert.svg) -->
<p>WhiteboxTools Version 0.16.0  <br />
Dr. John B. Lindsay © 2017-2019  <br />
<a href="https://jblindsay.github.io/ghrg/index.html">Geomorphometry and Hydrogeomatics Research Group</a>  <br />
University of Guelph  <br />
Guelph, Canada <br />
May 24, 2019
<br />
<br />
<br />
<br />
Sponsored by:</p>
<!-- ![](img/GHRGLogoSm.png =100x20) -->
<img src="img/GHRGLogoSm.png" alt="drawing" height="70"/><!-- ![](img/WhiteboxToolsLogo_vert.svg) -->
<!-- <img src="img/WhiteboxToolsLogo_vert.svg" alt="drawing" height="190"/> -->
<img src="img/WhiteboxToolsLogo_vert.svg" alt="drawing" height="150" align="right"/>
<a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p><strong><em>WhiteboxTools</em></strong> is an advanced geospatial data analysis platform created by Prof. <a href="https://jblindsay.github.io/ghrg/index.html">John Lindsay</a> at the <a href="http://www.uoguelph.ca">University of Guelph's</a> <em>Geomorphometry and Hydrogeomatics Research Group</em> (GHRG). The project began in January 2017 and quickly evolved in terms of its analytical capabilities. The WhiteboxTools <a href="https://jblindsay.github.io/ghrg/WhiteboxTools/index.html">homepage</a> contains more project information and the software <a href="https://jblindsay.github.io/ghrg/WhiteboxTools/download.html">download site</a>.</p>
<blockquote>
<p><strong>Project Highlights</strong></p>
<ul>
<li>Contains more than 395 tools for processing various types of geospatial data.</li>
<li>Many tools operate in parallel, taking full advantage of your multi-core processor.</li>
<li>Written in the safe and cross-platform systems programming language Rust and compiled to highly efficient native code.</li>
<li>Small stand-alone application with no external dependencies, making installation as easy as downloading the 8Mb zip file and decompressing it.</li>
<li>Simple yet powerful Python scripting interface that allows users to develop custom scripted workflows.</li>
<li><a href="python_scripting/scripting.html">Embed WhiteboxTools</a> functions into hetergenous scripting environments along with ArcPy, GDAL, and other geoprocessing libraries.</li>
<li>Serves as an analytical back-end for other GIS and remote sensing software (e.g. the <a href="./qgis_plugin.html">QGIS Whitebox for Processing</a> plugin).</li>
<li>Permissive <a href="./license.html">MIT open-source license</a> allows for ready integration with other software.</li>
<li>Transparent software philosopy allows for easy source code inspection and rapid innovation and development.</li>
</ul>
</blockquote>
<a class="header" href="#what-can-whiteboxtools-do" id="what-can-whiteboxtools-do"><h2>What can WhiteboxTools do?</h2></a>
<p><em>WhiteboxTools</em> can be used to perform common geographical information systems (GIS) analysis operations, such as cost-distance analysis, distance buffering, and raster reclassification. Remote sensing and image processing tasks include image enhancement (e.g. panchromatic sharpening, contrast adjustments), image mosaicking, numerous filtering operations, simple classification (k-means clustering), and common image transformations. <em>WhiteboxTools</em> also contains advanced tooling for spatial hydrological analysis (e.g. flow-accumulation, watershed delineation, stream network analysis, sink removal), geomorphometric analysis (e.g. common terrain indices such as slope, curvatures, wetness index, hillshading; hypsometric analysis; multi-scale topographic position analysis), and LiDAR data processing. LiDAR point clouds can be interrogated (LidarInfo, LidarHistogram), segmented, tiled and joined, analyzed for outliers, interpolated to rasters (DEMs, intensity images), and ground-points can be classified or filtered.</p>
<p><em>WhiteboxTools</em> is not a cartographic or spatial data visualization package; instead it is meant to serve as an analytical backend for other data visualization software, mainly GIS (e.g. Whitebox GAT and <a href="./qgis_plugin.html">QGIS</a>).</p>
<a class="header" href="#whiteboxtools-vs-whitebox-geospatial-analysis-tools-gat" id="whiteboxtools-vs-whitebox-geospatial-analysis-tools-gat"><h2>WhiteboxTools vs. Whitebox Geospatial Analysis Tools (GAT)</h2></a>
<p>Although <em>WhiteboxTools</em> was first developed with to serve as a source of plugin tools for the <a href="https://jblindsay.github.io/ghrg/Whitebox/"><em>Whitebox Geospatial Analysis Tools</em></a> (GAT) open-source GIS project, the tools contained in the library are stand-alone and can run outside of the larger <em>Whitebox GAT</em> project. See <a href="#interacting-with-whiteboxtools-from-the-command-prompt">Interacting With <em>WhiteboxTools</em> From the Command Prompt</a> for further details. There have been a large number of requests to call <em>Whitebox GAT</em> tools and functionality from outside of the <em>Whitebox GAT</em> user-interface (e.g. from Python automation scripts). <em>WhiteboxTools</em> is intended to meet these usage requirements. For example, a <a href="https://plugins.bruy.me/plugins/plugins.xml"><em>WhiteboxTools</em> plug-in for QGIS</a> is available.</p>
<blockquote>
<p>In this manual, <strong><em>WhiteboxTools</em></strong> refers to the standalone geospatial analysis library, a collection of tools contained within a compiled binary executable command-line program and the associated Python scripts that are distributed alongside the binary file (e.g. <em>whitebox_tools.py</em> and <em>wb_runner.py</em>). <strong><em>Whitebox Geospatial Analysis Tools</em></strong> and <strong><em>Whitebox GAT</em></strong> refer to the GIS software, which includes a user-interface (front-end), point-and-click tool interfaces, and cartographic data visualization capabilities. Importantly, <strong><em>WhiteboxTools</em></strong> and <strong><em>Whitebox GAT</em></strong> are related but separate projects.</p>
</blockquote>
<a class="header" href="#why-is-it-named-whiteboxtools" id="why-is-it-named-whiteboxtools"><h2>Why is it named <em>WhiteboxTools</em>?</h2></a>
<p>The project name <em>WhiteboxTools</em> clearly takes it inspiration from the related project Whitebox GAT. However, the name <em>Whitebox</em> is intended to convey opposition to a 'black box' system, one for which only the inputs and outputs may be observed and the internal workings may not be scrutinized. <em>WhiteboxTools</em> is inspired by the concept of <em>open-access software</em>, the tenants of which were described by Lindsay (2014)<sup class="footnote-reference"><a href="#1">1</a></sup>. Open-<em>access</em> software can be viewed as a complementary extension to the traditional open-<em>source</em> software (OSS) model of development. The concept of open access has been previously defined in the context of publishing scholarly literature in a way that removes financial, legal, and technical access barriers to knowledge transfer. Lindsay (2014) argued that the stated goals of reducing barriers associated with knowledge transfer applies equally to the software used in research. Open-access software is distinct from other OSS in that it has an explicitly stated design goal of reducing barriers to the transfer of knowledge to the user community. Direct insight into the workings of algorithm design and implementation allows for educational opportunities and increases the potential for rapid innovation, experimentation with algorithms, and community-directed development. This is particularly important in geomatics because many geospatial algorithms are complex and are strongly affected by implementation details. Also, there are often multiple competing algorithms for accomplishing the same task and the choice of one method over another can greatly impact the outcome of a workflow.</p>
<p>All OSS allow users the opportunity to download the source code and inspect the software’s internal workings. However, traditional OSS often does not lend itself to end-user source code inspection. Open-access software, by comparison, is <em>designed from the project's inception in a way that reduces the barriers that typically discourage end-users from examining the algorithm and implementation details associated with specific software artifacts</em>. WhiteboxTools attempts to address some of the barriers to knowledge transfer by allowing users to view the source code associated with each tool directly (e.g. <code>--viewcode=ExtendVectorLines</code>). This functionality removes the need to download separate, and often large, project source code files and eliminates the requisite familiarity with the project to identify the code sections related to the operation of the tool of interest. The <code>viewcode</code> flag is the embodiment of a design philosophy that is intended to empower the user community. Each tool included in the library has been written in a way to isolate the major functionality within a single file, thereby easing the task of interpreting the code (traditional coding style would split complex code among numerous files). This design goal is also why the developers have chosen to exclude external libraries commonly found in other similarly software (e.g. GDAL), thereby simplifying the installation process and code interpretation. This approach has the potential to encourage further community involvement and experimentation with geospatial analysis techniques.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lindsay, JB. 2014. <a href="https://www.researchgate.net/publication/271205138_The_Whitebox_Geospatial_Analysis_Tools_project_and_open-access_GIS">The Whitebox Geospatial Analysis Tools project and open-access GIS</a>. Proceedings of the GIS Research UK 22nd Annual Conference, The University of Glasgow, 16-18 April, DOI: 10.13140/RG.2.1.1010.8962.</p>
</div>
<a class="header" href="#setting-up-whiteboxtool" id="setting-up-whiteboxtool"><h1>Setting Up <em>WhiteboxTool</em></h1></a>
<p><em>WhiteboxTools</em> is a stand-alone executable command-line program with no actual installation. Download the appropriate file for your system from the <a href="https://github.com/jblindsay/whitebox-tools/releases/latest">GitHub site</a> or from the <a href="https://jblindsay.github.io/ghrg/WhiteboxTools/download.html">Geomorphometry and Hydrogeomatics Research Group homepage</a> and decompress the folder. Pre-compiled binaries can be downloaded for MS Windows, MacOS, and Linux operating systems. Depending on your operating system, you may need to grant the <em>WhiteboxTools</em> executable file execution privileges before running it.</p>
<p>If you intend to use WhiteboxTools from the <a href="command_prompt.html">command prompt</a> (i.e. a terminal application), you may wish to add the directory containing the WhiteboxTools executable file to your system <strong>PATH</strong> variable. Doing so will greatly simplify usage of the library from your terminal. Instructions for doing this depend on your operating system and can be found on the Internet.</p>
<p>If you intend to use the <a href="python_scripting/scripting.html">Python programming interface</a> for <em>WhiteboxTools</em> you will need to have <a href="https://www.python.org/downloads/">Python 3</a> installed. Please note that the Python interface will not work correctly with Python 2. If your system has Python 2 as the default Python version, it is possible to install Python 3 alongside your current version. You may need to use the <code>python3</code> command in place of the usual <code>python</code> if this is the case.</p>
<a class="header" href="#building-whiteboxtools-from-source-code" id="building-whiteboxtools-from-source-code"><h2>Building WhiteboxTools From Source Code</h2></a>
<p>Most users rely on the pre-compiled versions of WhiteboxTools and will never need to compile the software from its source code. There are two circumstances under which you may find that you need to build your own binary executable: 1) if you need a binary compiled for a platform other than the project-supported operating systems, and 2) if you require a bleeding-edge feature or bug-fix only available in the development branch. It is likely that <em>WhiteboxTools</em> will work on a wider variety of operating systems and architectures than those of the distributed pre-compiled binaries. If you do not find your operating system/architecture in the list of available <em>WhiteboxTool</em> binaries, then compilation from source code will be necessary. WhiteboxTools can be compiled from the source code with the following steps:</p>
<ol>
<li>Install the Rust compiler; <strong>Rustup</strong> is recommended for this purpose. Further instruction can be found at this <a href="https://www.rust-lang.org/en-US/install.html">link</a>.</li>
</ol>
<p>The proper way to install <strong>Rustup</strong> depends on your operating system and instructions can be found on the <a href="https://www.rust-lang.org/en-US/install.html">Rust install page</a>. For Unix-type OSs (including linux and MacOS), the recommended install command is:</p>
<p><code>curl https://sh.rustup.rs -sSf | sh</code></p>
<p>After installing <strong>Rustup</strong>, install the Rust compiler and tools (including the <strong>Cargo</strong> package manager and build tool):</p>
<p><code>rustup install stable</code></p>
<p>Note, you may need to install a linker in addition to the Rust compiler (e.g. MS Visual C++ 2015 Build Tools on MS Windows; XCode on MacOS).</p>
<ol start="2">
<li>
<p>Download the <em>WhiteboxTools</em> <a href="https://github.com/jblindsay/whitebox-tools">source code</a>. To download the code, click the green Clone or download button on the GitHub repository site.</p>
</li>
<li>
<p>Decompress the zipped download file.</p>
</li>
<li>
<p>Open a terminal (command prompt) window and change the working directory to the whitebox_tools sub-folder, which is contained within the decompressed downloaded Whitebox GAT folder:</p>
</li>
</ol>
<pre><code>&gt;&gt; cd /path/to/folder/whitebox_tools/
</code></pre>
<ol start="5">
<li>Finally, use the rust package manager <strong>Cargo</strong>, which will be installed alongside Rust, to compile the executable:</li>
</ol>
<pre><code>&gt;&gt; cargo build --release
</code></pre>
<p>Depending on your system, the compilation may take several minutes. When completed, the compiled binary executable file will be contained within the <em>whitebox_tools/target/release/ folder</em>. Type <em>./whitebox_tools --help</em> at the command prompt (after changing the directory to the containing folder) for information on how to run the executable from the terminal.</p>
<blockquote>
<p>The '&gt;&gt;' is shorthand used in this document to denote the command prompt and is not intended to be typed.</p>
</blockquote>
<p>Be sure to follow the instructions for installing Rust carefully. In particular, if you are installing on Microsoft Windows, you must have a linker installed prior to installing the Rust compiler (<em>rustc</em>). The Rust webpage recommends either the <strong>MS Visual C++ 2015 Build Tools</strong> or the GNU equivalent and offers details for each installation approach.</p>
<a class="header" href="#using-whiteboxtools" id="using-whiteboxtools"><h1>Using <em>WhiteboxTools</em></h1></a>
<p>Users interact with the <em>WhiteboxTools</em> platform either from a <a href="./command_prompt.html">command prompt</a> (i.e. terminal), through the <a href="python_scripting/scripting.html">Python</a> or <a href="./r_interface.html"><em>R</em> language</a> interfaces, or from one of the available <a href="./qgis_plugin.html">graphical user interfaces (GUI)</a> applications.</p>
<a class="header" href="#command-line-interface" id="command-line-interface"><h1>Command-Line Interface</h1></a>
<p><em>WhiteboxTools</em> is a command-line program and can be run either by calling it from a terminal application with appropriate commands and arguments, or, more conveniently, by calling it from a <a href="./python_scripting/scripting.html">script</a>. The following commands are recognized by the <em>WhiteboxTools</em> library:</p>
<table><thead><tr><th><strong>Command</strong>        </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--cd, --wd       </td><td>  Changes the working directory; used in conjunction with --run flag.</td></tr>
<tr><td>-h, --help        </td><td>  Prints help information.</td></tr>
<tr><td>-l, --license     </td><td>  Prints the whitebox-tools license.</td></tr>
<tr><td>--listtools       </td><td>  Lists all available tools, with tool descriptions. Keywords may also be used, --listtools slope.</td></tr>
<tr><td>-r, --run         </td><td>  Runs a tool; used in conjunction with --cd flag; -r=&quot;LidarInfo&quot;.</td></tr>
<tr><td>--toolbox         </td><td>  Prints the toolbox associated with a tool; --toolbox=Slope.</td></tr>
<tr><td>--toolhelp        </td><td>  Prints the help associated with a tool; --toolhelp=&quot;LidarInfo&quot;.</td></tr>
<tr><td>--toolparameters  </td><td>  Prints the parameters (in json form) for a specific tool; e.g. --toolparameters=&quot;FeaturePreservingDenoise&quot;.</td></tr>
<tr><td>-v                 </td><td>  Verbose mode. Without this flag, tool outputs will not be printed.</td></tr>
<tr><td>--viewcode        </td><td>  Opens the source code of a tool in a web browser; --viewcode=&quot;LidarInfo&quot;.</td></tr>
<tr><td>--version         </td><td>  Prints the version information.</td></tr>
</tbody></table>
<p>Generally, the Unix convention is that single-letter arguments (options) use a single hyphen (e.g. -h) while word-arguments (longer, more descriptive argument names) use double hyphens (e.g. --help). The same rule is used for passing arguments to tools as well. Use the <em>--toolhelp</em> argument to print information about a specific tool (e.g. --toolhelp=Clump).</p>
<blockquote>
<p>Tool names can be specified either using the snake_case or CamelCase convention (e.g. <em>lidar_info</em> or <em>LidarInfo</em>).</p>
</blockquote>
<p>The following is an example of calling the <em>WhiteboxTools</em> binary executable file directly from the command prompt:</p>
<pre><code>&gt;&gt;./whitebox_tools --wd='/Users/johnlindsay/Documents/data/' ^
--run=DevFromMeanElev --input='DEM clipped.tif' ^
--output='DEV raster.tif' -v
</code></pre>
<p>Notice the quotation marks (single or double) used around directories and filenames, and string tool arguments in general. After the <em>--run</em> flag, used to call a tool, a series of tool-specific
flags are provided to indicate the values of various input parameters. Note
that the order of these flags is unimportant. Use the '-v' flag (run in verbose mode) to force the tool to print output to the command prompt. Please note that the whitebox_tools executable file must have permission to be executed; on some systems, this may require setting special permissions. Also, the above example uses the forward slash character (/), the directory path separator used on unix based systems. On Windows, users should use the back slash character (\) instead. Also, it is sometimes necessary to break (^) commands across multiple lines, as above, in order to better fit with the documents format. Actual command prompts (&gt;&gt;) should be contained to a single line.</p>
<a class="header" href="#interfacing-with-python" id="interfacing-with-python"><h1>Interfacing With Python</h1></a>
<blockquote>
<p><strong>Important note</strong>: all of the following material assumes the user system is configured with Python 3. The code snippets below are not guaranteed to work with older versions of the language.</p>
</blockquote>
<p>By combining the <em>WhiteboxTools</em> library with a high-level scripting language, such as Python, users are capable of creating powerful stand-alone geospatial applications and workflow automation scripts. In fact, <em>WhiteboxTools</em> functionality can be called from many different programming languages. However, given the prevalent use of the Python language in the geospatial fields, the library is distributed with several resources specifically aimed at Python scripting. This section focuses on how Python programming can be used to interact with the <em>WhiteboxTools</em> library.</p>
<blockquote>
<p>If you use the Python package manager PIP, you may install <em>WhiteboxTools</em> at the command prompt with <code>pip install whitebox</code>. The <a href="https://github.com/giswqs/whitebox">PIP package</a> is maintained by Prof. Qiusheng Wu. There is also an <a href="https://anaconda.org/conda-forge/whitebox_tools">Anaconda package</a>, which can be installed with <code>conda install -c conda-forge whitebox_tools</code>, although it is unclear if this package is regularly updated to reflect the latest versions of <em>WhiteboxTools</em>.</p>
</blockquote>
<a class="header" href="#using-the-whitebox_toolspy-script" id="using-the-whitebox_toolspy-script"><h1>Using the <em>whitebox_tools.py</em> script</h1></a>
<p>Interacting with <em>WhiteboxTools</em> from Python scripts is easy. To begin, each script must start by importing the <em>WhiteboxTools</em> class, contained with the <em>whitebox_tools.py</em> script; a new <code>WhiteboxTools</code> object can then be created:</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
</code></pre>
<p>Depending on the relative location of the <em>WhiteboxTools</em> directory and the script file that you are importing to, the import statement may need to be altered slightly. In the above script, it is assumed that the folder containing the <em>WhiteboxTools</em> files (including the <em>whitebox_tools</em> Python script) is named <code>WBT</code> (Line 1) and that the calling script that is importing WhiteboxTools is located in the parent directory of <code>WBT</code>. See <a href="#an-example-whiteboxtools-python-project">An Example WhiteboxTools Python Project</a> for more details on project set-up. The use of <code>wbt</code> to designate the WhiteboxTools object variable in the above script (Line 3) is just the convention used in this manual and other project resources. In fact, any variable name can be used for this purpose.</p>
<p>The <code>WhiteboxTools</code> class expects to find the <em>WhiteboxTools</em> executable file (<em>whitebox_tools.exe</em> on Windows and <em>whitebox_tools</em> on other platforms) within the same directory (<code>WBT</code>) as the <em>whitebox_tools.py</em> script. If the binary file is located in a separate directory, you will need to set the executable directory as follows:</p>
<pre><code class="language-python">wbt.set_whitebox_dir('/local/path/to/whitebox/binary/')
# Or alternatively...
wbt.exe_path = '/local/path/to/whitebox/binary/'
</code></pre>
<p>Individual tools can be called using the convenience methods provided in the <code>WhiteboxTools</code> class:</p>
<pre><code class="language-python"># This line performs a 5 x 5 mean filter on 'inFile.tif':
wbt.mean_filter('/file/path/inFile.tif', '/file/path/outFile.tif', 5, 5)
</code></pre>
<p>Each tool has a cooresponding convenience method. The listing of tools in this manual includes information about each tool's Python convienience method, including default parameter values. Parameters with default values may be optionally left off of function calls. In addition to the convenience methods, tools can be called using the <code>run_tool()</code> method, specifying the tool name and a list of tool arguments.</p>
<pre><code class="language-python">source = &quot;source.tif&quot;
cost = &quot;cost.tif&quot;
out_accum = &quot;accum.tif&quot;
out_backlink = &quot;backlink.tif&quot;
args = []
args.append(&quot;--source='{}'&quot;.format(source))
args.append(&quot;--cost='{}'&quot;.format(cost))
args.append(&quot;--out_accum='{}'&quot;.format(out_accum))
args.append(&quot;--out_backlink='{}'&quot;.format(out_backlink))
self.run_tool('cost_distance', args)
</code></pre>
<p>Each of the tool-specific convenience methods collect their parameters into a properly formated list and then ultimately call the <code>run_tools()</code> method. Notice that while internally <em>whitebox_tools.exe</em> uses CamelCase (e.g. MeanFilter) to denote tool names, the Python interface of <em>whitebox_tools.py</em> uses snake_case (e.g. mean_filter), according to Python style conventions. The only exceptions are tools with names that clash with Python keywords (e.g. <code>And()</code>, <code>Not()</code>, and <code>Or()</code>).</p>
<p>The return value can be used to check for errors during operation:</p>
<pre><code class="language-python">if wbt.ruggedness_index('/path/DEM.tif', '/path/ruggedness.tif') != 0:
    # Non-zero returns indicate an error.
    print('ERROR running ruggedness_index')
</code></pre>
<p>If your data files tend to be burried deeply in layers of sub-directories, specifying complete file names as input parameters can be tedius. In this case, the best option is setting the working directory before calling tools:</p>
<pre><code class="language-python">from whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot; # Sets the Whitebox working directory

# Because the working directory has been set, file arguments can be
# specified simply using file names, without paths.
wbt.d_inf_flow_accumulation(&quot;DEM.tif&quot;, &quot;output.tif&quot;, log=True)
</code></pre>
<p>An advanced text editor, such as VS Code or Atom, can provide hints and autocompletion for available tool convenience methods and their parameters, including default values (Figure 1).</p>
<p><img src="../img/wbt_auotcomplete.png" alt="Autocompletion in Atom text editor makes calling WhiteboxTools functions easier." /></p>
<p>Sometimes it can be useful to print a complete list of available tools:</p>
<pre><code class="language-python">print(wbt.list_tools()) # List all tools in WhiteboxTools
</code></pre>
<p>The <code>list_tools()</code> method also takes an optional keywords list to search for tools:</p>
<pre><code class="language-python"># Lists tools with 'lidar' or 'LAS' in tool name or description.
print(wbt.list_tools(['lidar', 'LAS']))
</code></pre>
<p>To retrieve more detailed information for a specific tool, use the <code>tool_help()</code> method:</p>
<pre><code class="language-python">print(wbt.tool_help(&quot;elev_percentile&quot;))
</code></pre>
<p><code>tool_help()</code> prints tool details including a description, tool parameters (and their flags), and example usage at the command line prompt. The above statement prints this report:</p>
<pre><code>
ElevPercentile
Description:
Calculates the elevation percentile raster from a DEM.
Toolbox: Geomorphometric Analysis
Parameters:

Flag               Description
-----------------  -----------
-i, --input, --dem Input raster DEM file.
-o, --output       Output raster file.
--filterx          Size of the filter kernel in the x-direction.
--filtery          Size of the filter kernel in the y-direction.
--sig_digits       Number of significant digits.

Example usage:
&gt;&gt;./whitebox_tools -r=ElevPercentile -v --wd=&quot;/path/to/data/&quot; --dem=DEM.tif
&gt;&gt;-o=output.tif --filterx=25


</code></pre>
<blockquote>
<p><strong>A note on default parameter values</strong></p>
<p>Each tool contains one or more parameters with default values. These will always be listed after any input parameters that do not have default values. You do not need to specify a parameter with a default value if you accept the default. That is, unless you intend to specify an input value different from the default, you may leave these parameters off of the function call. However, be mindful of the fact that Python assigns values to parameters based on order, unless parameter names are specified.</p>
<p>Consider the Hillshade tool as an example. The User Manual gives the following function definition for the tool:</p>
<pre><code class="language-{.python}">hillshade(
dem,
output,
azimuth=315.0,
altitude=30.0,
zfactor=1.0,
callback=default_callback)
</code></pre>
<p>The <code>dem</code> and <code>output</code> parameters do not have default values and must be specified every time you call this function. Each of the remaining parameters have default values and can, optionally, be left off of calls to the <code>hillshade</code> function. As an example, say I want to accept the default values for all the parameters except <code>altitude</code>. I would then need to use the named-parameter form of the function call:</p>
<pre><code class="language-python">wbt.hillshade(
&quot;DEM.tif&quot;,
&quot;hillshade.tif&quot;,
altitude=20.0)
</code></pre>
<p>If I hadn't specified the parameter name for <code>altitude</code>, Python would have assumed that the value 20.0 should be assigned to the third parameter, <code>azimuth</code>.</p>
</blockquote>
<a class="header" href="#handling-tool-output" id="handling-tool-output"><h1>Handling tool output</h1></a>
<p>Tools will frequently print text to the standard output during their execution, including warnings, progress updates and other notifications. Sometimes, when users run many tools in complex workflows and in batch mode, these output messages can be undesirable. Most tools will have their outputs suppressed by setting the <em>verbose</em> mode to <em>False</em> as follows:</p>
<pre><code class="language-python">wbt.set_verbose_mode(False)
# Or, alternatively...
wbt.verbose = False
</code></pre>
<p>Alternatively, it may be helpful to capture the text output of a tool for custom processing. This is achieved by specifying a custom <em>callback</em> function to the tool's convenience function:</p>
<pre><code class="language-python"># This callback function suppresses printing progress updates,
# which always use the '%' character. The callback function
# approach is flexible and allows for any level of complex
# interaction with tool outputs.
def my_callback(value):
    if not &quot;%&quot; in value:
        print(value)

wbt.slope('DEM.tif', 'slope_raster.tif', callback=my_callback)
</code></pre>
<p>Every convienience function takes an optional callback as the last parameter. The default callback simply prints tool outputs to the standard output without any additional processing. The default callback itself can be overridden, instead of having to set callbacks in convienience functions individually:</p>
<pre><code class="language-python">wbt.default_callback = my_callback
</code></pre>
<p>Callback functions can serve as a means of cancelling operations:</p>
<pre><code class="language-python">def my_callback(value):
    if user_selected_cancel_btn: # Assumes a 'Cancel' button on a GUI
        print('Cancelling operation...')
        wbt.cancel_op = True
    else:
        print(value)

wbt.breach_depressions('DEM.tif', 'DEM_breached.tif', callback=my_callback)
</code></pre>
<a class="header" href="#additional-functions-in-whitebox_toolspy" id="additional-functions-in-whitebox_toolspy"><h1>Additional functions in <em>whitebox_tools.py</em></h1></a>
<p>The <em>whitebox_tools.py</em> script provides several other functions for interacting with the <em>WhiteboxTools</em> library, including:</p>
<pre><code class="language-python"># Print the WhiteboxTools help...a listing of available commands
print(wbt.help())

# Print the WhiteboxTools license
print(wbt.license())

# Print the WhiteboxTools version
print(&quot;Version information: {}&quot;.format(wbt.version()))

# Get the toolbox associated with a tool
tb = wbt.toolbox('lidar_info')

# Retrieve a JSON object of a tool's parameters.
tp = wbt.tool_parameters('raster_histogram')

# Opens a browser and navigates to a tool's source code in the
# WhiteboxTools GitHub repository
wbt.view_code('watershed')
</code></pre>
<p>For a working example of how to call functions and run tools from Python, see the <em>whitebox_example.py</em> Python script, which is distributed with the <em>WhiteboxTools</em> library.</p>
<blockquote>
<p>Additional resources for using <em>WhiteboxTools</em>' Python interface can be found on the <a href="https://jblindsay.github.io/ghrg/WhiteboxTools/tutorials.html">Tutorials</a> site of the <em>WhiteboxTools</em> home page. This site contains in-depth tutorials on topics such as, '<em>Interpolating LiDAR data</em>'.</p>
</blockquote>
<a class="header" href="#an-example-python-project" id="an-example-python-project"><h1>An Example Python Project</h1></a>
<p>In this section, we will create a Python project that utilizes the <em>WhiteboxTools</em> library to interpolate a LiDAR point-cloud, to process the resulting digital elevation model (DEM) to make it suitable for hydrological applications, and to perform a simple flow-accumulation operation. I suggest using an advanced coding text editor, such as <em>Visual Studio Code</em> or <em>Atom</em>, for this tutorial, but Python code can be written using any basic text editor.</p>
<p>Begin by creating a dedicated project directory called <em>FlowAccumExample</em> and copy <em>WhiteboxTools</em> binary file (i.e. the compressed file downloaded from the <em>Geomorphometry &amp; Hydrogeomatics Research Group</em> website) into this folder. Using the decompression software on your computer, decompress (i.e. an operation sometimes called <em>unzipping</em>) the file into the newly created <em>FlowAccumExample</em> directory. You will find the compressed file contains a folder with contents similar to the following:</p>
<!-- ![Folder contents of *WhiteboxTools* compressed download file](../img/wbt_directory.png) -->
<img src="../img/wbt_directory.png" alt="Folder contents of *WhiteboxTools* compressed download file" width="450" align="center"/>
<p>The folder contains a number of files, including the <em>WhiteboxTools</em> executable file, the <em>whitebox_tools.py</em> python script, the WhiteboxTools Runner (<em>wb_runner.py</em>; see below), and this user manual. It is likely that the folder has a name that reflects the operating system and architecture that the binary file was compiled for (e.g. WhiteboxTools_darwin_amd64). Rename this directory to <em>WBT</em>. Also note, depending on your decompression software, it may be the case that the contents of the <em>WBT</em> folder itself contains a sub-directory that actually holds these files. If this is the case, be sure to move the contents of the sub-directory into the <em>WBT</em> parent directory.</p>
<p>Using your text editor, create a new Python script file, called <em>FlowAccumulation.py</em> within the <em>FlowAccumExample</em> directory. We will begin by importing the <em>WhiteboxTools</em> class from the <em>whitebox_tools.py</em> script contained within the <em>WBT</em> sub-directory. Unfortunately, Python's module system is only able to import classes and function definitions declared in external Python scripts <em>if these external files are contained somewhere on the Python path or in the directory containing the script file into which you are importing</em>. This is important because based on the project structure that we have established, the <em>whitebox_tools.py</em> script is actually contained within a sub-directory of the <em>FlowAccumExample</em> directory and is therefore not directly accessible, unless you have previously installed the script on the Python path. Another, perhaps easier solution to this problem is to create a file named <em>__init__.py</em> (those are two leading and trailing underscore characters) within the <em>FlowAccumExample</em> directory. The presence of this empty file will make Python treat the <em>WBT</em> directory as containing packages, in this case, the <em>whitebox_tools</em> package. For more information, see the Python documentation on <a href="https://docs.python.org/3/tutorial/modules.html#packages">modules and packages</a>.</p>
<p>At this stage, you should have a project directory structure like the following:</p>
<!-- ![Example project set-up](../img/example_project_dir.png) -->
<img src="../img/example_project_dir.png" alt="Example project set-up" width="580" align="center"/>
<p>Many operating systems will disallow the execution of files that are downloaded directly from the Internet. As such, it is possible that you will need to explicitly give the <em>whitebox_tools.exe</em> permission to execute on your computer (Note: here we are referring to the compiled <em>WhiteboxTools</em> binary file and not the similarly named Python script <em>whitebox_tools.py</em> also contained in the folder). The procedure for doing this depends on your specific operating system. On MacOS, for example, this is usually achieved using the 'Security &amp; Privacy' tab under 'System Preferences'. To test whether <em>whitebox_tools.exe</em> has permission to run on your system, double-click the file. If the file is configured to execute, a command terminal will automatically open and the <em>WhiteboxTools</em> help documentation and a listing of the available tools will be printed. If this does not occur, you likely need to give the file permission to execute.</p>
<p>Using your text editor, you may now add the following lines to the <em>FlowAccumulation.py</em> file.</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
</code></pre>
<p>In the import statement, <code>WBT</code> is a reference to the package folder containing the <em>WhiteboxTools</em> files; <code>whitebox_tools</code> is a reference to the <em>whitebox_tools.py</em> script contained with this package folder; and <code>WhiteboxTools</code> is a reference to the <em>WhiteboxTools</em> class contained within this script file. Please note that if you named your directory containing the <em>WhiteboxTools</em> files something other than <em>WBT</em>, you would need to alter the import statement accordingly.</p>
<p>Visit the <a href="https://jblindsay.github.io/ghrg/software.shtml#WhiteboxTools"><em>Geomorphometry and Hydrogeomatics Research Group</em></a> website and download the St. Elis Mountains and Gulf of Alaska sample data set (<em>StElisAk.las</em>) from the <em>WhiteboxTools</em> section of the site. This file contains a LiDAR point cloud that has been previously filtered to remove points associated with non-ground returns, mainly trees (Figure 4). Create a sub-directory within the project folder called 'data' and copy <em>StElisAk.las</em> into the folder.</p>
<p><img src="../img/StElis_point_cloud.png" alt="St. Elis Mountains LiDAR point cloud, visualized using the plas.io software" /></p>
<p>Now we can complete our flow accumulation analysis with the following code:</p>
<pre><code class="language-python">import os
from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()

# Set the working directory, i.e. the folder containing the data,
# to the 'data' sub-directory.
wbt.work_dir = os.path.dirname(os.path.abspath(__file__)) + &quot;/data/&quot;

# When you're running mulitple tools, the outputs can be a tad
# chatty. In this case, you may want to suppress the output by
# setting the verbose mode to False.
# wbt.verbose = False

# Interpolate the LiDAR data using an inverse-distance weighting
# (IDW) scheme.
print(&quot;Interpolating DEM...&quot;)
wbt.lidar_idw_interpolation(
i=&quot;StElisAk.las&quot;,
output=&quot;raw_dem.tif&quot;,
parameter=&quot;elevation&quot;,
returns=&quot;last&quot;,
resolution=1.0,
weight=1.0,
radius=2.5
)

# The resulting DEM will contain NoData gaps. We need to fill
# these in by interpolating across the gap.
print(&quot;Filling missing data...&quot;)
wbt.fill_missing_data(
i=&quot;raw_dem.tif&quot;,
output=&quot;dem_nodata_filled.tif&quot;,
filter=11
)

# This DEM will contain grid cells that have no lower neighbours.
# This condition is unsuited for flow-path modelling applications
# because these operations assume that each interior cell in the
# DEM has at least one downslope neighour. We'll use an operation
# called depression breaching to 'fix' the elevations within the
# DEM to enforce continuous flow.
print(&quot;Performing flow enforcement...&quot;)
wbt.breach_depressions(
dem=&quot;dem_nodata_filled.tif&quot;,
output=&quot;dem_hydro_enforced.tif&quot;
)

# Lastly, perform the flow accumulation operation using the
# D-infinity flow algorithm.
print(&quot;Performing flow accumulation...&quot;)
wbt.d_inf_flow_accumulation(
dem=&quot;dem_hydro_enforced.tif&quot;,
output=&quot;flow_accum.tif&quot;,
log=True
)

print(&quot;Complete!&quot;)
</code></pre>
<p>To run the above script, open a terminal (command prompt), <em>cd</em> to the script containing folder, and run the following command:</p>
<pre><code>&gt;&gt;python FlowAccumulation.py
</code></pre>
<p>If Python 3 is not your default Python version, substitute <code>python3</code> for <code>python</code> in the above command line. The final D-infinity flow accumulation raster can be displayed in any GIS software of choice and should look similar to Figure 5.</p>
<p><img src="../img/flow_accum.png" alt="Output of the flow accumulation script for the St. Elis Mountains data set." /></p>
<a class="header" href="#interfacing-with-r" id="interfacing-with-r"><h1>Interfacing With <em>R</em></h1></a>
<p>In addition to the Python interface, the <em>WhiteboxTools</em> library is also accessible from an <a href="https://www.r-project.org/"><em>R</em></a> language package. <em>R</em> is a common programming language used within the statistical and scientific computing communities and the <em>R WhiteboxTools</em> package targets these groups. Prof. <a href="https://lidarblog.com/index.html">Qiusheng Wu</a>, at Binghamton University (SUNY) maintains the <em>R</em> package.</p>
<a class="header" href="#installation" id="installation"><h2>Installation</h2></a>
<p><em>WhiteboxTools</em> is available on <a href="https://r-forge.r-project.org/">R-Forge</a> and can be installed with the command:</p>
<pre><code class="language-python">install.packages(&quot;whitebox&quot;, repos=&quot;http://R-Forge.R-project.org&quot;)
</code></pre>
<p>You can alternatively install the development version of the <em>R</em> package <strong>whitebox</strong> from the <a href="https://github.com/giswqs/whiteboxR">GitHub repository</a> as follows:</p>
<pre><code class="language-python">if (!require(devtools)) install.packages('devtools')
devtools::install_github(&quot;giswqs/whiteboxR&quot;)
</code></pre>
<p>You will also need to make sure your machine is able to build packages from source. See <a href="http://www.rstudio.com/ide/docs/packages/prerequisites">Package Development Prerequisites</a> for the tools needed for your operating system.</p>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>A complete list of functions available in the <strong>whitebox</strong> <em>R</em> package can be found <a href="https://giswqs.github.io/whiteboxR/reference/index.html">within the GitHub repository</a>. A comprehensive <a href="https://giswqs.github.io/whiteboxR/articles/demo.html">demonstration</a>, complete with detailed examples, is also available from this site.</p>
<a class="header" href="#about-whiteboxtools" id="about-whiteboxtools"><h3>About <em>WhiteboxTools</em></h3></a>
<pre><code class="language-python">library(whitebox)

# Prints the whitebox-tools help...a listing of available commands
print(wbt_help())

# Prints the whitebox-tools license
print(wbt_license())

# Prints the whitebox-tools version
print(wbt_version())

# Prints the toolbox for a specific tool.
print(wbt_toolbox())

# List all available tools in whitebox-tools
print(wbt_list_tools())

# Lists tools with 'lidar' in tool name or description.
print(wbt_list_tools(&quot;lidar&quot;))

# Prints the help for a specific tool.
print(wbt_tool_help(&quot;lidar_info&quot;))

# Retrieves the tool parameter descriptions for a specific tool.
print(wbt_tool_parameters(&quot;slope&quot;))

# View the source code for a specific tool on the source code repository.
print(wbt_view_code(&quot;breach_depressions&quot;))
</code></pre>
<a class="header" href="#how-to-run-tools" id="how-to-run-tools"><h3>How to run tools?</h3></a>
<p>Tool names in the <em>whitebox R</em> package can be called using the snake_case (e.g. lidar_info). A comprehensive list of all available function tools can be found on the <a href="https://giswqs.github.io/whiteboxR/reference/index.html">package repository site</a>. For example:</p>
<pre><code class="language-python">library(whitebox)

# Set input raster DEM file
dem &lt;- system.file(&quot;extdata&quot;, &quot;DEM.tif&quot;, package=&quot;whitebox&quot;)

# Run tools
feature_preserving_denoise(dem, &quot;./smoothed.tif&quot;, filter=9)
breach_depressions(&quot;./smoothed.tif&quot;, &quot;./breached.tif&quot;)
d_inf_flow_accumulation(dem, &quot;./flow_accum.tif&quot;, verbose_mode=FALSE)
</code></pre>
<a class="header" href="#whiteboxtools-runner" id="whiteboxtools-runner"><h1><em>WhiteboxTools Runner</em></h1></a>
<p>There is a Python script contained within the <em>WhiteboxTools</em> directory called '<em>wb_runner.py</em>'. This script is intended to provide a very basic user-interface, <em>WhiteboxTools Runner</em>, for running the tools contained within the <em>WhiteboxTools</em> library. The user-interface uses Python's TkInter GUI library and is cross-platform. The user interface is currently experimental and is under heavy testing. Please report any issues that you experience in using it.</p>
<p><img src="img/WBRunner.png" alt="The WhiteboxTools Runner user-interface" /></p>
<p>The <em>WhiteboxTools Runner</em> does not rely on the <em>Whitebox GAT</em> user interface at all and can therefore be used indepedent of the larger project. The script must be run from a directory that also contains the '<em>whitebox_tools.py</em>' Python script and the '<em>whitebox_tools</em>' executable file. There are plans to link tool help documentation in <em>WhiteboxTools Runner</em> and to incorporate toolbox information, rather than one large listing of available tools.</p>
<p>To launch the runner application, open a terminal and issue issue the following commands:</p>
<pre><code>cd /path/to/whitebox_runner/script/
python3 wb_runner.py
</code></pre>
<p>If you recieve <code>No module named '_tkinter'</code> error when running the WhiteboxTools Runner on Linux, you likely need to install the python3-tk package:</p>
<ul>
<li>For Ubuntu, Linux Mint, try sudo apt-get install python3-tk</li>
<li>For Manjaro, Arch Linux, try sudo pacman -S tk</li>
</ul>
<a class="header" href="#qgis-plugin" id="qgis-plugin"><h1>QGIS Plugin</h1></a>
<p><em>WhiteboxTools</em> functionality can also be accessed conveniently through the popular open-source geospatial software QGIS. QGIS developer <a href="https://wiki.osgeo.org/wiki/User:Alexbruy">Alexander Bruy</a> maintains a plugin for the toolbox called <a href="https://plugins.bruy.me/processing-whitebox.html">Whitebox For Processing</a>.</p>
<blockquote>
<p>The Whitebox for QGIS plugin works QGIS v3 but cannot be installed on the earlier v2 series.</p>
</blockquote>
<p><img src="img/QGIS_plugin.png" alt="The WhiteboxTools QGIS plugin toolbox" /></p>
<a class="header" href="#installation-of-the-plugin" id="installation-of-the-plugin"><h2>Installation of the Plugin</h2></a>
<ol>
<li>From the <strong>Plugins</strong> menu, select <strong>Manage and Install Plugins...</strong>.</li>
<li>Select the <strong>Settings</strong> tab and press the <strong>Add</strong> button.</li>
<li>In the <strong>Repository details</strong> dialog box, enter <code>https://plugins.bruy.me/plugins/plugins.xml</code> in the <strong>Name</strong> textbox and press <strong>OK</strong>.</li>
</ol>
<p><img src="img/QGIS_add_repo.png" alt="The WhiteboxTools QGIS plugin toolbox installation" /></p>
<ol start="4">
<li>Select the <strong>All</strong> tab and enter the word 'whitebox' in the search box. <code>Whitebox for Processing</code> should appear the search listing. Select and check this toolbox and press the <strong>Install</strong> buttton.</li>
</ol>
<p><img src="img/QGIS_whitebox.png" alt="The WhiteboxTools QGIS plugin toolbox installation" /></p>
<blockquote>
<p>Note that the QGIS plugin does not come with a copy of the <em>WhiteboxTools</em> executable and so you will still need to download <em>WhiteboxTools</em> from either the <a href="https://jblindsay.github.io/ghrg/WhiteboxTools/download.html">Geomorphometry and Hydrogeomatics Research Group website</a> or the <a href="https://github.com/jblindsay/whitebox-tools/releases">WhiteboxTools Github repository</a> prior to running the plugin.</p>
</blockquote>
<ol start="5">
<li>
<p>Once you've downloaded WhiteboxTools and decompressed (unzipped) the folder, select <strong>Options</strong> from under the <strong>Settings</strong> menu in QGIS.</p>
</li>
<li>
<p>Select the <strong>Processing</strong> tab and the <strong>Providers</strong> list item. You should find the WhiteboxTools entry there. Select the down arrow, and check the <strong>Activate</strong> and <strong>Log commands output</strong> checkboxes. Lastly, enter full file name of the WhiteboxTools executable file contained within the decompressed WhiteboxTools folder that you downloaded previously (see note above). If you are using a Mac or Linux computer, note that this may require you to 1) select a file contained in the folder that is not the executable (QGIS seems to exclude files without extensions, which the WhiteboxTools executable is on MacOS and Linux) then delete the file extension (see below). You will also need to leave the textbox by selecting any other feature on the dialog box before pressing the <strong>OK</strong> button.</p>
</li>
</ol>
<p><img src="img/QGIS_settings.png" alt="The WhiteboxTools QGIS plugin toolbox installation" /></p>
<p>You should now see the Whitebox toolbox within the <strong>Processing Toolbox</strong> at the right-hand side of the QGIS interface, as in the screenshots above.</p>
<a class="header" href="#arcgis-plugin" id="arcgis-plugin"><h1>ArcGIS Plugin</h1></a>
<p><em>WhiteboxTools</em> functionality can also be accessed conveniently through the ArcGIS. This <em>WhiteboxTools</em> front-end has been developed and is maintained by Prof. <a href="https://lidarblog.com/index.html">Qiusheng Wu</a>, of Binghamton University (SUNY). This front-end is available from the <a href="https://github.com/giswqs/WhiteboxTools-ArcGIS">Gihub repository</a>. The plugin works for ArcGIS 10.6 and ArcGIS Pro; other version of ArcGIS have not been tested for support. Detailed instructions on installing and setting-up the ArcGIS toolbox can be found on the GitHub site.</p>
<p><img src="img/ArcGIS_toolbox.png" alt="The WhiteboxTools ArcGIS plugin toolbox" /></p>
<a class="header" href="#tools-reference" id="tools-reference"><h1>Tools Reference</h1></a>
<p>The <em>WhiteboxTools</em> library currently contains approximately 400 tools, which are organized into themed toolboxes, including:</p>
<ul>
<li><a href="available_tools/./data_tools.html">Data Tools</a></li>
<li><a href="available_tools/./geomorphometric_analysis.html">Geomorphometric Analysis</a></li>
<li><a href="available_tools/./gis_analysis.html">GIS Analysis</a></li>
<li><a href="available_tools/./hydrological_analysis.html">Hydrological Analysis</a></li>
<li><a href="available_tools/./image_processing_tools.html">Image Analysis</a></li>
<li><a href="available_tools/./lidar_tools.html">LiDAR Analysis</a></li>
<li><a href="available_tools/./mathand_stats_tools.html">Mathematical and Statistical Analysis</a></li>
<li><a href="available_tools/./stream_network_analysis.html">Stream Network Analysis </a></li>
</ul>
<p>To retrieve detailed information about a tool's input arguments and example usage, either use the <code>toolhelp</code> command from the terminal, or the <code>wbt.tool_help('tool_name')</code> function from the <em>whitebox_tools.py</em> script. The following is a complete listing of available tools, with brief descriptions, tool parameter, and example usage.</p>
<p>The <a href="available_tools/../tool_index.html">Tool Index</a> located at the end of the user manual contains a complete alphabetical listing of the available tools.</p>
<a class="header" href="#data-tools" id="data-tools"><h1>Data Tools</h1></a>
<ul>
<li><a href="#AddPointCoordinatesToTable">AddPointCoordinatesToTable</a></li>
<li><a href="#CleanVector">CleanVector</a></li>
<li><a href="#ConvertNodataToZero">ConvertNodataToZero</a></li>
<li><a href="#ConvertRasterFormat">ConvertRasterFormat</a></li>
<li><a href="#CsvPointsToVector">CsvPointsToVector</a></li>
<li><a href="#ExportTableToCsv">ExportTableToCsv</a></li>
<li><a href="#JoinTables">JoinTables</a></li>
<li><a href="#LinesToPolygons">LinesToPolygons</a></li>
<li><a href="#MergeTableWithCsv">MergeTableWithCsv</a></li>
<li><a href="#MergeVectors">MergeVectors</a></li>
<li><a href="#MultiPartToSinglePart">MultiPartToSinglePart</a></li>
<li><a href="#NewRasterFromBase">NewRasterFromBase</a></li>
<li><a href="#PolygonsToLines">PolygonsToLines</a></li>
<li><a href="#PrintGeoTiffTags">PrintGeoTiffTags</a></li>
<li><a href="#RasterToVectorLines">RasterToVectorLines</a></li>
<li><a href="#RasterToVectorPoints">RasterToVectorPoints</a></li>
<li><a href="#ReinitializeAttributeTable">ReinitializeAttributeTable</a></li>
<li><a href="#RemovePolygonHoles">RemovePolygonHoles</a></li>
<li><a href="#SetNodataValue">SetNodataValue</a></li>
<li><a href="#SinglePartToMultiPart">SinglePartToMultiPart</a></li>
<li><a href="#VectorLinesToRaster">VectorLinesToRaster</a></li>
<li><a href="#VectorPointsToRaster">VectorPointsToRaster</a></li>
<li><a href="#VectorPolygonsToRaster">VectorPolygonsToRaster</a></li>
</ul>
<p><a name="AddPointCoordinatesToTable"></a></p>
<a class="header" href="#addpointcoordinatestotable" id="addpointcoordinatestotable"><h1>AddPointCoordinatesToTable</h1></a>
<p>This tool modifies the attribute table of a vector of POINT ShapeType by adding two fields,
XCOORD and YCOORD, containing each point's X and Y coordinates respectively.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.add_point_coordinates_to_table(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AddPointCoordinatesToTable -v ^
--wd=&quot;/path/to/data/&quot; --input=points.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/add_point_coordinates_to_table.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="CleanVector"></a></p>
<a class="header" href="#cleanvector" id="cleanvector"><h1>CleanVector</h1></a>
<p>This tool can be used to remove all features in Shapefiles that are of the <code>null</code> ShapeType. It also
removes line features with fewer than two vertices and polygon features with fewer than three vertices.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clean_vector(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CleanVector -v --wd=&quot;/path/to/data/&quot; ^
-i=input.shp -o=output.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/clean_vector.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/06/2019</p>
<p><a name="ConvertNodataToZero"></a></p>
<a class="header" href="#convertnodatatozero" id="convertnodatatozero"><h1>ConvertNodataToZero</h1></a>
<p>This tool can be used to change the value within the grid cells of a raster file (<code>--input</code>) that contain
NoData to zero. The most common reason for using this tool is to change the background region of a raster
image such that it can be included in analysis since NoData values are usually ignored by by most tools.
This change, however, will result in the background no longer displaying transparently in most GIS. This
change can be reversed using the <code>SetNoDataValue</code> tool.</p>
<p><em>See Also</em>:</p>
<p><code>SetNoDataValue</code>, <code>IsNodata</code></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.convert_nodata_to_zero(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConvertNodataToZero -v ^
--wd=&quot;/path/to/data/&quot; --input=in.tif -o=NewRaster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/convert_nodata_to_zero.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="ConvertRasterFormat"></a></p>
<a class="header" href="#convertrasterformat" id="convertrasterformat"><h1>ConvertRasterFormat</h1></a>
<p>This tool converts raster data from one format to another. It determines input/output raster
formats based on extensions, but due to file extension naming collisions, it would be good to
add user hints. For example, the extension 'grd' could belong to a SurferAscii or a Surfer7Binary.
This is more important for distinguishing output files since input files can be read and
distiguishing features idenfitied from the file structure. At the moment, this tool does not
support user hints however.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.convert_raster_format(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConvertRasterFormat -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/convert_raster_format.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="CsvPointsToVector"></a></p>
<a class="header" href="#csvpointstovector" id="csvpointstovector"><h1>CsvPointsToVector</h1></a>
<p>This tool can be used to import a series of points contained within a comma-separated values
(*.csv) file (<code>--input</code>) into a vector shapefile of a POINT ShapeType. The input file must be an ASCII text
file with a .csv extensions. The tool will automatically detect the field data type; for numeric
fields, it will also determine the appropriate length and precision. The user must specify the
x-coordinate (<code>--xfield</code>) and y-coordiante (<code>--yfield</code>) fields. All fields are imported as
attributes in the output (<code>--output</code>) vector file. The tool assumes that the first line of the file is a header line from which field
names are retreived.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#mergetablewithcsv"><strong>MergeTableWithCsv</strong></a>, <a href="./data_tools.html#exporttabletocsv"><strong>ExportTableToCsv</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input CSV file (i.e. source of data to be imported)</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--xfield           </td><td> X field number (e.g. 0 for first field)</td></tr>
<tr><td>--yfield           </td><td> Y field number (e.g. 1 for second field)</td></tr>
<tr><td>--epsg             </td><td> EPSG projection (e.g. 2958)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.csv_points_to_vector(
    i, 
    output, 
    xfield=0, 
    yfield=1, 
    epsg=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CsvPointsToVector -v ^
--wd=&quot;/path/to/data/&quot; -i=points.csv -o=points.shp --xfield=0 ^
--yfield=1 --epsg=4326 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/csv_points_to_vector.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Prof. John Lindsay</p>
<p><em>Created</em>: 07/08/2019</p>
<p><a name="ExportTableToCsv"></a></p>
<a class="header" href="#exporttabletocsv" id="exporttabletocsv"><h1>ExportTableToCsv</h1></a>
<p>This tool can be used to export a vector's attribute table to a comma separated values (CSV)
file. CSV files stores tabular data (numbers and text) in plain-text form such that each row
corresponds to a record and each column to a field. Fields are typically separated by commas
within records. The user must specify the name of the vector (and associated attribute file),
the name of the output CSV file, and whether or not to include the field names as a header
column in the output CSV file.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#mergetablewithcsv"><strong>MergeTableWithCsv</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--headers          </td><td> Export field names as file header?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.export_table_to_csv(
    i, 
    output, 
    headers=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExportTableToCsv -v ^
--wd=&quot;/path/to/data/&quot; -i=lines.shp -o=output.csv --headers 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/export_table_to_csv.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/04/2018</p>
<p><a name="JoinTables"></a></p>
<a class="header" href="#jointables" id="jointables"><h1>JoinTables</h1></a>
<p>This tool can be used to join (i.e. merge) a vector's attribute table with a second table. The
user must specify the name of the vector file (and associated attribute file) as well as the
<em>primary key</em> within the table. The <em>primary key</em> (<code>--pkey</code> flag) is the field
within the table that is being appended to that serves as the identifier. Additionally, the user
must specify the name of a second vector from which the data appended into the first table will be
derived. The <em>foreign key</em> (<code>--fkey</code> flag), the identifying field within the
second table that corresponds with the data contained within the primary key in the table, must be
specified. Both the primary and foreign keys should either be strings (text) or integer values.
<em>Fields containing decimal values are not good candidates for keys.</em> Lastly, the names of the field
within the second file to include in the merge operation can also be input (<code>--import_field</code>). If the
<code>--import_field</code> field is not input, all fields in the attribute table of the second file, that are not
the foreign key nor FID, will be imported to the first table.</p>
<p>Merging works for one-to-one and many-to-one database relations. A <em>one-to-one</em> relations exists when
each record in the attribute table corresponds to one record in the second table and each primary
key is unique. Since each record in the attribute table is associated with a geospatial feature in
the vector, an example of a one-to-one relation may be where the second file contains AREA and
PERIMETER fields for each polygon feature in the vector. This is the most basic type of relation.
A many-to-one relation would exist when each record in the first attribute table corresponds to one
record in the second file and the primary key is NOT unique. Consider as an example a vector and
attribute table associated with a world map of countries. Each country has one or more more polygon
features in the shapefile, e.g. Canada has its mainland and many hundred large islands. You may want
to append a table containing data about the population and area of each country. In this case, the
COUNTRY columns in the attribute table and the second file serve as the primary and foreign keys
respectively. While there may be many duplicate primary keys (all of those Canadian polygons) each
will correspond to only one foreign key containing the population and area data. This is a
<em>many-to-one</em> relation. The <a href="./data_tools.html#jointables"><strong>JoinTables</strong></a> tool does not support one-to-many nor many-to-many relations.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#mergetablewithcsv"><strong>MergeTableWithCsv</strong></a>, <a href="./data_tools.html#reinitializeattributetable"><strong>ReinitializeAttributeTable</strong></a>, <a href="./data_tools.html#exporttabletocsv"><strong>ExportTableToCsv</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input primary vector file (i.e. the table to be modified)</td></tr>
<tr><td>--pkey             </td><td> Primary key field</td></tr>
<tr><td>--i2, --input2    </td><td> Input foreign vector file (i.e. source of data to be imported)</td></tr>
<tr><td>--fkey             </td><td> Foreign key field</td></tr>
<tr><td>--import_field     </td><td> Imported field (all fields will be imported if not specified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.join_tables(
    input1, 
    pkey, 
    input2, 
    fkey, 
    import_field, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=JoinTables -v --wd=&quot;/path/to/data/&quot; ^
--i1=properties.shp --pkey=TYPE --i2=land_class.shp ^
--fkey=VALUE --import_field=NEW_VALUE 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/join_tables.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Prof. John Lindsay</p>
<p><em>Created</em>: 07/10/2018</p>
<p><a name="LinesToPolygons"></a></p>
<a class="header" href="#linestopolygons" id="linestopolygons"><h1>LinesToPolygons</h1></a>
<p>This tool converts vector polylines into polygons. Note that this tool will close polygons
that are open and will ensure that the first part of an input line is interpreted
as the polygon hull and subsequent parts are considered holes. The tool does not
examine input lines for line crossings (self intersections), which are topological
errors.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#polygonstolines"><strong>PolygonsToLines</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector line file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lines_to_polygons(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LinesToPolygons -v ^
--wd=&quot;/path/to/data/&quot; -i=input.shp -o=output.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/lines_to_polygons.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2018</p>
<p><a name="MergeTableWithCsv"></a></p>
<a class="header" href="#mergetablewithcsv" id="mergetablewithcsv"><h1>MergeTableWithCsv</h1></a>
<p>This tool can be used to merge a vector's attribute table with data contained within a comma
separated values (CSV) text file. CSV files stores tabular data (numbers and text) in plain-text
form such that each row is a record and each column a field. Fields are typically separated by
commas although the tool will also support seimi-colon, tab, and space delimited files. The user
must specify the name of the vector (and associated attribute file) as well as the <em>primary key</em>
within the table. The <em>primary key</em> (<code>--pkey</code> flag) is the field within the
table that is being appended to that serves as the unique identifier. Additionally, the user must
specify the name of a CSV text file with either a *.csv or *.txt extension. The file must possess a
header row, i.e. the first row must contain information about the names of the various fields. The
<em>foreign key</em> (<code>--fkey</code> flag), that is the identifying field within the
CSV file that corresponds with the data contained within the <em>primary key</em> in the table, must also
be specified. Both the primary and foreign keys should either be strings (text) or integer values.
<em>Fields containing decimal values are not good candidates for keys.</em> Lastly, the user may optionally
specify the name of a field within the CSV file to import in the merge operation (<code>--import_field</code> flag).
If this flag is not specified, all of the fields within the CSV, with the exception of the foreign
key, will be appended to the attribute table.</p>
<p>Merging works for one-to-one and many-to-one database relations. A <em>one-to-one</em> relations exists when
each record in the attribute table corresponds to one record in the second table and each primary
key is unique. Since each record in the attribute table is associated with a geospatial feature in
the vector, an example of a one-to-one relation may be where the second file contains AREA and
PERIMETER fields for each polygon feature in the vector. This is the most basic type of relation.
A many-to-one relation would exist when each record in the first attribute table corresponds to one
record in the second file and the primary key is NOT unique. Consider as an example a vector and
attribute table associated with a world map of countries. Each country has one or more more polygon
features in the shapefile, e.g. Canada has its mainland and many hundred large islands. You may want
to append a table containing data about the population and area of each country. In this case, the
COUNTRY columns in the attribute table and the second file serve as the primary and foreign keys
respectively. While there may be many duplicate primary keys (all of those Canadian polygons) each
will correspond to only one foreign key containing the population and area data. This is a
<em>many-to-one</em> relation. The <a href="./data_tools.html#jointables"><strong>JoinTables</strong></a> tool does not support one-to-many nor many-to-many relations.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#jointables"><strong>JoinTables</strong></a>, <a href="./data_tools.html#reinitializeattributetable"><strong>ReinitializeAttributeTable</strong></a>, <a href="./data_tools.html#exporttabletocsv"><strong>ExportTableToCsv</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input primary vector file (i.e. the table to be modified)</td></tr>
<tr><td>--pkey             </td><td> Primary key field</td></tr>
<tr><td>--csv              </td><td> Input CSV file (i.e. source of data to be imported)</td></tr>
<tr><td>--fkey             </td><td> Foreign key field</td></tr>
<tr><td>--import_field     </td><td> Imported field (all fields will be imported if not specified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.merge_table_with_csv(
    i, 
    pkey, 
    csv, 
    fkey, 
    import_field=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MergeTableWithCsv -v ^
--wd=&quot;/path/to/data/&quot; -i=properties.shp --pkey=TYPE ^
--csv=land_class.csv --fkey=VALUE ^
--import_field=NEW_VALUE
&gt;&gt;./whitebox_tools -r=MergeTableWithCsv ^
-v --wd=&quot;/path/to/data/&quot; -i=properties.shp --pkey=TYPE ^
--csv=land_class.csv --fkey=VALUE 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/merge_table_with_csv.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Prof. John Lindsay</p>
<p><em>Created</em>: 11/10/2018</p>
<p><a name="MergeVectors"></a></p>
<a class="header" href="#mergevectors" id="mergevectors"><h1>MergeVectors</h1></a>
<p>Combines two or more input vectors of the same ShapeType creating a single, new output
vector. Importantly, the attribute table of the output vector will contain the ubiquitous
file-specific FID, the parent file name, the parent FID, and the list of attribute fields
that are shared among each of the input files. For a field to be considered common
between tables, it must have the same <code>name</code> and <code>field_type</code> (i.e. data type and
precision).</p>
<p>Overlapping features will not be identified nor handled in the merging. If you have
significant areas of overlap, it is advisable to use one of the vector overlay tools
instead.</p>
<p>The difference between <a href="./data_tools.html#mergevectors"><strong>MergeVectors</strong></a> and the <code>Append</code> tool is that merging takes two
or more files and creates one new file containing the features of all inputs, and
<code>Append</code> places the features of a single vector into another existing (appended) vector.</p>
<p>This tool only operates on vector files. Use the <a href="./image_processing_tools.html#mosaic"><strong>Mosaic</strong></a> tool to combine raster data.</p>
<p><em>See Also</em>:</p>
<p><code>Append</code>, <a href="./image_processing_tools.html#mosaic"><strong>Mosaic</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input vector files</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.merge_vectors(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MergeVectors -v --wd=&quot;/path/to/data/&quot; ^
-i='polys1.shp;polys2.shp;polys3.shp' -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/merge_vectors.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/10/2018</p>
<p><a name="MultiPartToSinglePart"></a></p>
<a class="header" href="#multiparttosinglepart" id="multiparttosinglepart"><h1>MultiPartToSinglePart</h1></a>
<p>This tool can be used to convert a vector file containing multi-part features into a vector
containing only single-part features. Any multi-part polygons or lines within the input
vector file will be split into seperate features in the output file, each possessing their
own entry in the associated attribute file. For polygon-type vectors, the user may optionally
choose to exclude hole-parts from being separated from their containing polygons. That is,
with the <code>--exclude_holes</code> flag, hole parts in the input vector will continue to belong to
their enclosing polygon in the output vector.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#singleparttomultipart"><strong>SinglePartToMultiPart</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector line or polygon file</td></tr>
<tr><td>-o, --output       </td><td> Output vector line or polygon file</td></tr>
<tr><td>--exclude_holes    </td><td> Exclude hole parts from the feature splitting? (holes will continue to belong to their features in output.)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multi_part_to_single_part(
    i, 
    output, 
    exclude_holes=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiPartToSinglePart -v ^
--wd=&quot;/path/to/data/&quot; -i=input.shp -o=output.shp ^
--exclude_holes 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/multipart_to_singlepart.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2018</p>
<p><a name="NewRasterFromBase"></a></p>
<a class="header" href="#newrasterfrombase" id="newrasterfrombase"><h1>NewRasterFromBase</h1></a>
<p>This tool can be used to create a new raster with the same coordinates and dimensions
(i.e. rows and columns) as an existing base image. The user must specify the name of the
base image (<code>--base</code>), the value that the new grid will be filled with (<code>--value</code> flag;
default of NoData), and the data type (<code>--data_type</code> flag; options include 'double',
'float', and 'integer'). Notice that the functionality of this tool is the same as
multiplying the base image by zero and adding the constant value.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#rastercellassignment"><strong>RasterCellAssignment</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base         </td><td> Input base raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--value            </td><td> Constant value to fill raster with; either 'nodata' or numeric value</td></tr>
<tr><td>--data_type        </td><td> Output raster data type; options include 'double' (64-bit), 'float' (32-bit), and 'integer' (signed 16-bit) (default is 'float')</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.new_raster_from_base(
    base, 
    output, 
    value=&quot;nodata&quot;, 
    data_type=&quot;float&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NewRasterFromBase -v ^
--wd=&quot;/path/to/data/&quot; --base=base.tif -o=NewRaster.tif ^
--value=0.0 --data_type=integer
&gt;&gt;./whitebox_tools ^
-r=NewRasterFromBase -v --wd=&quot;/path/to/data/&quot; --base=base.tif ^
-o=NewRaster.tif --value=nodata 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/new_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 11, 2017</p>
<p><a name="PolygonsToLines"></a></p>
<a class="header" href="#polygonstolines" id="polygonstolines"><h1>PolygonsToLines</h1></a>
<p>This tool converts vector polygons into polylines, simply by modifying the Shapefile geometry type.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#linestopolygons"><strong>LinesToPolygons</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
<tr><td>-o, --output       </td><td> Output vector lines file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygons_to_lines(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonsToLines -v ^
--wd=&quot;/path/to/data/&quot; -i=input.shp -o=output.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/polygons_to_lines.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/09/2018</p>
<p><a name="PrintGeoTiffTags"></a></p>
<a class="header" href="#printgeotifftags" id="printgeotifftags"><h1>PrintGeoTiffTags</h1></a>
<p>This tool can be used to view the tags contained within a GeoTiff file. Viewing
the tags of a GeoTiff file can be useful when trying to import the GeoTiff to
different software environments. The user must specify the name of a GeoTiff file
and the tag information will be output to the StdOut output stream (e.g. console).
Note that tags that contain greater than 100 values will be truncated in the output.
GeoKeys will also be interpreted as per the GeoTIFF specification.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input GeoTIFF file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.print_geo_tiff_tags(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PrintGeoTiffTags -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tiff 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/print_geotiff_tags.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: March 2, 2018</p>
<p><a name="RasterToVectorLines"></a></p>
<a class="header" href="#rastertovectorlines" id="rastertovectorlines"><h1>RasterToVectorLines</h1></a>
<p>This tool converts raster lines features into a vector of the POLYLINE ShapeType.
Grid cells associated with line features will contain non-zero, non-NoData cell
values. The algorithm requires three passes of the raster. The first pass counts
the number of line neighbours of each line cell; the second pass traces line
segments starting from line ends (i.e. line cells with only one neighbouring line
cell); lastly, the final pass traces any remaining line segments, which are likely
forming closed loops (and therefore do not have line ends).</p>
<p>If the line raster contains streams, it is preferable to use the <a href="./stream_network_analysis.html#rasterstreamstovector"><strong>RasterStreamsToVector</strong></a>
instead. This tool will use knowledge of flow directions to ensure connections
between stream segments at confluence sites, whereas <a href="./data_tools.html#rastertovectorlines"><strong>RasterToVectorLines</strong></a> will not.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#rastertovectorpoints"><strong>RasterToVectorPoints</strong></a>, <a href="./stream_network_analysis.html#rasterstreamstovector"><strong>RasterStreamsToVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster lines file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_to_vector_lines(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterToVectorLines -v ^
--wd=&quot;/path/to/data/&quot; -i=lines.tif -o=lines.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/raster_to_vector_lines.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><a name="RasterToVectorPoints"></a></p>
<a class="header" href="#rastertovectorpoints" id="rastertovectorpoints"><h1>RasterToVectorPoints</h1></a>
<p>Converts a raster dataset to a vector of the POINT shapetype. The user must specify
the name of a raster file and the name of the output vector. Points will correspond
with grid cell centre points. All grid cells containing non-zero, non-NoData values
will be considered a point. The vector's attribute table will contain a field called
'VALUE' that will contain the cell value for each point feature.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output vector points file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_to_vector_points(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterToVectorPoints -v ^
--wd=&quot;/path/to/data/&quot; --input=points.tif -o=out.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/raster_to_vector_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="ReinitializeAttributeTable"></a></p>
<a class="header" href="#reinitializeattributetable" id="reinitializeattributetable"><h1>ReinitializeAttributeTable</h1></a>
<p>Reinitializes a vector's attribute table deleting all fields but the feature ID (FID).
Caution: this tool overwrites the input file's attribute table.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reinitialize_attribute_table(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ReinitializeAttributeTable -v ^
--wd=&quot;/path/to/data/&quot; -i=input.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/reinitialize_attribute_table.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/09/2018</p>
<p><a name="RemovePolygonHoles"></a></p>
<a class="header" href="#removepolygonholes" id="removepolygonholes"><h1>RemovePolygonHoles</h1></a>
<p>This tool can be used to remove holes from the features within a vector
polygon file. The user must specify the name of the input vector file,
which must be of a polygon shapetype, and the name of the output file.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_polygon_holes(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemovePolygonHoles -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp ^
--output=no_holes.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/remove_polygon_holes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/09/2018</p>
<p><a name="SetNodataValue"></a></p>
<a class="header" href="#setnodatavalue" id="setnodatavalue"><h1>SetNodataValue</h1></a>
<p>This tool will re-assign a user-defined background value in an input raster image the <strong>NoData</strong> value.
More precisely, the NoData value will be changed to the specified background value and any existing
grid cells containing the previous NoData value, if it had been defined, will be changed to this new
value. Most WhiteboxTools tools recognize NoData grid cells and treat them specially. NoData grid cells
are also often displayed transparently by GIS software. The user must specify the names of the input and
output rasters and the background value. The default background value is zero, although any numeric
value is possible.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#convertnodatatozero"><strong>ConvertNodataToZero</strong></a>, <code>IsNodata</code></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--back_value       </td><td> Background value to set to nodata</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.set_nodata_value(
    i, 
    output, 
    back_value=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SetNodataValue -v --wd=&quot;/path/to/data/&quot; ^
-i=in.tif -o=newRaster.tif --back_value=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/set_nodata_value.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/09/2017</p>
<p><a name="SinglePartToMultiPart"></a></p>
<a class="header" href="#singleparttomultipart" id="singleparttomultipart"><h1>SinglePartToMultiPart</h1></a>
<p>This tool can be used to convert a vector file containing single-part features into a vector
containing multi-part features. The user has the option to either group features based on an
ID Field (<code>--field</code> flag), which is a categorical field within the vector's attribute table.
The ID Field should either be of String (text) or Integer type. Fields containing decimal values
are not good candidates for the ID Field. <strong>If no <code>--field</code> flag is specified, all features will
be grouped together into one large multi-part vector</strong>.</p>
<p>This tool works for vectors containing either point, line, or polygon features.
Since vectors of a POINT ShapeType cannot represent multi-part features, the ShapeType of the
output file will be modified to a MULTIPOINT ShapeType if the input file is of a POINT ShapeType.
If the input vector is of a POLYGON ShapeType, the user can optionally set the algorithm to search
for polygons that should be represented as hole parts. In the case of grouping based on an ID Field,
hole parts are polygon features contained within larger polygons of the same ID Field value. Please
note that searching for polygon holes may significantly increase processing time for larger polygon
coverages.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#multiparttosinglepart"><strong>MultiPartToSinglePart</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector line or polygon file</td></tr>
<tr><td>--field            </td><td> Grouping ID field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output vector line or polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.single_part_to_multi_part(
    i, 
    output, 
    field=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SinglePartToMultiPart -v ^
--wd=&quot;/path/to/data/&quot; -i=input.shp -o=output.shp ^
--field='COUNTRY' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/singlepart_to_multipart.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2018</p>
<p><a name="VectorLinesToRaster"></a></p>
<a class="header" href="#vectorlinestoraster" id="vectorlinestoraster"><h1>VectorLinesToRaster</h1></a>
<p>This tool can be used to convert a vector lines or polygon file into a raster grid of lines. If a vector of one
of the polygon shapetypes is selected, the resulting raster will outline the polygons without filling these
features. Use the <code>VectorPolygonToRaster</code> tool if you need to fill the polygon features.</p>
<p>The user must specify the name of the input vector (<code>--input</code>) and the output raster file (<code>--output</code>). The Field
Name (<code>--field</code>) is
the field from the attributes table, from which the tool will retrieve the information to assign to
grid cells in the output raster. Note that if this field contains numerical data with no decimals, the output raster
data type will be INTEGER; if it contains decimals it will be of a FLOAT data type. The field must contain numerical
data. If the user does not supply a Field Name parameter, each feature in the raster will be assigned the record
number of the feature. The assignment operation determines how the situation of multiple points contained within the
same grid cell is handled. The background value is the value that is assigned to grid cells in the output raster that
do not correspond to the location of any points in the input vector. This value can be any numerical value (e.g. 0)
or the string 'NoData', which is the default.</p>
<p>If the user optionally specifies the <code>--cell_size</code> parameter then the coordinates will be determined by the input
vector (i.e. the bounding box) and the specified Cell Size. This will also determine the number of rows and columns
in the output raster. If the user instead specifies the optional base raster file parameter (<code>--base</code>), the output raster's
coordinates (i.e. north, south, east, west) and row and column count will be the same as the base file. If the user
does not specify either of these two optional parameters, the tool will determine the cell size automatically as the
maximum of the north-south extent (determined from the shapefile's bounding box) or the east-west extent divided by 500.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#vectorpointstoraster"><strong>VectorPointsToRaster</strong></a>, <a href="./data_tools.html#vectorpolygonstoraster"><strong>VectorPolygonsToRaster</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector lines file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--nodata           </td><td> Background value to set to NoData. Without this flag, it will be set to 0.0</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.vector_lines_to_raster(
    i, 
    output, 
    field=&quot;FID&quot;, 
    nodata=True, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VectorLinesToRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=lines.shp --field=ELEV -o=output.tif ^
--nodata --cell_size=10.0
        &gt;&gt;./whitebox_tools ^
-r=VectorLinesToRaster -v --wd=&quot;/path/to/data/&quot; -i=lines.shp ^
--field=FID -o=output.tif --base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/vector_lines_to_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/04/2018</p>
<p><a name="VectorPointsToRaster"></a></p>
<a class="header" href="#vectorpointstoraster" id="vectorpointstoraster"><h1>VectorPointsToRaster</h1></a>
<p>This tool can be used to convert a vector points file into a raster grid. The user must
specify the name of the input vector and the output raster file. The field name (<code>--field</code>)
is the field from the attributes table from which the tool will retrieve the information to
assign to grid cells in the output raster. The field must contain numerical data. If the user does not
supply a field name parameter, each feature in the raster will be assigned the record number
of the feature. The assignment operation determines how the situation of multiple points
contained within the same grid cell is handled. The background value is zero by default
but can be set to <code>NoData</code> optionally using the <code>--nodata</code> value.</p>
<p>If the user optionally specifies the grid cell size parameter (<code>--cell_size</code>) then the coordinates
will be determined by the input vector (i.e. the bounding box) and the specified cell size. This
will also determine the number of rows and columns in the output raster. If the user instead
specifies the optional base raster file parameter (<code>--base</code>), the output raster's coordinates (i.e.
north, south, east, west) and row and column count will be the same as the base file.</p>
<p>In the case that multiple points are contained within a single grid cell, the output can be
assigned (<code>--assign</code>) the first, last (default), min, max, or sum of the contained points.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#vectorpolygonstoraster"><strong>VectorPolygonsToRaster</strong></a>, <a href="./data_tools.html#vectorlinestoraster"><strong>VectorLinesToRaster</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--assign           </td><td> Assignment operation, where multiple points are in the same grid cell; options include 'first', 'last' (default), 'min', 'max', 'sum'</td></tr>
<tr><td>--nodata           </td><td> Background value to set to NoData. Without this flag, it will be set to 0.0</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.vector_points_to_raster(
    i, 
    output, 
    field=&quot;FID&quot;, 
    assign=&quot;last&quot;, 
    nodata=True, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VectorPointsToRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--assign=min --nodata ^
--cell_size=10.0
        &gt;&gt;./whitebox_tools ^
-r=VectorPointsToRaster -v --wd=&quot;/path/to/data/&quot; -i=points.shp ^
--field=FID -o=output.tif --assign=last ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/vector_points_to_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/04/2018</p>
<p><a name="VectorPolygonsToRaster"></a></p>
<a class="header" href="#vectorpolygonstoraster" id="vectorpolygonstoraster"><h1>VectorPolygonsToRaster</h1></a>
<p>Converts a vector containing polygons into a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygons file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--nodata           </td><td> Background value to set to NoData. Without this flag, it will be set to 0.0</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.vector_polygons_to_raster(
    i, 
    output, 
    field=&quot;FID&quot;, 
    nodata=True, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VectorPolygonsToRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=lakes.shp --field=ELEV -o=output.tif ^
--nodata --cell_size=10.0
        &gt;&gt;./whitebox_tools ^
-r=VectorPolygonsToRaster -v --wd=&quot;/path/to/data/&quot; ^
-i=lakes.shp --field=ELEV -o=output.tif ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/data_tools/vector_polygons_to_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/04/2018</p>
<a class="header" href="#geomorphometric-analysis" id="geomorphometric-analysis"><h1>Geomorphometric Analysis</h1></a>
<ul>
<li><a href="#Aspect">Aspect</a></li>
<li><a href="#AverageNormalVectorAngularDeviation">AverageNormalVectorAngularDeviation</a></li>
<li><a href="#CircularVarianceOfAspect">CircularVarianceOfAspect</a></li>
<li><a href="#DevFromMeanElev">DevFromMeanElev</a></li>
<li><a href="#DiffFromMeanElev">DiffFromMeanElev</a></li>
<li><a href="#DirectionalRelief">DirectionalRelief</a></li>
<li><a href="#DownslopeIndex">DownslopeIndex</a></li>
<li><a href="#EdgeDensity">EdgeDensity</a></li>
<li><a href="#ElevAbovePit">ElevAbovePit</a></li>
<li><a href="#ElevPercentile">ElevPercentile</a></li>
<li><a href="#ElevRelativeToMinMax">ElevRelativeToMinMax</a></li>
<li><a href="#ElevRelativeToWatershedMinMax">ElevRelativeToWatershedMinMax</a></li>
<li><a href="#FeaturePreservingSmoothing">FeaturePreservingSmoothing</a></li>
<li><a href="#FetchAnalysis">FetchAnalysis</a></li>
<li><a href="#FillMissingData">FillMissingData</a></li>
<li><a href="#FindRidges">FindRidges</a></li>
<li><a href="#Hillshade">Hillshade</a></li>
<li><a href="#HorizonAngle">HorizonAngle</a></li>
<li><a href="#HypsometricAnalysis">HypsometricAnalysis</a></li>
<li><a href="#MaxAnisotropyDev">MaxAnisotropyDev</a></li>
<li><a href="#MaxAnisotropyDevSignature">MaxAnisotropyDevSignature</a></li>
<li><a href="#MaxBranchLength">MaxBranchLength</a></li>
<li><a href="#MaxDifferenceFromMean">MaxDifferenceFromMean</a></li>
<li><a href="#MaxDownslopeElevChange">MaxDownslopeElevChange</a></li>
<li><a href="#MaxElevDevSignature">MaxElevDevSignature</a></li>
<li><a href="#MaxElevationDeviation">MaxElevationDeviation</a></li>
<li><a href="#MinDownslopeElevChange">MinDownslopeElevChange</a></li>
<li><a href="#MultiscaleRoughness">MultiscaleRoughness</a></li>
<li><a href="#MultiscaleRoughnessSignature">MultiscaleRoughnessSignature</a></li>
<li><a href="#MultiscaleStdDevNormals">MultiscaleStdDevNormals</a></li>
<li><a href="#MultiscaleStdDevNormalsSignature">MultiscaleStdDevNormalsSignature</a></li>
<li><a href="#MultiscaleTopographicPositionImage">MultiscaleTopographicPositionImage</a></li>
<li><a href="#NumDownslopeNeighbours">NumDownslopeNeighbours</a></li>
<li><a href="#NumUpslopeNeighbours">NumUpslopeNeighbours</a></li>
<li><a href="#PennockLandformClass">PennockLandformClass</a></li>
<li><a href="#PercentElevRange">PercentElevRange</a></li>
<li><a href="#PlanCurvature">PlanCurvature</a></li>
<li><a href="#Profile">Profile</a></li>
<li><a href="#ProfileCurvature">ProfileCurvature</a></li>
<li><a href="#RelativeAspect">RelativeAspect</a></li>
<li><a href="#RelativeStreamPowerIndex">RelativeStreamPowerIndex</a></li>
<li><a href="#RelativeTopographicPosition">RelativeTopographicPosition</a></li>
<li><a href="#RemoveOffTerrainObjects">RemoveOffTerrainObjects</a></li>
<li><a href="#RuggednessIndex">RuggednessIndex</a></li>
<li><a href="#SedimentTransportIndex">SedimentTransportIndex</a></li>
<li><a href="#Slope">Slope</a></li>
<li><a href="#SlopeVsElevationPlot">SlopeVsElevationPlot</a></li>
<li><a href="#SphericalStdDevOfNormals">SphericalStdDevOfNormals</a></li>
<li><a href="#StandardDeviationOfSlope">StandardDeviationOfSlope</a></li>
<li><a href="#SurfaceAreaRatio">SurfaceAreaRatio</a></li>
<li><a href="#TangentialCurvature">TangentialCurvature</a></li>
<li><a href="#TotalCurvature">TotalCurvature</a></li>
<li><a href="#Viewshed">Viewshed</a></li>
<li><a href="#VisibilityIndex">VisibilityIndex</a></li>
<li><a href="#WetnessIndex">WetnessIndex</a></li>
</ul>
<p><a name="Aspect"></a></p>
<a class="header" href="#aspect" id="aspect"><h1>Aspect</h1></a>
<p>This tool calculates slope aspect (i.e. slope orientation in degrees clockwise from north) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>aspect = 180 - arctan(f<sub>y</sub> / f<sub>x</sub>) + 90(f<sub>x</sub> / |f<sub>x</sub>|)</p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / 8 * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.aspect(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Aspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="AverageNormalVectorAngularDeviation"></a></p>
<a class="header" href="#averagenormalvectorangulardeviation" id="averagenormalvectorangulardeviation"><h1>AverageNormalVectorAngularDeviation</h1></a>
<p>This tool characterizes the spatial distribution of the average normal vector angular deviation, a measure of
surface roughness. Working in the field of 3D printing, Ko et al. (2016) defined a measure of surface roughness
based on quantifying the angular deviations in the direction of the normal vector of a real surface from its ideal
(i.e. smoothed) form. This measure of surface complexity is therefore in units of degrees. Specifically, roughness
is defined in this study as the neighborhood-averaged difference in the normal vectors of the original DEM and a
smoothed DEM surface. Smoothed surfaces are derived by applying a Gaussian blur of the same size as the
neighborhood (<code>--filter</code>).</p>
<p>The <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a> tool calculates the same measure of surface roughness, except that it is designed to
work with multiple spatial scales.</p>
<p><em>Reference</em>:</p>
<p>Ko, M., Kang, H., ulrim Kim, J., Lee, Y., &amp; Hwang, J. E. (2016, July). How to measure quality of affordable 3D
printing: Cultivating quantitative index in the user community. In International Conference on Human-Computer
Interaction (pp. 116-121). Springer, Cham.</p>
<p>Lindsay, J. B., &amp; Newman, D. R. (2018). Hyper-scale analysis of surface roughness. PeerJ Preprints, 6, e27110v1.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_normal_vector_angular_deviation(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageNormalVectorAngularDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/average_normal_vector_angular_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><a name="CircularVarianceOfAspect"></a></p>
<a class="header" href="#circularvarianceofaspect" id="circularvarianceofaspect"><h1>CircularVarianceOfAspect</h1></a>
<p>This tool can be used to calculate the circular variance (i.e. one minus the mean resultant length) of aspect
for an input digital elevation model (DEM). This is a measure of how variable slope aspect is within a local
neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a> is therefore a measure of <strong>surface
shape complexity</strong>, or texture. It will take a value of 0.0 for smooth sites and near 1.0 in areas of high surface
roughness or complex topography.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular variance, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, the metric should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <strong><em>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</em></strong> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.circular_variance_of_aspect(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CircularVarianceOfAspect -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/circular_variance_of_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/01/2019</p>
<p><a name="DevFromMeanElev"></a></p>
<a class="header" href="#devfrommeanelev" id="devfrommeanelev"><h1>DevFromMeanElev</h1></a>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood, normalized by standard
deviation. Therefore, this index of topographic residual is essentially equivalent to a
local z-score. This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the deviation from mean elevation (DEV) at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool can be used to output the per-pixel maximum DEV
value across a range of input scales.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.dev_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DevFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/dev_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/06/2017</p>
<p><a name="DiffFromMeanElev"></a></p>
<a class="header" href="#difffrommeanelev" id="difffrommeanelev"><h1>DiffFromMeanElev</h1></a>
<p>This tool can be used to calculate the difference between the elevation of each grid
cell and the mean elevation of the centering local neighbourhood. This is similar to what a high-pass
filter calculates for imagery data, but is intended to work with DEM data instead. This attribute
measures the <em>relative topographic position</em>. <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>
utilizes an integral image approach (Crow, 1984) to ensure highly efficient filtering that
is invariant with filter size.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM), the
name of the output file (<code>--output</code>), and the size of the neighbourhood in the <em>x</em> and <em>y</em>
directions (<code>--filterx</code> and <code>--filtery</code>), measured in grid size.</p>
<p>While <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a> calculates the DIFF at a single, user-defined
scale, the <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a> tool can be used to output the per-pixel maximum DIFF
value across a range of input scales.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.diff_from_mean_elev(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiffFromMeanElev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/diff_from_mean_elev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="DirectionalRelief"></a></p>
<a class="header" href="#directionalrelief" id="directionalrelief"><h1>DirectionalRelief</h1></a>
<p>This tool calculates the relief for each grid cell in a digital elevation model (DEM) in a specified direction.
Directional relief is an index of the degree to which a DEM grid cell is higher or lower than its surroundings.
It is calculated by subtracting the elevation of a DEM grid cell from the average elevation of those cells which
lie between it and the edge of the DEM in a specified compass direction. Thus, positive values indicate that a
grid cell is lower than the average elevation of the grid cells in a specific direction (i.e. relatively sheltered),
whereas a negative directional relief indicates that the grid cell is higher (i.e. relatively exposed). The
algorithm is based on a modification of the procedure described by Lapen and Martz (1993). The modifications
include: (1) the ability to specify any direction between 0-degrees and 360-degrees (<code>--azimuth</code>), and (2) the ability to use
a distance-limited search (<code>--max_dist</code>), such that the ray-tracing procedure terminates before the DEM edge is
reached for longer search paths. The algorithm works by tracing a ray from each grid cell in the direction of
interest and evaluating the average elevation along the ray. Linear interpolation is used to estimate the elevation
of the surface where a ray does not intersect the DEM grid precisely at one of its nodes. The user must specify the
name of an input DEM raster file, the output raster name, and a hypothetical wind direction. Furthermore, the user
is able to constrain the maximum search distance for the ray tracing. If no maximum search distance is specified,
each ray will be traced to the edge of the DEM. The units of the output image are the same as the input DEM.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate
for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued grid cells in the
input image will be assigned NoData values in the output image. The output raster is of the float data type and
continuous data scale. Directional relief is best displayed using the blue-white-red bipolar palette to distinguish
between the positive and negative values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#fetchanalysis"><strong>FetchAnalysis</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees</td></tr>
<tr><td>--max_dist         </td><td> Optional maximum search distance (unspecified if none; in xy units)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.directional_relief(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DirectionalRelief -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/directional_relief.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="DownslopeIndex"></a></p>
<a class="header" href="#downslopeindex" id="downslopeindex"><h1>DownslopeIndex</h1></a>
<p>This tool can be used to calculate the downslope index described by Hjerdt et al. (2004).
The downslope index is a measure of the slope gradient between a grid cell and some
downslope location (along the flowpath passing through the upslope grid cell) that
represents a specified vertical drop (i.e. a potential head drop). The index has been
shown to be useful for hydrological, geomorphological, and biogeochemical applications.</p>
<p>The user must specify the name of a digital elevaton model (DEM) raster. This DEM
should be have been pre-processed to remove artifact topographic depressions and flat
areas. The user must also specify the head potential drop (d), and the output type. The
output type can be either '<code>tangent</code>', '<code>degrees</code>', '<code>radians</code>', or '<code>distance</code>'. If
'<code>distance</code>' is selected as the output type, the output grid actually represents the
downslope flowpath length required to drop d meters from each grid cell. Linear
interpolation is used when the specified drop value is encountered between two adjacent
grid cells along a flowpath traverse.</p>
<p>Notice that this algorithm is affected by edge contamination. That is, for some grid cells,
the edge of the grid will be encountered along a flowpath traverse before the specified
vertical drop occurs. In these cases, the value of the downslope index is approximated by
replacing d with the actual elevation drop observed along the flowpath. To avoid this problem,
the entire watershed containing an area of interest should be contained in the DEM.</p>
<p>Grid cells containing NoData values in any of the input images are assigned the NoData
value in the output raster. The output raster is of the float data type and continuous
data scale.</p>
<p><em>Reference</em>:</p>
<p>Hjerdt, K.N., McDonnell, J.J., Seibert, J. Rodhe, A. (2004) <em>A new topographic index to
quantify downslope controls on local drainage</em>, <strong>Water Resources Research</strong>, 40, W05602,
doi:10.1029/2004WR003130.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--drop             </td><td> Vertical drop value (default is 2.0)</td></tr>
<tr><td>--out_type         </td><td> Output type, options include 'tangent', 'degrees', 'radians', 'distance' (default is 'tangent')</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.downslope_index(
    dem, 
    output, 
    drop=2.0, 
    out_type=&quot;tangent&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DownslopeIndex -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=dsi.tif --drop=5.0 --out_type=distance 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/downslope_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 17, 2017</p>
<p><a name="EdgeDensity"></a></p>
<a class="header" href="#edgedensity" id="edgedensity"><h1>EdgeDensity</h1></a>
<p>This tool calculates the density of edges, or breaks-in-slope within an input digital elevation model (DEM).
A break-in-slope occurs between two neighbouring grid cells if the angular difference between their normal
vectors is greater than a user-specified threshold value (<code>--norm_diff</code>). <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> calculates the proportion
of edge cells within the neighbouring window, of square filter dimension <code>--filter</code>, surrounding each grid cell.
Therefore, <code>EdgeDensity</code>is a measure of how complex the topographic surface is within a local neighbourhood.
It is therefore a measure of topographic texture. It will take a value near 0.0 for smooth sites and 1.0 in areas
of high surface roughness or complex topography.</p>
<p>The distribution of <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> is highly dependent upon the value of the <code>norm_diff</code> used in the calculation. This
threshold may require experimentation to find an appropriate value and is likely dependent upon the topography and
source data. Nonetheless, experience has shown that <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a> provides one of the best measures of surface
texture of any of the available roughness tools.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.edge_density(
    dem, 
    output, 
    filter=11, 
    norm_diff=5.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgeDensity -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=15 --norm_diff=20.0 ^
--num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/edge_density.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/01/2019</p>
<p><a name="ElevAbovePit"></a></p>
<a class="header" href="#elevabovepit" id="elevabovepit"><h1>ElevAbovePit</h1></a>
<p>This tool will calculate the elevation of each grid cell in a digital elevation model (DEM) above the nearest
downslope pit cell or grid edge cell, depending on which is encountered first during the flow-path traverse.
The resulting image is therefore a measure of relative landscape position. The user must specify the names of
a D8 flow pointer grid, a DEM file, and the output file. The flow pointer grid must be derived using the D8
flow algorithm.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_above_pit(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevAbovePit -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_above_pit.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="ElevPercentile"></a></p>
<a class="header" href="#elevpercentile" id="elevpercentile"><h1>ElevPercentile</h1></a>
<p>Elevation percentile (EP) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentile of the
elevation distribution within the filter window, such that:</p>
<blockquote>
<p>EP = count<sub>i∈C</sub>(z<sub>i</sub> &gt; z<sub>0</sub>) x (100 / n<sub>C</sub>)</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>i</sub> is the elevation
of cell <em>i</em> contained within the neighboring set C, and n<sub>C</sub> is the number
of grid cells contained within the window.</p>
<p>EP is unsigned and expressed as a percentage, bound between 0%
and 100%. Quantile-based estimates (e.g., the median and interquartile
range) are often used in nonparametric statistics to provide data
variability estimates without assuming the distribution is normal.
Thus, EP is largely unaffected by irregularly shaped elevation frequency
distributions or by outliers in the DEM, resulting in a highly robust metric
of LTP. In fact, elevation distributions within small to medium sized
neighborhoods often exhibit skewed, multimodal, and non-Gaussian
distributions, where the occurrence of elevation errors can often result
in distribution outliers. Thus, based on these statistical characteristics,
EP is considered one of the most robust representation of LTP.</p>
<p>The algorithm implemented by this tool uses the relatively efficient running-histogram filtering algorithm of Huang
et al. (1979). Because most DEMs contain floating point data, elevation values must be rounded to be binned. The
<code>--sig_digits</code> parameter is used to determine the level of precision preserved during this binning process. The
algorithm is parallelized to further aid with computational efficiency.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_percentile(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevPercentile -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_percentile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="ElevRelativeToMinMax"></a></p>
<a class="header" href="#elevrelativetominmax" id="elevrelativetominmax"><h1>ElevRelativeToMinMax</h1></a>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a
percentage of the relief between the DEM minimum and maximum values. As such, it provides a basic
measure of relative topographic position.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevrelativetowatershedminmax"><strong>ElevRelativeToWatershedMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_min_max(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_relative_to_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="ElevRelativeToWatershedMinMax"></a></p>
<a class="header" href="#elevrelativetowatershedminmax" id="elevrelativetowatershedminmax"><h1>ElevRelativeToWatershedMinMax</h1></a>
<p>This tool can be used to express the elevation of a grid cell in a digital elevation model (DEM) as a percentage
of the relief between the watershed minimum and maximum values. As such, it provides a basic
measure of relative topographic position. The user must specify the names of DEM (<code>--dem</code>) and watersheds (<code>--watersheds</code>)
raster files.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevrelativetominmax"><strong>ElevRelativeToMinMax</strong></a>, <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--watersheds       </td><td> Input raster watersheds file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elev_relative_to_watershed_min_max(
    dem, 
    watersheds, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevRelativeToWatershedMinMax -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --watersheds=watershed.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/elev_relative_to_watershed_min_max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="FeaturePreservingSmoothing"></a></p>
<a class="header" href="#featurepreservingsmoothing" id="featurepreservingsmoothing"><h1>FeaturePreservingSmoothing</h1></a>
<p>This tool implements a highly modified form of the DEM de-noising algorithm described
by Sun et al. (2007). It is very effective at removing surface roughness from digital
elevation models (DEMs), without significantly altering breaks-in-slope. As such,
this tool should be used for smoothing DEMs rather than either smoothing with
low-pass filters (e.g. mean, median, Gaussian filters) or grid size coarsening
by resampling. The algorithm works by 1) calculating the surface normal 3D vector
of each grid cell in the DEM, 2) smoothing the normal vector field using a
filtering scheme that applies more weight to neighbours with lower angular difference
in surface normal vectors, and 3) uses the smoothed normal vector field to update
the elevations in the input DEM.</p>
<p>Sun et al.'s (2007) original method was intended to work on input point clouds and
fitted triangular irregular networks (TINs). The algorithm has been modified to
work with input raster DEMs instead. In so doing, this algorithm calculates surface
normal vectors from the planes fitted to 3 x 3 neighbourhoods surrounding each
grid cell, rather than the triangular facet. The normal vector field smoothing and
elevation updating procedures are also based on raster filtering operations. These
modifications make this tool more efficient than Sun's original method, but will
also result in a slightly different output than what would be achieved with Sun's
method.</p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Francioni* A, Cockburn JMH. 2019. LiDAR DEM smoothing and the preservation of
drainage features. <em>Remote Sensing</em>, 11(16), 1926; DOI: 10.3390/rs11161926.</p>
<p>Sun, X., Rosin, P., Martin, R., &amp; Langbein, F. (2007). Fast and effective feature-preserving
mesh denoising. <em>IEEE Transactions on Visualization &amp; Computer Graphics</em>, (5), 925-938.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--num_iter         </td><td> Number of iterations</td></tr>
<tr><td>--max_diff         </td><td> Maximum allowable absolute elevation change (optional)</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.feature_preserving_smoothing(
    dem, 
    output, 
    filter=11, 
    norm_diff=15.0, 
    num_iter=3, 
    max_diff=0.5, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FeaturePreservingSmoothing -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --filter=15 ^
--norm_diff=20.0 --num_iter=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/feature_preserving_smoothing.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/11/2017</p>
<p><a name="FetchAnalysis"></a></p>
<a class="header" href="#fetchanalysis" id="fetchanalysis"><h1>FetchAnalysis</h1></a>
<p>This tool creates a new raster in which each grid cell is assigned the distance, in meters, to the nearest
topographic obstacle in a specified direction. It is a modification of the algorithm described by Lapen and
Martz (1993). Unlike the original algorithm, Fetch Analysis is capable of analyzing fetch in any direction
from 0-360 degrees. The user must specify the name of an input digital elevation model (DEM) raster file, the
output raster name, a hypothetical wind direction, and a value for the height increment parameter. The algorithm
searches each grid cell in a path following the specified wind direction until the following condition is met:</p>
<blockquote>
<p><em>Z</em><sub>test</sub> &gt;= <em>Z</em><sub>core</sub> + <em>DI</em></p>
</blockquote>
<p>where <em>Z</em><sub>core</sub> is the elevation of the grid cell at which fetch is being determined, <em>Z</em><sub>test</sub>
is the elevation of the grid cell being tested as a topographic obstacle, <em>D</em> is the distance between the two
grid cells in meters, and <em>I</em> is the height increment in m/m. Lapen and Martz (1993) suggest values for <em>I</em> in
the range of 0.025 m/m to 0.1 m/m based on their study of snow re-distribution in low-relief agricultural
landscapes of the Canadian Prairies. If the directional search does not identify an obstacle grid cell before the
edge of the DEM is reached, the distance between the DEM edge and Zcore is entered. Edge distances are assigned
negative values to differentiate between these artificially truncated fetch values and those for which a valid
topographic obstacle was identified. Notice that linear interpolation is used to estimate the elevation of the
surface where a ray (i.e. the search path) does not intersect the DEM grid precisely at one of its nodes.</p>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to
operate for larger sized DEMs. This tool is parallelized to aid with computational efficiency. NoData valued
grid cells in the input image will be assigned NoData values in the output image. Fetch Analysis images are
best displayed using the blue-white-red bipolar palette to distinguish between the positive and negative
values that are present in the output.</p>
<p><em>Reference</em>:</p>
<p>Lapen, D. R., &amp; Martz, L. W. (1993). The measurement of two simple topographic indices of wind sheltering-exposure
from raster digital elevation models. Computers &amp; Geosciences, 19(6), 769-779.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#directionalrelief"><strong>DirectionalRelief</strong></a>, <a href="./geomorphometric_analysis.html#horizonangle"><strong>HorizonAngle</strong></a>, <a href="./geomorphometric_analysis.html#relativeaspect"><strong>RelativeAspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees in degrees</td></tr>
<tr><td>--hgt_inc          </td><td> Height increment value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fetch_analysis(
    dem, 
    output, 
    azimuth=0.0, 
    hgt_inc=0.05, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FetchAnalysis -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/fetch_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="FillMissingData"></a></p>
<a class="header" href="#fillmissingdata" id="fillmissingdata"><h1>FillMissingData</h1></a>
<p>This tool can be used to fill in small gaps in a raster or digital elevation model (DEM). The gaps,
or holes, must have recognized NoData values. If gaps do not currently have this characteristic, use
the <a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a> tool and ensure that the data are stored using a raster format that supports NoData
values. All valid, non-NoData values in the input raster will be assigned the same value in the output image.</p>
<p>The algorithm uses an inverse-distance weighted (IDW) scheme based on the valid values on the edge of
NoData gaps to estimate gap values. The user must specify the filter size (<code>--filter</code>), which determines
the size of gap that is filled, and the IDW weight (<code>--weight</code>).</p>
<p>The filter size, specified in grid cells, is used to determine how far the algorithm will search for valid,
non-NoData values. Therefore, setting a larger filter size allows for the filling of larger gaps in the input
raster.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Filter size (cells)</td></tr>
<tr><td>--weight           </td><td> IDW weight value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_missing_data(
    i, 
    output, 
    filter=11, 
    weight=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillMissingData -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 ^
--weight=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/fill_missing_data.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/06/2017</p>
<p><a name="FindRidges"></a></p>
<a class="header" href="#findridges" id="findridges"><h1>FindRidges</h1></a>
<p>This tool can be used to identify ridge cells in a digital elevation model (DEM). Ridge cells are those that
have lower neighbours either to the north and south or the east and west. Line thinning can optionally be used
to create single-cell wide ridge networks by specifying the <code>--line_thin</code> parameter.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--line_thin        </td><td> Optional flag indicating whether post-processing line-thinning should be performed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_ridges(
    dem, 
    output, 
    line_thin=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindRidges -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=out.tif --line_thin 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/find_ridges.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/12/2017</p>
<p><a name="Hillshade"></a></p>
<a class="header" href="#hillshade" id="hillshade"><h1>Hillshade</h1></a>
<p>This tool performs a hillshade operation (also called shaded relief) on an input digital elevation model (DEM).
The user must specify the  name of the input DEM and the output hillshade image name. Other parameters that must
be specified include the illumination source azimuth (<code>--azimuth</code>), or sun direction (0-360 degrees), the
illumination source altitude (<code>--altitude</code>; i.e. the elevation of the sun above the horizon, measured as an angle
from 0 to 90 degrees) and the Z conversion factor (<code>--zfactor</code>). The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The hillshade value (<em>HS</em>) of a DEM grid cell is calculate as:</p>
<blockquote>
<p><em>HS</em> = tan(<em>s</em>) / [1 - tan(<em>s</em>)<sup>2</sup>]<sup>0.5</sup> x [sin(<em>Alt</em>) / tan(<em>s</em>) - cos(<em>Alt</em>) x sin(<em>Az</em> - <em>a</em>)]</p>
</blockquote>
<p>where <em>s</em> and <em>a</em> are the local slope gradient and aspect (orientation) respectively and <em>Alt</em> and <em>Az</em>
are the illumination source altitude and azimuth respectively. Slope and aspect are calculated using
Horn's (1981) 3rd-order finate difference method.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Illumination source azimuth in degrees</td></tr>
<tr><td>--altitude         </td><td> Illumination source altitude in degrees</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hillshade(
    dem, 
    output, 
    azimuth=315.0, 
    altitude=30.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Hillshade -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --azimuth=315.0 --altitude=30.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="HorizonAngle"></a></p>
<a class="header" href="#horizonangle" id="horizonangle"><h1>HorizonAngle</h1></a>
<p>This tool calculates the horizon angle (<em>Sx</em>), i.e. the maximum slope along a specified azimuth (0-360 degrees) for
each grid cell in an input digital elevation model (DEM). Horizon angle is sometime referred to as the maximum upwind
slope in wind exposure/sheltering studies. Positive values can be considered sheltered with respect to the azimuth and
negative values are exposed. Thus, <em>Sx</em> is a measure of exposure to a wind from a specific direction. The algorithm works
by tracing a ray from each grid cell in the direction of interest and evaluating the slope for each location in which the
DEM grid is intersected by the ray. Linear interpolation is used to estimate the elevation of the surface where a ray does
not intersect the DEM grid precisely at one of its nodes.</p>
<p>The user is able to constrain the maximum search distance (<code>--max_dist</code>) for the ray tracing by entering a valid maximum
search distance value (in the same units as the X-Y coordinates of the input raster DEM). If the maximum search distance
is left blank, each ray will be traced to the edge of the DEM, which will add to the computational time.</p>
<p>Maximum upwind slope should not be calculated for very extensive areas over which the Earth's curvature must be taken into
account. Also, this index does not take into account the deflection of wind by topography. However, averaging the horizon
angle over a window of directions can yield a more robust measure of exposure, compensating for the deflection of wind from
its regional average by the topography. For example, if you are interested in measuring the exposure of a landscape to a
northerly wind, you could perform the following calculation:</p>
<blockquote>
<p>Sx(N) = [Sx(345)+Sx(350)+Sx(355)+Sx(0)+Sx(5)+Sx(10)+Sx(15)] / 7.0</p>
</blockquote>
<p>Ray-tracing is a highly computationally intensive task and therefore this tool may take considerable time to operate for
larger sized DEMs. Maximum upwind slope is best displayed using a Grey scale palette that is inverted.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Wind azimuth in degrees</td></tr>
<tr><td>--max_dist         </td><td> Optional maximum search distance (unspecified if none; in xy units)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.horizon_angle(
    dem, 
    output, 
    azimuth=0.0, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HorizonAngle -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --azimuth=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/horizon_angle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/07/2017</p>
<p><a name="HypsometricAnalysis"></a></p>
<a class="header" href="#hypsometricanalysis" id="hypsometricanalysis"><h1>HypsometricAnalysis</h1></a>
<p>This tool can be used to derive the hypsometric curve, or area-altitude curve, of one or more
input digital elevation models (DEMs) (<code>--inputs</code>). A hypsometric curve is a histogram or cumulative
distribution function of elevations in a geographical area.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#slopevselevationplot"><strong>SlopeVsElevationPlot</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input DEM files</td></tr>
<tr><td>--watershed        </td><td> Input watershed files (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hypsometric_analysis(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HypsometricAnalysis -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/hypsometric_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/01/2018</p>
<p><a name="MaxAnisotropyDev"></a></p>
<a class="header" href="#maxanisotropydev" id="maxanisotropydev"><h1>MaxAnisotropyDev</h1></a>
<p>Calculates the maximum anisotropy (directionality) in elevation deviation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=3, 
    step=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDev -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_anisotropy_dev.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: January 26, 2018</p>
<p><a name="MaxAnisotropyDevSignature"></a></p>
<a class="header" href="#maxanisotropydevsignature" id="maxanisotropydevsignature"><h1>MaxAnisotropyDevSignature</h1></a>
<p>Calculates the anisotropy in deviation from mean for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_anisotropy_dev_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAnisotropyDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_anisotropy_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dan Newman and John Lindsay</p>
<p><em>Created</em>: 27/03/2018</p>
<p><a name="MaxBranchLength"></a></p>
<a class="header" href="#maxbranchlength" id="maxbranchlength"><h1>MaxBranchLength</h1></a>
<p>Maximum branch length (<code>Bmax</code>) is the longest branch length between a grid cell's flowpath
and the flowpaths initiated at each of its neighbours. It can be conceptualized as the
downslope distance that a volume of water that is split into two portions by a drainage
divide would travel before reuniting.</p>
<p>If the two flowpaths of neighbouring grid cells do not intersect, <code>Bmax</code> is simply the
flowpath length from the starting cell to its terminus at the edge of the grid or a cell
with undefined flow direction (i.e. a pit cell either in a topographic depression or at
the edge of a major body of water).</p>
<p>The pattern of <code>Bmax</code> derived from a DEM should be familiar to anyone who has interpreted
upslope contributing area images. In fact, <code>Bmax</code> can be thought of as the complement of
upslope contributing area. Whereas contributing area is greatest along valley bottoms and lowest at
drainage divides, <code>Bmax</code> is greatest at divides and lowest along channels. The two topographic
attributes are also distinguished by their units of measurements; <code>Bmax</code> is a length rather
than an area. The presence of a major drainage divide between neighbouring grid cells is apparent in
a <code>Bmax</code> image as a linear feature, often two grid cells wide, of relatively high values. This
property makes <code>Bmax</code> a useful land surface parameter for mapping ridges and divides.</p>
<p><code>Bmax</code> is useful in the study of landscape structure, particularly with respect to drainage patterns.
The index gives the relative significance of a specific location along a divide, with respect to the
dispersion of materials across the landscape, in much the same way that stream ordering can be used
to assess stream size.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#flowlengthdiff"><strong>FlowLengthDiff</strong></a></p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Seibert J. 2013. Measuring the significance of a divide to local drainage patterns.
International Journal of Geographical Information Science, 27: 1453-1468. DOI:
10.1080/13658816.2012.705289</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_branch_length(
    dem, 
    output, 
    log=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxBranchLength -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_branch_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 9, 2017</p>
<p><a name="MaxDifferenceFromMean"></a></p>
<a class="header" href="#maxdifferencefrommean" id="maxdifferencefrommean"><h1>MaxDifferenceFromMean</h1></a>
<p>Calculates the maximum difference from mean elevation over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DIFFmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DIFFmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_difference_from_mean(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDifferenceFromMean -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_diff_from_mean.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/08/2018</p>
<p><a name="MaxDownslopeElevChange"></a></p>
<a class="header" href="#maxdownslopeelevchange" id="maxdownslopeelevchange"><h1>MaxDownslopeElevChange</h1></a>
<p>This tool calculates the maximum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#mindownslopeelevchange"><strong>MinDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MaxElevDevSignature"></a></p>
<a class="header" href="#maxelevdevsignature" id="maxelevdevsignature"><h1>MaxElevDevSignature</h1></a>
<p>Calculates the maximum elevation deviation over a range of spatial scales and for a set of points.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elev_dev_signature(
    dem, 
    points, 
    output, 
    min_scale, 
    max_scale, 
    step=10, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevDevSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.tif ^
--output=topo_position.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_elev_dev_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: March 1, 2018</p>
<p><a name="MaxElevationDeviation"></a></p>
<a class="header" href="#maxelevationdeviation" id="maxelevationdeviation"><h1>MaxElevationDeviation</h1></a>
<p>This tool can be used to calculate the maximum deviation from mean elevation, <em>DEVmax</em> (Lindsay et al. 2015) for each
grid cell in a digital elevation model (DEM) across a range specified spatial scales. <em>DEV</em>
is an elevation residual index and is essentially equivalent to a local elevation z-score.
This attribute measures the <em>relative topographic position</em> as a fraction of
local relief, and so is normalized to the local surface roughness. The multi-scaled calculation
of <em>DEVmax</em> utilizes an integral image approach (Crow, 1984) to ensure highly efficient
filtering that is invariant with filter size, which is the algorithm characteristic that allows for
this densely sampled multi-scale analysis. In this way, <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> allows users
to estimate the locally optimal scale with which to estimate <em>DEV</em> on a pixel-by-pixel basis.
This multi-scaled version of local topographic position can reveal significant terrain
characteristics and can aid with soil, vegetation, landform, and other mapping applications
that depend on geomorphometric characterization.</p>
<p>The user must specify the name (<code>--dem</code>) of the input digital elevation model (DEM). The range of scales that are
evaluated in calculating <em>DEVmax</em> are determined by the user-specified <code>--min_scale</code>, <code>--max_scale</code>, and <code>--step</code>
parameters. All filter radii between the minimum and maximum scales, increasing by <code>step</code>, will be evaluated.
The scale parameters are in units of grid cells and specify kernel size &quot;radii&quot; (<em>r</em>), such that:</p>
<blockquote>
<p><em>d</em> = 2<em>r</em> + 1</p>
</blockquote>
<p>That is, a radii of 1, 2, 3... yields a square filters of dimension (<em>d</em>) 3 x 3, 5 x 5, 7 x 7...</p>
<p><em>DEV</em> is estimated at each tested filter size and every grid cell is assigned the maximum <em>DEV</em> value
across the evaluated scales.</p>
<p>The user must specify the file names of two output rasters, including the magnitude (<em>DEVmax</em>) and a
second raster the assigns each pixel the scale at which <em>DEVmax</em> is encountered (<em>DEVscale</em>). The
<em>DEVscale</em> raster can be very useful for revealing multi-scale landscape structure.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#maxdifferencefrommean"><strong>MaxDifferenceFromMean</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster DEVmax magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster DEVmax scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_elevation_deviation(
    dem, 
    out_mag, 
    out_scale, 
    min_scale, 
    max_scale, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxElevationDeviation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=DEVmax_mag.tif ^
--out_scale=DEVmax_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/max_elev_deviation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 20, 2017</p>
<p><a name="MinDownslopeElevChange"></a></p>
<a class="header" href="#mindownslopeelevchange" id="mindownslopeelevchange"><h1>MinDownslopeElevChange</h1></a>
<p>This tool calculates the minimum elevation drop between each grid cell and its neighbouring cells within
a digital elevation model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output
(<code>--output</code>) raster name.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#maxdownslopeelevchange"><strong>MaxDownslopeElevChange</strong></a>, <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_downslope_elev_change(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinDownslopeElevChange -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/min_downslope_elev_change.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MultiscaleRoughness"></a></p>
<a class="header" href="#multiscaleroughness" id="multiscaleroughness"><h1>MultiscaleRoughness</h1></a>
<p>Calculates surface roughness over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster roughness scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness(
    dem, 
    out_mag, 
    out_scale, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughness -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_roughness.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/02/2018</p>
<p><a name="MultiscaleRoughnessSignature"></a></p>
<a class="header" href="#multiscaleroughnesssignature" id="multiscaleroughnesssignature"><h1>MultiscaleRoughnessSignature</h1></a>
<p>Calculates the surface roughness for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--max_scale        </td><td> Maximum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_roughness_signature(
    dem, 
    points, 
    output, 
    max_scale, 
    min_scale=1, 
    step=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleRoughnessSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_roughness_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/02/2018</p>
<p><a name="MultiscaleStdDevNormals"></a></p>
<a class="header" href="#multiscalestddevnormals" id="multiscalestddevnormals"><h1>MultiscaleStdDevNormals</h1></a>
<p>Calculates surface roughness over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_mag          </td><td> Output raster roughness magnitude file</td></tr>
<tr><td>--out_scale        </td><td> Output raster roughness scale file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
<tr><td>--num_steps        </td><td> Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td> Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_std_dev_normals(
    dem, 
    out_mag, 
    out_scale, 
    min_scale=1, 
    step=1, 
    num_steps=10, 
    step_nonlinearity=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleStdDevNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --step=5 ^
--num_steps=100 --step_nonlinearity=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_std_dev_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/06/2019</p>
<p><a name="MultiscaleStdDevNormalsSignature"></a></p>
<a class="header" href="#multiscalestddevnormalssignature" id="multiscalestddevnormalssignature"><h1>MultiscaleStdDevNormalsSignature</h1></a>
<p>Calculates the surface roughness for points over a range of spatial scales.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--min_scale        </td><td> Minimum search neighbourhood radius in grid cells</td></tr>
<tr><td>--step             </td><td> Step size as any positive non-zero integer</td></tr>
<tr><td>--num_steps        </td><td> Number of steps</td></tr>
<tr><td>--step_nonlinearity</td><td> Step nonlinearity factor (1.0-2.0 is typical)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_std_dev_normals_signature(
    dem, 
    points, 
    output, 
    min_scale=1, 
    step=1, 
    num_steps=10, 
    step_nonlinearity=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleStdDevNormalsSignature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --points=sites.shp ^
--output=roughness.html --min_scale=1 --step=5 --num_steps=100 ^
--step_nonlinearity=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_std_dev_normals_signature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/06/2019</p>
<p><a name="MultiscaleTopographicPositionImage"></a></p>
<a class="header" href="#multiscaletopographicpositionimage" id="multiscaletopographicpositionimage"><h1>MultiscaleTopographicPositionImage</h1></a>
<p>This tool creates a multiscale topographic position (MTP) image (<a href="https://www.uoguelph.ca/%7Ehydrogeo/pubs/UpdatedPosterMapSm.png">see here for an
example</a>) from three DEV<sub>max</sub> rasters of differing
spatial scale ranges. Specifically, <a href="./geomorphometric_analysis.html#multiscaletopographicpositionimage"><strong>MultiscaleTopographicPositionImage</strong></a> takes three DEV<sub>max</sub> <em>magnitude</em>
rasters, created using the <a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a> tool, as inputs. The three inputs should correspond to the elevation
deviations in the local (<code>--local</code>), meso (<code>--meso</code>), and broad (<code>--broad</code>) scale ranges and will be forced into the
blue, green, and red colour components of the colour composite output (<code>--output</code>) raster. The image lightness value
(<code>--lightness</code>) controls the overall brightness of the output image, as depending on the topography and scale ranges,
these images can appear relatively dark. Higher values result in brighter, more colourful output images.</p>
<p>The output images can take some training to interpret correctly and a detailed explanation can be found in Lindsay et al.
(2015). Sites within the landscape that occupy prominent topographic positions, either
low-lying or elevated, will be apparent by their bright colouring in the MTP image. Those that are coloured more strongly in
the blue are promient at the local scale range; locations that are more strongly green coloured are promient at the meso scale;
and bright reds in the MTP image are associated with broad-scale landscape prominence. Of course, combination colours are also possible when
topography is elevated or low-lying across multiple scale ranges. For example, a yellow area would indicated a site of prominent
topographic position across the meso and broadest scale ranges.</p>
<p><em>Reference</em>:</p>
<p>Lindsay J, Cockburn J, Russell H. 2015. An integral image approach to performing multi-scale
topographic position analysis. Geomorphology, 245: 51-61.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#maxelevationdeviation"><strong>MaxElevationDeviation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--local            </td><td> Input local-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--meso             </td><td> Input meso-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>--broad            </td><td> Input broad-scale topographic position (DEVmax) raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--lightness        </td><td> Image lightness value (default is 1.2)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiscale_topographic_position_image(
    local, 
    meso, 
    broad, 
    output, 
    lightness=1.2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MultiscaleTopographicPositionImage -v ^
--wd=&quot;/path/to/data/&quot; --local=DEV_local.tif --meso=DEV_meso.tif ^
--broad=DEV_broad.tif -o=output.tif --lightness=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/multiscale_topographic_position_image.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2017</p>
<p><a name="NumDownslopeNeighbours"></a></p>
<a class="header" href="#numdownslopeneighbours" id="numdownslopeneighbours"><h1>NumDownslopeNeighbours</h1></a>
<p>This tool calculates the number of downslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output image can therefore have values raning from 0 to 8. A
raster grid cell with eight downslope neighbours is a peak and a cell with zero downslope neighbours is a pit. This
tool can be used with the <a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a> tool to assess the degree of local flow divergence/convergence.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#numupslopeneighbours"><strong>NumUpslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_downslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumDownslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/num_downslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="NumUpslopeNeighbours"></a></p>
<a class="header" href="#numupslopeneighbours" id="numupslopeneighbours"><h1>NumUpslopeNeighbours</h1></a>
<p>This tool calculates the number of upslope neighbours of each grid cell in a raster digital elevation model (DEM).
The user must specify the name of the input DEM (<code>--dem</code>) and the output (<code>--output</code>) raster name. The tool examines
the eight neighbouring cells for each grid cell in a the DEM and counts the number of neighbours with an elevation
less than the centre cell of the 3 x 3 window. The output raster can therefore have values ranging from 0 to 8, although
in a DEM that has been hydrologically conditioned (i.e. depressions and flats removed), the values of the output will
not exceed seven. This tool can be used with the <a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a> tool to assess the degree of local flow
divergence/convergence.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#numdownslopeneighbours"><strong>NumDownslopeNeighbours</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_upslope_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumUpslopeNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/num_upslope_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PennockLandformClass"></a></p>
<a class="header" href="#pennocklandformclass" id="pennocklandformclass"><h1>PennockLandformClass</h1></a>
<p>Tool can be used to perform a simple landform classification based on measures of slope gradient
and curvature derived from a user-specified digital elevation model (DEM). The classification
scheme is based on the method proposed by Pennock, Zebarth, and DeJong (1987). The scheme divides
a landscape into seven element types, including: convergent footslopes (CFS), divergent footslopes
(DFS), convergent shoulders (CSH), divergent shoulders (DSH), convergent backslopes (CBS), divergent
backslopes (DBS), and level terrain (L). The output raster image will record each of these base element
types as:</p>
<table><thead><tr><th>Element Type  </th><th>  Code</th></tr></thead><tbody>
<tr><td>CFS           </td><td>  1</td></tr>
<tr><td>DFS           </td><td>  2</td></tr>
<tr><td>CSH           </td><td>  3</td></tr>
<tr><td>DSH           </td><td>  4</td></tr>
<tr><td>CBS           </td><td>  5</td></tr>
<tr><td>DBS           </td><td>  6</td></tr>
<tr><td>L             </td><td>  7</td></tr>
</tbody></table>
<p>The definition of each of the elements, based on the original Pennock et al. (1987) paper, is
as follows:</p>
<table><thead><tr><th align="left">    PROFILE             </th><th align="left">   GRADIENT    </th><th>   PLAN         </th><th>  Element </th></tr></thead><tbody>
<tr><td align="left"> Concave ( -0.10)       </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CFS     </td></tr>
<tr><td align="left"> Concave ( -0.10)       </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DFS     </td></tr>
<tr><td align="left"> Convex (&gt;0.10)         </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CSH     </td></tr>
<tr><td align="left"> Convex (&gt;0.10)         </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DSH     </td></tr>
<tr><td align="left"> Linear (-0.10...0.10)  </td><td align="left">  High &gt;3.0    </td><td align="left"> Concave 0.0    </td><td align="left">  CBS     </td></tr>
<tr><td align="left"> Linear (-0.10...0.10)  </td><td align="left">  High &gt;3.0    </td><td align="left"> Convex &gt;0.0    </td><td align="left">  DBS     </td></tr>
<tr><td align="left"> --                     </td><td align="left">  Low 3.0      </td><td align="left"> --             </td><td align="left">  L       </td></tr>
</tbody></table>
<p>Where PROFILE is profile curvature, GRADIENT is the slope gradient, and PLAN is the plan curvature.
Note that these values are likely landscape and data specific and can be adjusted by the user.
Landscape classification schemes that are based on terrain attributes are highly sensitive to
short-range topographic variability (i.e. roughness) and can benefit from pre-processing the DEM
with a smoothing filter to reduce the effect of surface roughness and emphasize the longer-range
topographic signal. The <a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a> tool
offers excellent performance in smoothing DEMs without removing the sharpness of breaks-in-slope.</p>
<p><em>Reference</em>:</p>
<p>Pennock, D.J., Zebarth, B.J., and DeJong, E. (1987) Landform classification and soil distribution
in hummocky terrain, Saskatchewan, Canada. Geoderma, 40: 297-315.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#featurepreservingsmoothing"><strong>FeaturePreservingSmoothing</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--slope            </td><td> Slope threshold value, in degrees (default is 3.0)</td></tr>
<tr><td>--prof             </td><td> Profile curvature threshold value (default is 0.1)</td></tr>
<tr><td>--plan             </td><td> Plan curvature threshold value (default is 0.0)</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.pennock_landform_class(
    dem, 
    output, 
    slope=3.0, 
    prof=0.1, 
    plan=0.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PennockLandformClass -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif --slope=3.0 ^
--prof=0.1 --plan=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/pennock_landform_class.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 12, 2017</p>
<p><a name="PercentElevRange"></a></p>
<a class="header" href="#percentelevrange" id="percentelevrange"><h1>PercentElevRange</h1></a>
<p>Percent elevation range (PER) is a measure of local topographic position (LTP). It expresses the vertical
position for a digital elevation model (DEM) grid cell (z<sub>0</sub>) as the percentage of the
elevation range within the neighbourhood filter window, such that:</p>
<blockquote>
<p>PER = z<sub>0</sub> / (z<sub>max</sub> - z<sub>min</sub>) x 100</p>
</blockquote>
<p>where z<sub>0</sub> is the elevation of the window's center grid cell, z<sub>max</sub> is the maximum
neighbouring elevation, and z<sub>min</sub> is the minimum neighbouring elevation.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>Compared with <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a> and <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, PER is a less robust measure of LTP that is susceptible
to outliers in neighbouring elevations (e.g. the presence of off-terrain objects in the DEM).</p>
<p><em>References</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic position
for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_elev_range(
    dem, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentElevRange -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/percent_elev_range.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="PlanCurvature"></a></p>
<a class="header" href="#plancurvature" id="plancurvature"><h1>PlanCurvature</h1></a>
<p>This tool calculates the plan curvature (i.e. contour curvature), or the rate of change in
aspect along a contour line, from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Plan curvature characterizes the
degree of flow convergence or divergence within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Plan curvature is negative for diverging flow along ridges and positive for
convergent areas, e.g. along valley bottoms.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.plan_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PlanCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/plan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/06/2017</p>
<p><a name="Profile"></a></p>
<a class="header" href="#profile" id="profile"><h1>Profile</h1></a>
<p>This tool can be used to plot the data profile, along a set of one or more vector lines (<code>--lines</code>), in
an input (<code>--surface</code>) digital elevation model (DEM), or other surface model. The data profile plots
surface height (y-axis) against distance along profile (x-axis). The tool outputs an interactive SVG line
graph embedded in an HTML document (<code>--output</code>). If the vector lines file contains multiple line features,
the output plot will contain each of the input profiles.</p>
<p>If you want to extract the <a href="http://www.fao.org/docrep/003/X6841E/X6841E02.HTM">longitudinal profile</a> of a river,
use the <a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a>, <a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--lines            </td><td> Input vector line file</td></tr>
<tr><td>--surface          </td><td> Input raster surface file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile(
    lines, 
    surface, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Profile -v --wd=&quot;/path/to/data/&quot; ^
--lines=profile.shp --surface=dem.tif -o=profile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/profile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/02/2018</p>
<p><a name="ProfileCurvature"></a></p>
<a class="header" href="#profilecurvature" id="profilecurvature"><h1>ProfileCurvature</h1></a>
<p>This tool calculates the profile curvature, or the rate of change in slope along a flow line,
from a digital elevation model (DEM). Curvature is the second
derivative of the topographic surface defined by a DEM. Profile curvature characterizes the
degree of downslope acceleration or deceleration within the landscape (Gallant and Wilson, 2000).
The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image.
WhiteboxTools reports curvature in degrees multiplied by 100 for easier interpretation because
curvature values are typically very small. The
<em>Z conversion factor</em> (<code>--zfactor</code>) is only important when the vertical and horizontal units
are not the same in the DEM. When this is the case, the algorithm will multiply each
elevation in the DEM by the Z Conversion Factor. If the DEM is in the geographic coordinate
system (latitude and longitude), the following equation is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The algorithm uses the same formula for the calculation of plan curvature as Gallant and
Wilson (2000). Profile curvature is negative for slope increasing downhill (convex flow profile,
typical of upper slopes) and positive for slope decreasing downhill (concave, typical of lower slopes).</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.profile_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ProfileCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/prof_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/062017</p>
<p><a name="RelativeAspect"></a></p>
<a class="header" href="#relativeaspect" id="relativeaspect"><h1>RelativeAspect</h1></a>
<p>This tool creates a new raster in which each grid cell is assigned the terrain aspect relative to a user-specified
direction (<code>--azimuth</code>). Relative terrain aspect is the angular distance (measured in degrees) between the land-surface
aspect and the assumed regional wind azimuth (Bohner and Antonic, 2007). It is bound between 0-degrees (windward direction)
and 180-degrees (leeward direction). Relative terrain aspect is the simplest of the measures of topographic exposure to
wind, taking into account terrain orientation only and neglecting the influences of topographic shadowing by distant
landforms and the deflection of wind by topography.</p>
<p>The user must specify the name of a digital elevation model (DEM) (<code>--dem</code>) and an azimuth (i.e. a wind direction). The
Z Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the same in the DEM.
When this is the case, the algorithm will multiply each elevation in the DEM by the Z Conversion Factor.</p>
<p><em>Reference</em>:</p>
<p>Böhner, J., and Antonić, O. (2009). Land-surface parameters specific to topo-climatology. Developments in Soil
Science, 33, 195-226.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--azimuth          </td><td> Illumination source azimuth</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_aspect(
    dem, 
    output, 
    azimuth=0.0, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeAspect -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --azimuth=180.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_aspect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/06/2017</p>
<p><a name="RelativeStreamPowerIndex"></a></p>
<a class="header" href="#relativestreampowerindex" id="relativestreampowerindex"><h1>RelativeStreamPowerIndex</h1></a>
<p>This tool can be used to calculate the relative stream power (<em>RSP</em>) index. This index is directly related
to the stream power if the assumption can be made that discharge is directly proportional to upslope
contributing area (<em>A<sub>s</sub></em>; <code>--sca</code>). The index is calculated as:</p>
<blockquote>
<p><em>RSP</em> = <em>A<sub>s</sub></em><sup><em>p</em></sup> × tan(β)</p>
</blockquote>
<p>where <em>A<sub>s</sub></em> is the specific catchment area (i.e. the upslope contributing area per unit
contour length) estimated using one of the available flow accumulation algorithms; β is the local
slope gradient in degrees (<code>--slope</code>); and, <em>p</em> (<code>--exponent</code>) is a user-defined exponent term that
controls the location-specific relation between contributing area and discharge. Notice that
<em>A<sub>s</sub></em> must not be log-transformed prior to being used; <em>A<sub>s</sub></em> is commonly
log-transformed to enhance visualization of the data. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a> <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--exponent         </td><td> SCA exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_stream_power_index(
    sca, 
    slope, 
    output, 
    exponent=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeStreamPowerIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --exponent=1.1 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_stream_power_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="RelativeTopographicPosition"></a></p>
<a class="header" href="#relativetopographicposition" id="relativetopographicposition"><h1>RelativeTopographicPosition</h1></a>
<p>Relative topographic position (RTP) is an index of local topographic position (i.e. how
elevated or low-lying a site is relative to its surroundings) and is a modification of percent
elevation range (PER; <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a>) and accounts for the elevation distribution. Rather than
positioning the central cell's elevation solely between the filter extrema, RTP is a piece-wise
function that positions the central elevation relative to the minimum (z<sub>min</sub>), mean (μ),
and maximum values (z<sub>max</sub>), within a local neighbourhood of a user-specified size (<code>--filterx</code>,
<code>--filtery</code>), such that:</p>
<blockquote>
<p>RTP = (z<sub>0</sub> − μ) / (μ − z<sub>min</sub>), if z<sub>0</sub> &lt; μ</p>
<p>OR</p>
<p>RTP = (z<sub>0</sub> − μ) / (z<sub>max</sub> - μ), if z<sub>0</sub> &gt;= μ
</p>
</blockquote>
<p>The resulting index is bound by the interval [−1, 1], where the sign indicates if the cell is above or below
than the filter mean. Although RTP uses the mean to define two linear functions, the reliance on the filter
extrema is expected to result in sensitivity to outliers. Furthermore, the use of the mean implies assumptions
of unimodal and symmetrical elevation distribution.</p>
<p>In many cases, Elevation Percentile (<a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>) and deviation from mean elevation (<a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>)
provide more suitable and robust measures of relative topographic position.</p>
<p><em>Reference</em>:</p>
<p>Newman, D. R., Lindsay, J. B., and Cockburn, J. M. H. (2018). Evaluating metrics of local topographic
position for multiscale geomorphometric analysis. Geomorphology, 312, 40-50.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#difffrommeanelev"><strong>DiffFromMeanElev</strong></a>, <a href="./geomorphometric_analysis.html#elevpercentile"><strong>ElevPercentile</strong></a>, <a href="./geomorphometric_analysis.html#percentelevrange"><strong>PercentElevRange</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.relative_topographic_position(
    dem, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelativeTopographicPosition -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/relative_topographic_position.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><a name="RemoveOffTerrainObjects"></a></p>
<a class="header" href="#removeoffterrainobjects" id="removeoffterrainobjects"><h1>RemoveOffTerrainObjects</h1></a>
<p>This tool can be used to create a bare-earth DEM from a fine-resolution digital surface model. The
tool is typically applied to LiDAR DEMs which frequently contain numerous off-terrain objects (OTOs) such
as buildings, trees and other vegetation, cars, fences and other anthropogenic objects. The algorithm
works by finding and removing steep-sided peaks within the DEM. All peaks within a sub-grid, with a
dimension of the user-specified maximum OTO size (<code>--filter</code>), in pixels, are identified and removed.
Each of the edge cells of the peaks are then examined to see if they have a slope that is less than the
user-specified minimum OTO edge slope (<code>--slope</code>) and a back-filling procedure is used. This ensures that
OTOs are distinguished from natural topographic features such as hills. The DEM is preprocessed using a
white top-hat transform, such that elevations are normalized for the underlying ground surface.</p>
<p>Note that this tool is appropriate to apply to rasterized LiDAR DEMs. Use the <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a>
tool to remove or classify OTOs within a LiDAR point-cloud.</p>
<p><em>Reference</em>:</p>
<p>J.B. Lindsay (2018) A new method for the removal of off-terrain objects from LiDAR-derived raster surface
models. Available online, DOI: <a href="https://www.researchgate.net/publication/323003064_A_new_method_for_the_removal_of_off-terrain_objects_from_LiDAR-derived_raster_surface_models">10.13140/RG.2.2.21226.62401</a></p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a>, <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input, --dem</td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Filter size (cells)</td></tr>
<tr><td>--slope            </td><td> Slope threshold value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_off_terrain_objects(
    dem, 
    output, 
    filter=11, 
    slope=15.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemoveOffTerrainObjects -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=bare_earth_DEM.tif ^
--filter=25 --slope=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/remove_off_terrain_objects.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/06/2017</p>
<p><a name="RuggednessIndex"></a></p>
<a class="header" href="#ruggednessindex" id="ruggednessindex"><h1>RuggednessIndex</h1></a>
<p>The terrain ruggedness index (TRI) is a measure of local topographic relief. The TRI calculates
the root-mean-square-deviation (RMSD) for each grid cell in a digital elevation model (DEM),
calculating the residuals (i.e. elevation differences) between a grid cell and its eight neighbours.
Notice that, unlike the output of this tool, the original Riley et al. (1999) TRI did not normalize
for the number of cells in the local window (i.e. it is a root-square-deviation only). However,
using the mean has the advantage of allowing for the varying number of neighbouring cells along
the grid edges and in areas bordering NoData cells. This modification does however imply that the
ouput of this tool cannot be directly compared with the index ranges of level to extremely rugged
terrain provided in Riley et al. (1999)</p>
<p><em>Reference</em>:</p>
<p>Riley, S. J., DeGloria, S. D., and Elliot, R. (1999). Index that quantifies topographic heterogeneity.
<em>Intermountain Journal of Sciences</em>, 5(1-4), 23-27.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#relativetopographicposition"><strong>RelativeTopographicPosition</strong></a>, <a href="./geomorphometric_analysis.html#devfrommeanelev"><strong>DevFromMeanElev</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ruggedness_index(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RuggednessIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/ruggedness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="SedimentTransportIndex"></a></p>
<a class="header" href="#sedimenttransportindex" id="sedimenttransportindex"><h1>SedimentTransportIndex</h1></a>
<p>This tool calculates the sediment transport index, or sometimes, length-slope (<em>LS</em>)
factor, based on input specific contributing area (<em>A<sub>s</sub></em>, i.e. the upslope
contributing area per unit contour length; <code>--sca</code>) and slope gradient
(β, measured in degrees; <code>--slope</code>) rasters. Moore et al. (1991) state that the physical potential for
sheet and rill erosion in upland catchments can be evaluated by the product <em>R K LS</em>,
a component of the Universal Soil Loss Equation (USLE), where <em>R</em> is a rainfall and
runoff erosivity factor, <em>K</em> is a soil erodibility factor, and <em>LS</em> is the length-slope
factor that accounts for the effects of topography on erosion. To predict erosion at a
point in the landscape the LS factor can be written as:</p>
<blockquote>
<p><em>LS</em> = (<em>n</em> + 1)(<em>A<sub>s</sub></em> / 22.13)<sup><em>n</em></sup>(sin(β) / 0.0896)<sup><em>m</em></sup></p>
</blockquote>
<p>where <em>n</em> = 0.4 (<code>--sca_exponent</code>) and <em>m</em> = 1.3 (<code>--slope_exponent</code>) in its original formulation.</p>
<p>This index is derived from unit stream-power theory and is sometimes used in place of the
length-slope factor in the revised universal soil loss equation (RUSLE) for slope lengths
less than 100 m and slope less than 14 degrees. Like many hydrological land-surface
parameters <a href="./geomorphometric_analysis.html#sedimenttransportindex"><strong>SedimentTransportIndex</strong></a> assumes that contributing area is directly related to
discharge. Notice that <em>A<sub>s</sub></em> must not be log-transformed prior to being used;
<em>A<sub>s</sub></em> is commonly log-transformed to enhance visualization of the data. Also,
<em>A<sub>s</sub></em> can be derived using any of the available flow accumulation tools, alghough
better results usually result from application of multiple-flow direction algorithms such
as <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a> and <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a>. The slope raster can be created from the base
digital elevation model (DEM) using the <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a> tool. The input images must have the same grid dimensions.</p>
<p><em>Reference</em>:</p>
<p>Moore, I. D., Grayson, R. B., and Ladson, A. R. (1991). Digital terrain modelling:
a review of hydrological, geomorphological, and biological applications. <em>Hydrological
processes</em>, 5(1), 3-30.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#relativestreampowerindex"><strong>RelativeStreamPowerIndex</strong></a>, <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sca_exponent     </td><td> SCA exponent value</td></tr>
<tr><td>--slope_exponent   </td><td> Slope exponent value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sediment_transport_index(
    sca, 
    slope, 
    output, 
    sca_exponent=0.4, 
    slope_exponent=1.3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SedimentTransportIndex -v ^
--wd=&quot;/path/to/data/&quot; --sca='flow_accum.tif' ^
--slope='slope.tif' -o=output.tif --sca_exponent=0.5 ^
--slope_exponent=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/sediment_transport_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="Slope"></a></p>
<a class="header" href="#slope" id="slope"><h1>Slope</h1></a>
<p>This tool calculates slope gradient (i.e. slope steepness in degrees) for each grid cell
in an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>) and the output raster image. The <em>Z conversion factor</em> is only important
when the vertical and horizontal units are not the same in the DEM. When this is the case,
the algorithm will multiply each elevation in the DEM by the Z conversion factor. If the
DEM is in the geographic coordinate system (latitude and longitude), the following equation
is used:</p>
<blockquote>
<p>zfactor = 1.0 / (113200.0 x cos(mid_lat))</p>
</blockquote>
<p>where <code>mid_lat</code> is the latitude of the centre of the raster, in radians.</p>
<p>The tool uses Horn's (1981) 3rd-order finite difference method to estimate slope. Given
the following clock-type grid cell numbering scheme (Gallant and Wilson, 2000),</p>
<p>|  7  |  8  |  1  | <br />
|  6  |  9  |  2  | <br />
|  5  |  4  |  3  |</p>
<blockquote>
<p>slope = arctan(f<sub>x</sub><sup>2</sup> + f<sub>y</sub><sup>2</sup>)<sup>0.5</sup></p>
</blockquote>
<p>where,</p>
<blockquote>
<p>f<sub>x</sub> = (z<sub>3</sub> - z<sub>5</sub> + 2(z<sub>2</sub> - z<sub>6</sub>) + z<sub>1</sub> - z<sub>7</sub>) / 8 * Δx</p>
</blockquote>
<p>and,</p>
<blockquote>
<p>f<sub>y</sub> = (z<sub>7</sub> - z<sub>5</sub> + 2(z<sub>8</sub> - z<sub>4</sub>) + z<sub>1</sub> - z<sub>3</sub>) / * Δy</p>
</blockquote>
<p>Δx and Δy are the grid resolutions in the x and y direction respectively</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a>, <a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Slope -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="SlopeVsElevationPlot"></a></p>
<a class="header" href="#slopevselevationplot" id="slopevselevationplot"><h1>SlopeVsElevationPlot</h1></a>
<p>This tool can be used to create a slope versus average elevation plot for one or more digital elevation models (DEMs).
Similary to a hypsometric analysis (<a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a>), the slope-elevation relation can reveal the basic
topographic character of a site. The output of this analysis is an HTML document (<code>--output</code>) that contains the
slope-elevation chart. The tool can plot multiple slope-elevation analyses on the same chart by specifying multiple
input DEM files (<code>--inputs</code>). Each input DEM can have an optional watershed in which the slope-elevation analysis is
confined by specifying the optional <code>--watershed</code> flag. If multiple input DEMs are used, and a watershed is used to
confine the analysis to a sub-area, there must be the same number of input raster watershed files as input DEM files.
The order of the DEM and watershed files must the be same (i.e. the first DEM file must correspond to the first
watershed file, the second DEM file to the second watershed file, etc.). Each watershed file may contain one or more
watersheds, designated by unique identifiers.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#hypsometricanalysis"><strong>HypsometricAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input DEM files</td></tr>
<tr><td>--watershed        </td><td> Input watershed files (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.slope_vs_elevation_plot(
    inputs, 
    output, 
    watershed=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SlopeVsElevationPlot -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;DEM1.tif;DEM2.tif&quot; ^
--watershed=&quot;ws1.tif;ws2.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/slope_vs_elev_plot.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/02/2018</p>
<p><a name="SphericalStdDevOfNormals"></a></p>
<a class="header" href="#sphericalstddevofnormals" id="sphericalstddevofnormals"><h1>SphericalStdDevOfNormals</h1></a>
<p>This tool can be used to calculate the spherical standard deviation of the distribution of surface normals
for an input digital elevation model (DEM; <code>--dem</code>). This is a measure of the angular dispersion of the surface
normal vectors within a local neighbourhood of a specified size (<code>--filter</code>). <a href="./geomorphometric_analysis.html#sphericalstddevofnormals"><strong>SphericalStdDevOfNormals</strong></a>
is therefore a measure of surface shape complexity, texture, and roughness. The <a href="https://en.wikipedia.org/wiki/Directional_statistics#Measures_of_location_and_spread">
spherical standard deviation</a> (<em>s</em>) is defined as:</p>
<blockquote>
<p><em>s</em> = √[-2ln(<em>R</em> / <em>N</em>)] × 180 / π</p>
</blockquote>
<p>where <em>R</em> is the resultant vector length and <em>N</em> is the number of unit normal vectors
within the local neighbourhood. <em>s</em> is measured in degrees and is zero for simple planes and increases
infinitely with increasing surface complexity or roughness. Note that this formulation of the spherical
standard deviation assumes an underlying wrapped normal distribution.</p>
<p>The local neighbourhood size (<code>--filter</code>) must be any odd integer equal to or greater than three. Grohmann et al. (2010) found that
vector dispersion, a related measure of angular dispersion, increases monotonically with scale. This is the result
of the angular dispersion measure integrating (accumulating) all of the surface variance of smaller scales up to the
test scale. A more interesting scale relation can therefore be estimated by isolating the amount of surface complexity
associated with specific scale ranges. That is, at large spatial scales, <em>s</em> should reflect
the texture of large-scale landforms rather than the accumulated complexity at all smaller scales, including
microtopographic roughness. As such, <strong><em>this tool normalizes the surface complexity of scales that are smaller than
the filter size by applying Gaussian blur</em></strong> (with a standard deviation of one-third the filter size) to the DEM prior
to calculating <em>R</em>. In this way, the resulting distribution is able to isolate and highlight
the surface shape complexity associated with landscape features of a similar scale to that of the filter size.</p>
<p>This tool makes extensive use of <a href="https://en.wikipedia.org/wiki/Summed-area_table">integral images</a>
(i.e. summed-area tables) and parallel processing to ensure computational efficiency. It may, however, require
substantial memory resources when applied to larger DEMs.</p>
<p><em>References</em>:</p>
<p>Grohmann, C. H., Smith, M. J., &amp; Riccomini, C. (2010). Multiscale analysis of topographic surface roughness in the
Midland Valley, Scotland. <em>IEEE Transactions on Geoscience and Remote Sensing</em>, 49(4), 1200-1213.</p>
<p>Hodgson, M. E., and Gaile, G. L. (1999). A cartographic modeling approach for surface orientation-related applications.
<em>Photogrammetric Engineering and Remote Sensing</em>, 65(1), 85-95.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a>, <a href="./geomorphometric_analysis.html#surfacearearatio"><strong>SurfaceAreaRatio</strong></a>, <a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--output           </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.spherical_std_dev_of_normals(
    dem, 
    output, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SphericalStdDevOfNormals -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif --out_mag=roughness_mag.tif ^
--out_scale=roughness_scale.tif --min_scale=1 --max_scale=1000 ^
--step=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/spherical_std_dev_of_normals.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/05/2019</p>
<p><a name="StandardDeviationOfSlope"></a></p>
<a class="header" href="#standarddeviationofslope" id="standarddeviationofslope"><h1>StandardDeviationOfSlope</h1></a>
<p>Calculates the standard deviation of slope from an input DEM, a metric of
roughness described by Grohmann et al., (2011).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster DEM file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.standard_deviation_of_slope(
    i, 
    output, 
    zfactor=1.0, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationOfSlope -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/standard_deviation_of_slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Anthony Francioni</p>
<p><em>Created</em>: May 26, 2018</p>
<p><a name="SurfaceAreaRatio"></a></p>
<a class="header" href="#surfacearearatio" id="surfacearearatio"><h1>SurfaceAreaRatio</h1></a>
<p>This tool calculates the ratio between the surface area and planar area of grid cells within digital elevation models (DEMs).
The tool uses the method of Jenness (2004) to estimate the surface area of a DEM grid cell based on the elevations
contained within the 3 x 3 neighbourhood surrounding each cell. The surface area ratio has a lower bound of 1.0 for
perfectly flat grid cells and is greater than 1.0 for other conditions. In particular, surface area ratio is a measure of
neighbourhood surface shape complexity (texture) and elevation variability (local slope).</p>
<p><em>Reference</em>:</p>
<p>Jenness, J. S. (2004). Calculating landscape surface area from digital elevation models. Wildlife Society
Bulletin, 32(3), 829-839.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#ruggednessindex"><strong>RuggednessIndex</strong></a>, <a href="./geomorphometric_analysis.html#multiscaleroughness"><strong>MultiscaleRoughness</strong></a>, <a href="./geomorphometric_analysis.html#circularvarianceofaspect"><strong>CircularVarianceOfAspect</strong></a>, <a href="./geomorphometric_analysis.html#edgedensity"><strong>EdgeDensity</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.surface_area_ratio(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SurfaceAreaRatio -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/surface_area_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/01/2019</p>
<p><a name="TangentialCurvature"></a></p>
<a class="header" href="#tangentialcurvature" id="tangentialcurvature"><h1>TangentialCurvature</h1></a>
<p>This tool calculates the tangential curvature, which is the curvature of an inclined plan perpendicular
to both the direction of flow and the surface (Gallant and Wilson, 2000). Curvature is a second
derivative of the topographic surface defined by a digital elevation model (DEM). The user must specify
the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#totalcurvature"><strong>TotalCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tangential_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TangentialCurvature -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/tan_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="TotalCurvature"></a></p>
<a class="header" href="#totalcurvature" id="totalcurvature"><h1>TotalCurvature</h1></a>
<p>This tool calculates the total curvature, which measures the curvature of the topographic surface rather
than the curvature of a line across the surface in some direction (Gallant and Wilson, 2000). Total
curvature can be positive or negative, with zero curvature indicating that the surface is either flat
or the convexity in one direction is balanced by the concavity in another direction, as would occur at
a saddle point. Curvature is a second derivative of the topographic surface defined by a digital elevation
model (DEM). The user must specify the name of the input DEM (<code>--dem</code>) and the output raster image (<code>--output</code>). The output reports curvature
in degrees multiplied by 100 for easier interpretation, as curvature values are often very small. The Z
Conversion Factor (<code>--zfactor</code>) is only important when the vertical and horizontal units are not the
same in the DEM. When this is the case, the algorithm will multiply each elevation in the DEM by the
Z Conversion Factor. If the DEM is in the geographic coordinate system (latitude and longitude), with
XY units measured in degrees, an appropriate Z Conversion Factor is calculated internally based on
site latitude.</p>
<p><em>Reference</em>:</p>
<p>Gallant, J. C., and J. P. Wilson, 2000, Primary topographic attributes, in Terrain Analysis: Principles
and Applications, edited by J. P. Wilson and J. C. Gallant pp. 51-86, John Wiley, Hoboken, N.J.</p>
<p><a href="./geomorphometric_analysis.html#plancurvature"><strong>PlanCurvature</strong></a>, <a href="./geomorphometric_analysis.html#profilecurvature"><strong>ProfileCurvature</strong></a>, <a href="./geomorphometric_analysis.html#tangentialcurvature"><strong>TangentialCurvature</strong></a>, <a href="./geomorphometric_analysis.html#slope"><strong>Slope</strong></a>, <a href="./geomorphometric_analysis.html#aspect"><strong>Aspect</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zfactor          </td><td> Optional multiplier for when the vertical and horizontal units are not the same</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.total_curvature(
    dem, 
    output, 
    zfactor=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TotalCurvature -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/total_curvature.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="Viewshed"></a></p>
<a class="header" href="#viewshed" id="viewshed"><h1>Viewshed</h1></a>
<p>This tool can be used to calculate the viewshed (i.e. the visible area) from a
location (i.e. viewing station) or group of locations based on the topography defined
by an input digital elevation model (DEM). The user must specify the name of the input
DEM (<code>--dem</code>), a viewing station input vector file (<code>--stations</code>), the output file name
(<code>--output</code>), and the viewing height (<code>--height</code>).
Viewing station locations are specified as points within an input shapefile. The output
image indicates the number of stations visible from each grid cell. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation from which the viewshed is calculated.</p>
<p><a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a> should be used when there are a relatively small number of target sites
for which visibility needs to be assessed. If you need to assess general landscape
visibility as a land-surface parameter, the <a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a> tool should be used
instead.</p>
<p>Viewshed analysis is a very
computationally intensive task. Depending on the size of the input DEM grid and the
number of viewing stations, this operation may take considerable time to complete. Also,
this implementation of the viewshed algorithm does not account for the curvature of the
Earth. This should be accounted for if viewsheds are being calculated over very
extensive areas.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#visibilityindex"><strong>VisibilityIndex</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>--stations         </td><td> Input viewing station vector file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--height           </td><td> Viewing station height, in z units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.viewshed(
    dem, 
    stations, 
    output, 
    height=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Viewshed -v --wd=&quot;/path/to/data/&quot; ^
--dem='dem.tif' --stations='stations.shp' -o=output.tif ^
--height=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/viewshed.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/01/2018</p>
<p><a name="VisibilityIndex"></a></p>
<a class="header" href="#visibilityindex" id="visibilityindex"><h1>VisibilityIndex</h1></a>
<p>This tool can be used to calculate a measure of landscape visibility based on the
topography of an input digital elevation model (DEM). The user must specify the name of
the input DEM (<code>--dem</code>), the output file name (<code>--output</code>), the viewing height (<code>--height</code>),
and a resolution factor (<code>--res_factor</code>).
Viewsheds are calcuated for a subset of grid cells in the DEM based on the resolution
factor. The visibility index value (0.0-1.0) indicates the proportion of tested stations
(determined by the resolution factor) that each cell is visible from. The viewing height
is in the same units as the elevations of the DEM and represent a height above the ground
elevation. Each tested grid cell's viewshed will be calculated in parallel. However, visibility
index is one of the most computationally intensive geomorphometric indices to calculate.
Depending on the size of the input DEM grid and the resolution factor, this operation may take
considerable time to complete. If the task is too long-running, it is advisable to raise the
resolution factor. A resolution factor of 2 will skip every second row and every second column
(effectively evaluating the viewsheds of a quarter of the DEM's grid cells). Increasing this
value decreases the number of calculated viewshed but will result in a lower accuracy estimate
of overall visibility. In addition to the high computational costs of this index, the tool
also requires substantial memory resources to operate. Each of these limitations should be
considered before running this tool on a particular data set. This tool is best to apply
on computer systems with high core-counts and plenty of memory.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#viewshed"><strong>Viewshed</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--height           </td><td> Viewing station height, in z units</td></tr>
<tr><td>--res_factor       </td><td> The resolution factor determines the density of measured viewsheds</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.visibility_index(
    dem, 
    output, 
    height=2.0, 
    res_factor=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VisibilityIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=dem.tif -o=output.tif ^
--height=10.0 --res_factor=4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/visibility_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/04/2018</p>
<p><a name="WetnessIndex"></a></p>
<a class="header" href="#wetnessindex" id="wetnessindex"><h1>WetnessIndex</h1></a>
<p>Calculates the topographic wetness index, Ln(A / tan(slope)).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--sca              </td><td> Input raster specific contributing area (SCA) file</td></tr>
<tr><td>--slope            </td><td> Input raster slope file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.wetness_index(
    sca, 
    slope, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WetnessIndex -v --wd=&quot;/path/to/data/&quot; ^
--sca='flow_accum.tif' --slope='slope.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/terrain_analysis/wetness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 2, 2017</p>
<a class="header" href="#gis-analysis" id="gis-analysis"><h1>GIS Analysis</h1></a>
<ul>
<li><a href="#AggregateRaster">AggregateRaster</a></li>
<li><a href="#BlockMaximumGridding">BlockMaximumGridding</a></li>
<li><a href="#BlockMinimumGridding">BlockMinimumGridding</a></li>
<li><a href="#Centroid">Centroid</a></li>
<li><a href="#CentroidVector">CentroidVector</a></li>
<li><a href="#Clump">Clump</a></li>
<li><a href="#ConstructVectorTin">ConstructVectorTin</a></li>
<li><a href="#CreateHexagonalVectorGrid">CreateHexagonalVectorGrid</a></li>
<li><a href="#CreatePlane">CreatePlane</a></li>
<li><a href="#CreateRectangularVectorGrid">CreateRectangularVectorGrid</a></li>
<li><a href="#Dissolve">Dissolve</a></li>
<li><a href="#EliminateCoincidentPoints">EliminateCoincidentPoints</a></li>
<li><a href="#ExtendVectorLines">ExtendVectorLines</a></li>
<li><a href="#ExtractNodes">ExtractNodes</a></li>
<li><a href="#ExtractRasterValuesAtPoints">ExtractRasterValuesAtPoints</a></li>
<li><a href="#FindLowestOrHighestPoints">FindLowestOrHighestPoints</a></li>
<li><a href="#IdwInterpolation">IdwInterpolation</a></li>
<li><a href="#LayerFootprint">LayerFootprint</a></li>
<li><a href="#Medoid">Medoid</a></li>
<li><a href="#MinimumBoundingBox">MinimumBoundingBox</a></li>
<li><a href="#MinimumBoundingCircle">MinimumBoundingCircle</a></li>
<li><a href="#MinimumBoundingEnvelope">MinimumBoundingEnvelope</a></li>
<li><a href="#MinimumConvexHull">MinimumConvexHull</a></li>
<li><a href="#NearestNeighbourGridding">NearestNeighbourGridding</a></li>
<li><a href="#PolygonArea">PolygonArea</a></li>
<li><a href="#PolygonLongAxis">PolygonLongAxis</a></li>
<li><a href="#PolygonPerimeter">PolygonPerimeter</a></li>
<li><a href="#PolygonShortAxis">PolygonShortAxis</a></li>
<li><a href="#RasterArea">RasterArea</a></li>
<li><a href="#RasterCellAssignment">RasterCellAssignment</a></li>
<li><a href="#Reclass">Reclass</a></li>
<li><a href="#ReclassEqualInterval">ReclassEqualInterval</a></li>
<li><a href="#ReclassFromFile">ReclassFromFile</a></li>
<li><a href="#SmoothVectors">SmoothVectors</a></li>
<li><a href="#TinGridding">TinGridding</a></li>
<li><a href="#VectorHexBinning">VectorHexBinning</a></li>
<li><a href="#VoronoiDiagram">VoronoiDiagram</a></li>
</ul>
<p><a name="AggregateRaster"></a></p>
<a class="header" href="#aggregateraster" id="aggregateraster"><h1>AggregateRaster</h1></a>
<p>This tool can be used to reduce the grid resolution of a raster by a user specified amount. For example, using
an aggregation factor (<code>--agg_factor</code>) of 2 would result in a raster with half the number of rows and columns.
The grid cell values (<code>--type</code>) in the output image will consist of the mean, sum, maximum, minimum, or range
of the overlapping grid cells in the input raster (four cells in the case of an aggregation factor of 2).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#resample"><strong>Resample</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--agg_factor       </td><td> Aggregation factor, in pixels</td></tr>
<tr><td>--type             </td><td> Statistic used to fill output pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.aggregate_raster(
    i, 
    output, 
    agg_factor=2, 
    type=&quot;mean&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AggregateRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--output_text 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/aggregate_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/12/2017</p>
<p><a name="BlockMaximumGridding"></a></p>
<a class="header" href="#blockmaximumgridding" id="blockmaximumgridding"><h1>BlockMaximumGridding</h1></a>
<p>Creates a raster grid based on a set of vector points and assigns grid values using a block maximum scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.block_maximum_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BlockMaximumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=BlockMaximumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/block_maximum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><a name="BlockMinimumGridding"></a></p>
<a class="header" href="#blockminimumgridding" id="blockminimumgridding"><h1>BlockMinimumGridding</h1></a>
<p>Creates a raster grid based on a set of vector points and assigns grid values using a block minimum scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.block_minimum_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BlockMinimumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=BlockMinimumGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/block_minimum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><a name="Centroid"></a></p>
<a class="header" href="#centroid" id="centroid"><h1>Centroid</h1></a>
<p>This tool calculates the centroid, or average location, of raster polygon objects.
For vector features, use the <a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--text_output      </td><td> Optional text output</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.centroid(
    i, 
    output, 
    text_output=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Centroid -v --wd=&quot;/path/to/data/&quot; ^
-i=polygons.tif -o=output.tif
&gt;&gt;./whitebox_tools -r=Centroid ^
-v --wd=&quot;/path/to/data/&quot; -i=polygons.tif -o=output.tif ^
--text_output 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/centroid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 22 2017</p>
<p><a name="CentroidVector"></a></p>
<a class="header" href="#centroidvector" id="centroidvector"><h1>CentroidVector</h1></a>
<p>This can be used to identify the centroid point of a vector polyline or polygon feature or a group of
vector points. The output is a vector shapefile of points. For multi-part polyline or polygon features,
the user can optionally specify whether to identify the centroid of each part. The default is to treat
multi-part features a single entity.</p>
<p>For raster features, use the <a href="./gis_analysis.html#centroid"><strong>Centroid</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#centroid"><strong>Centroid</strong></a>, <a href="./gis_analysis.html#medoid"><strong>Medoid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.centroid_vector(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CentroidVector -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/centroid_vector.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><a name="Clump"></a></p>
<a class="header" href="#clump" id="clump"><h1>Clump</h1></a>
<p>This tool re-categorizes data in a raster image by grouping cells that form
discrete, contiguous areas into unique categories. Essentially this will produce
a patch map from an input categorical raster, assigning each feature unique
identifiers. The input raster should either be
Boolean (1's and 0's) or categorical. The input raster could be created using
the <a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a> tool or one of the comparison operators (<a href="./mathand_stats_tools.html#greaterthan"><strong>GreaterThan</strong></a>, <a href="./mathand_stats_tools.html#lessthan"><strong>LessThan</strong></a>,
<a href="./mathand_stats_tools.html#equalto"><strong>EqualTo</strong></a>, <a href="./mathand_stats_tools.html#notequalto"><strong>NotEqualTo</strong></a>). Use the <em>treat zeros as background cells</em> options
(<code>--zero_back</code>) if you would like to only assigned contiguous groups of non-zero
values in the raster unique identifiers. Additionally, inter-cell connectivity
can optionally include diagonally neighbouring cells if the <code>--diag</code> flag is
specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./mathand_stats_tools.html#greaterthan"><strong>GreaterThan</strong></a>, <a href="./mathand_stats_tools.html#lessthan"><strong>LessThan</strong></a>, <a href="./mathand_stats_tools.html#equalto"><strong>EqualTo</strong></a>, <a href="./mathand_stats_tools.html#notequalto"><strong>NotEqualTo</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--diag             </td><td> Flag indicating whether diagonal connections should be considered</td></tr>
<tr><td>--zero_back        </td><td> Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clump(
    i, 
    output, 
    diag=True, 
    zero_back=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Clump -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --diag 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/clump.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="ConstructVectorTin"></a></p>
<a class="header" href="#constructvectortin" id="constructvectortin"><h1>ConstructVectorTin</h1></a>
<p>This tool creates a vector triangular irregular network (TIN) for a set of vector points (<code>--input</code>)
using a 2D <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> algorithm.
TIN vertex heights can be assigned based on either a field in the vector's attribute table (<code>--field</code>),
or alternatively, if the vector is of a z-dimension <em>ShapeTypeDimension</em>, the point z-values may be
used for vertex heights (<code>--use_z</code>). For LiDAR points, use the <a href="./lidar_tools.html#lidarconstructvectortin"><strong>LidarConstructVectorTIN</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarconstructvectortin"><strong>LidarConstructVectorTIN</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.construct_vector_tin(
    i, 
    output, 
    field=None, 
    use_z=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConstructVectorTIN -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=HEIGHT ^
-o=tin.shp
&gt;&gt;./whitebox_tools -r=ConstructVectorTIN -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=tin.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/construct_vector_tin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/09/2018</p>
<p><a name="CreateHexagonalVectorGrid"></a></p>
<a class="header" href="#createhexagonalvectorgrid" id="createhexagonalvectorgrid"><h1>CreateHexagonalVectorGrid</h1></a>
<p>This tool can be used to create a hexagonal vector grid. The extent of the hexagonal
grid is based on the extent of a user-specified base file (any supported raster format,
shapefiles, or LAS files). The user must also specify the hexagonal cell width (<code>--width</code>)
and whether the hexagonal orientation (<code>--orientation</code>) is <code>horizontal</code> or <code>vertical</code>.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#createrectangularvectorgrid"><strong>CreateRectangularVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base, --input</td><td> Input base file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--width            </td><td> The grid cell width</td></tr>
<tr><td>--orientation      </td><td> Grid Orientation, 'horizontal' or 'vertical'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_hexagonal_vector_grid(
    i, 
    output, 
    width, 
    orientation=&quot;horizontal&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreateHexagonalVectorGrid -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--orientation=vertical 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/create_hexagonal_vector_grid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><a name="CreatePlane"></a></p>
<a class="header" href="#createplane" id="createplane"><h1>CreatePlane</h1></a>
<p>This tool can be used to create a new raster with values that are determined by the equation of a simple plane. The user
must specify the name of a base raster (<code>--base</code>) from which the output raster coordinate and dimensional information
will be taken. In addition the user must specify the values of the planar slope gradient (S; <code>--gradient</code>; <code>--aspect</code>)
in degrees, the planar slope direction or aspect (A; 0 to 360 degrees), and an constant value (k; <code>--constant</code>). The
equation of the plane is as follows:</p>
<blockquote>
<p>Z = tan(S) × sin(A - 180) × X + tan(S) × cos(A - 180) × Y + k</p>
</blockquote>
<p>where X and Y are the X and Y coordinates of each grid cell in the grid. Notice that A is the direction,
or azimuth, that the plane is facing</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--base             </td><td> Input base raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--gradient         </td><td> Slope gradient in degrees (-85.0 to 85.0)</td></tr>
<tr><td>--aspect           </td><td> Aspect (direction) in degrees clockwise from north (0.0-360.0)</td></tr>
<tr><td>--constant         </td><td> Constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_plane(
    base, 
    output, 
    gradient=15.0, 
    aspect=90.0, 
    constant=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreatePlane -v --wd=&quot;/path/to/data/&quot; ^
--base=base.tif -o=NewRaster.tif --gradient=15.0 ^
--aspect=315.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/create_plane.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="CreateRectangularVectorGrid"></a></p>
<a class="header" href="#createrectangularvectorgrid" id="createrectangularvectorgrid"><h1>CreateRectangularVectorGrid</h1></a>
<p>This tool can be used to create a rectangular vector grid. The extent of the rectangular
grid is based on the extent of a user-specified base file (any supported raster format,
shapefiles, or LAS files). The user must also specify the origin of the grid (<code>--xorig</code>
and <code>--yorig</code>) and the grid cell width and height (<code>--width</code> and <code>--height</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base, --input</td><td> Input base file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--width            </td><td> The grid cell width</td></tr>
<tr><td>--height           </td><td> The grid cell height</td></tr>
<tr><td>--xorig            </td><td> The grid origin x-coordinate</td></tr>
<tr><td>--yorig            </td><td> The grid origin y-coordinate</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_rectangular_vector_grid(
    i, 
    output, 
    width, 
    height, 
    xorig=0, 
    yorig=0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreateRectangularVectorGrid -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--height=10.0 --xorig=0.0 --yorig=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/create_rectangular_vector_grid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><a name="Dissolve"></a></p>
<a class="header" href="#dissolve" id="dissolve"><h1>Dissolve</h1></a>
<p>This tool can be used to remove the interior, or shared, boundaries within a vector
polygon coverage. You can either dissolve all interior boundaries or dissolve those
boundaries along polygons with the same value of a user-specified attribute within
the vector's attribute table. It may be desirable to use the <code>VectorCleaning</code> tool
to correct any topological errors resulting from the slight misalignment of nodes
along shared boundaries in the vector coverage before performing the <a href="./gis_analysis.html#dissolve"><strong>Dissolve</strong></a> operation.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a>, <a href="./gis_analysis_overlay_tools.html#polygonize"><strong>Polygonize</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--field            </td><td> Dissolve field attribute (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap             </td><td> Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.dissolve(
    i, 
    output, 
    field=None, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Dissolve -v --wd=&quot;/path/to/data/&quot; ^
-input=layer1.shp --field=SIZE -o=out_file.shp ^
--snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/dissolve.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/11/2018</p>
<p><a name="EliminateCoincidentPoints"></a></p>
<a class="header" href="#eliminatecoincidentpoints" id="eliminatecoincidentpoints"><h1>EliminateCoincidentPoints</h1></a>
<p>This tool can be used to remove any coincident, or nearly coincident, points
from a vector points file. The user must specify the name of the input file,
which must be of a POINTS ShapeType, the output file name, and the tolerance
distance. All points that are within the specified tolerance distance will be
eliminated from the output file. A tolerance distance of 0.0 indicates that
points must be exactly coincident to be removed.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarremoveduplicates"><strong>LidarRemoveDuplicates</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--tolerance        </td><td> The distance tolerance for points</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.eliminate_coincident_points(
    i, 
    output, 
    tolerance, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EliminateCoincidentPoints -v ^
--wd=&quot;/path/to/data/&quot; -i=input_file.shp -o=out_file.shp ^
--tolerance=0.01 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/eliminate_coincident_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/09/2018</p>
<p><a name="ExtendVectorLines"></a></p>
<a class="header" href="#extendvectorlines" id="extendvectorlines"><h1>ExtendVectorLines</h1></a>
<p>This tool can be used to extend vector lines by a specified distance. The user must
input the names of the input and output shapefiles, the distance to extend features
by, and whether to extend both ends, line starts, or line ends. The input shapefile
must be of a POLYLINE base shape type and should be in a projected coordinate system.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polyline file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polyline file</td></tr>
<tr><td>--dist             </td><td> The distance to extend</td></tr>
<tr><td>--extend           </td><td> Extend direction, 'both ends' (default), 'line start', 'line end'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extend_vector_lines(
    i, 
    output, 
    dist, 
    extend=&quot;both ends&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtendVectorLines -v ^
--wd=&quot;/path/to/data/&quot; -i=in_file.shp -o=out_file.shp ^
--dist=10.0 --extend='both ends' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/extend_vector_lines.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><a name="ExtractNodes"></a></p>
<a class="header" href="#extractnodes" id="extractnodes"><h1>ExtractNodes</h1></a>
<p>This tool converts vector lines or polygons into vertex points. The user must specify the
name of the input vector, which must be of a polyline or polygon base shape type, and
the name of the output point-type vector.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector lines or polygon file</td></tr>
<tr><td>-o, --output       </td><td> Output vector points file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_nodes(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractNodes -v --wd=&quot;/path/to/data/&quot; ^
-i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/extract_nodes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/09/2018</p>
<p><a name="ExtractRasterValuesAtPoints"></a></p>
<a class="header" href="#extractrastervaluesatpoints" id="extractrastervaluesatpoints"><h1>ExtractRasterValuesAtPoints</h1></a>
<p>This tool can be used to extract the values of one or more rasters (<code>--inputs</code>) at the sites of a set of vector points.
By default, the data is output to the attribute table of the input points (<code>--points</code>) vector; however,
if the <code>--out_text</code> parameter is specified, the tool will additionally output point values as text data
to standard output (<em>stdout</em>). Attribute fields will be added to the table of the points file, with field
names, <em>VALUE1</em>, <em>VALUE2</em>, <em>VALUE3</em>, etc. each corresponding to the order of input rasters.</p>
<p>If you need to plot a chart of values from a raster stack at a set of points, the <a href="./image_processing_tools.html#imagestackprofile"><strong>ImageStackProfile</strong></a> may be
more suitable for this application.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#imagestackprofile"><strong>ImageStackProfile</strong></a>, <a href="./gis_analysis.html#findlowestorhighestpoints"><strong>FindLowestOrHighestPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>--out_text         </td><td> Output point values as text? Otherwise, the only output is to to the points file's attribute table</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_raster_values_at_points(
    inputs, 
    points, 
    out_text=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractRasterValuesAtPoints -v ^
--wd=&quot;/path/to/data/&quot; -i='image1.tif;image2.tif;image3.tif' ^
-points=points.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/extract_raster_values_at_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/06/2018</p>
<p><a name="FindLowestOrHighestPoints"></a></p>
<a class="header" href="#findlowestorhighestpoints" id="findlowestorhighestpoints"><h1>FindLowestOrHighestPoints</h1></a>
<p>This tool locates the lowest and/or highest cells in a raster and outputs these locations to a vector
points file. The user must specify the name of the input raster (<code>--input</code>) and the name of the output
vector file (<code>--output</code>). The user also has the option (<code>--out_type</code>) to locate either the lowest value,
highest value, or both values. The output vector's attribute table will contain fields for the points
XY coordinates and their values.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#extractrastervaluesatpoints"><strong>ExtractRasterValuesAtPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output vector points file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'area' (default) and 'volume'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_lowest_or_highest_points(
    i, 
    output, 
    out_type=&quot;lowest&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindLowestOrHighestPoints -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tif -o=out.shp ^
--out_type=highest 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/find_lowest_or_highest_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/06/2018</p>
<p><a name="IdwInterpolation"></a></p>
<a class="header" href="#idwinterpolation" id="idwinterpolation"><h1>IdwInterpolation</h1></a>
<p>points or a fixed neighbourhood size. This tool is currently configured to perform the later
only, using a FixedRadiusSearch structure. Using a fixed number of neighbours will require
use of a KD-tree structure. I've been testing one Rust KD-tree library but its performance
does not appear to be satisfactory compared to the FixedRadiusSearch. I will need to explore
other options here.</p>
<p>Another change that will need to be implemented is the use of a nodal function. The original
Whitebox GAT tool allows for use of a constant or a quadratic. This tool only allows the
former.
This tool interpolates vector points into a raster surface using an inverse-distance weighted scheme.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--weight           </td><td> IDW weight value</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--min_points       </td><td> Minimum number of points</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.idw_interpolation(
    i, 
    field, 
    output, 
    use_z=False, 
    weight=2.0, 
    radius=None, 
    min_points=None, 
    cell_size=None, 
    base=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IdwInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--weight=2.0 --radius=4.0 --min_points=3 ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=IdwInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--weight=2.0 --radius=4.0 --min_points=3 ^
--base=existing_raster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/idw_interpolation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/05/2018</p>
<p><a name="LayerFootprint"></a></p>
<a class="header" href="#layerfootprint" id="layerfootprint"><h1>LayerFootprint</h1></a>
<p>This tool creates a vector polygon footprint of the area covered by a raster grid or vector
layer. It will create a vector rectangle corresponding to the bounding box. The user must
specify the name of the input file, which may be either a Whitebox raster or a vector, and
the name of the output file.</p>
<p>If an input raster grid is specified which has an irregular shape, i.e. it contains NoData
values at the edges, the resulting vector will still correspond to the full grid extent,
ignoring the irregular boundary. If this is not the desired effect, you should reclass the
grid such that all cells containing valid values are assigned some positive, non-zero value,
and then use the <code>RasterToVectorPolygons</code> tool to vectorize the irregular-shaped extent
boundary.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <code>RasterToVectorPolygons</code></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster or vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.layer_footprint(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LayerFootprint -v --wd=&quot;/path/to/data/&quot; ^
-i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/layer_footprint.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/09/2018</p>
<p><a name="Medoid"></a></p>
<a class="header" href="#medoid" id="medoid"><h1>Medoid</h1></a>
<p>This tool calculates the medoid for a series of vector features contained in a shapefile. The medoid
of a two-dimensional feature is conceptually similar its centroid, or mean position, but the medoid
is always a members of the input feature data set. Thus, the medoid is a measure of central tendency
that is robust in the presence of outliers. If the input vector is of a POLYLINE or POLYGON ShapeType,
the nodes of each feature will be used to estimate the feature medoid. If the input vector is of a
POINT base ShapeType, the medoid will be calculated for the collection of points. While there are
more than one competing method of calculating the medoid, this tool uses an algorithm that works as follows:</p>
<ol>
<li>The x-coordinate and y-coordinate of each point/node are placed into two arrays.</li>
<li>The x- and y-coordinate arrays are then sorted and the median x-coordinate (Med X) and median
y-coordinate (Med Y) are calculated.</li>
<li>The point/node in the dataset that is nearest the point (Med X, Med Y) is identified as the medoid.</li>
</ol>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#centroidvector"><strong>CentroidVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.medoid(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Medoid -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/medoid.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/09/2018</p>
<p><a name="MinimumBoundingBox"></a></p>
<a class="header" href="#minimumboundingbox" id="minimumboundingbox"><h1>MinimumBoundingBox</h1></a>
<p>This tool delineates the minimum bounding box (MBB) for a group of vectors. The MBB is the smallest box to
completely enclose a feature. The algorithm works by rotating the feature, calculating the axis-aligned
bounding box for each rotation, and finding the box with the smallest area, length, width, or perimeter. The
MBB is needed to compute several shape indices, such as the Elongation Ratio. The <code>MinimumBoundingEnvelop</code>
tool can be used to calculate the axis-aligned bounding rectangle around each feature in a vector file.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--criterion        </td><td> Minimization criterion; options include 'area' (default), 'length', 'width', and 'perimeter'</td></tr>
<tr><td>--features         </td><td> Find the minimum bounding rectangles around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_box(
    i, 
    output, 
    criterion=&quot;area&quot;, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingBox -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp ^
--criterion=length --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/minimum_bounding_box.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><a name="MinimumBoundingCircle"></a></p>
<a class="header" href="#minimumboundingcircle" id="minimumboundingcircle"><h1>MinimumBoundingCircle</h1></a>
<p>This tool delineates the minimum bounding circle (MBC) for a group of vectors. The MBC is the smallest enclosing
circle to completely enclose a feature.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--features         </td><td> Find the minimum bounding circle around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_circle(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingCircle -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/minimum_bounding_circle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><a name="MinimumBoundingEnvelope"></a></p>
<a class="header" href="#minimumboundingenvelope" id="minimumboundingenvelope"><h1>MinimumBoundingEnvelope</h1></a>
<p>This tool delineates the minimum bounding axis-aligned box for a group of vector features. The is the smallest
rectangle to completely enclose a feature, in which the sides of the envelope are aligned with the x and y
axis of the coordinate system. The <a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a> can be used instead to find the smallest possible
non-axis aligned rectangular envelope.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--features         </td><td> Find the minimum bounding envelop around each individual vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_bounding_envelope(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumBoundingEnvelope -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/minimum_bounding_envelope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/09/2018</p>
<p><a name="MinimumConvexHull"></a></p>
<a class="header" href="#minimumconvexhull" id="minimumconvexhull"><h1>MinimumConvexHull</h1></a>
<p>This tool creates a vector convex polygon around vector features. The convex hull
is a convex closure of a set of points or polygon verticies and can be may be
conceptualized as the shape enclosed by a rubber band stretched around the point
set. The convex hull has many applications and is most notably used in various
shape indices. The Delaunay triangulation of a point set and its dual, the
Voronoi diagram, are mathematically related to convex hulls.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumboundingcircle"><strong>MinimumBoundingCircle</strong></a>, <a href="./gis_analysis.html#minimumboundingenvelope"><strong>MinimumBoundingEnvelope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--features         </td><td> Find the hulls around each vector feature</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_convex_hull(
    i, 
    output, 
    features=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumConvexHull -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --features 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/minimum_convex_hull.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/09/2018</p>
<p><a name="NearestNeighbourGridding"></a></p>
<a class="header" href="#nearestneighbourgridding" id="nearestneighbourgridding"><h1>NearestNeighbourGridding</h1></a>
<p>Creates a raster grid based on a set of vector points and assigns grid values using the nearest neighbour.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use z-coordinate instead of field?</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
<tr><td>--base             </td><td> Optionally specified input base raster file. Not used when a cell size is specified</td></tr>
<tr><td>--max_dist         </td><td> Maximum search distance (optional)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.nearest_neighbour_gridding(
    i, 
    field, 
    output, 
    use_z=False, 
    cell_size=None, 
    base=None, 
    max_dist=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NearestNeighbourGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --field=ELEV -o=output.tif ^
--cell_size=1.0
&gt;&gt;./whitebox_tools -r=NearestNeighbourGridding ^
-v --wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=output.tif ^
--base=existing_raster.tif --max_dist=5.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/nearest_neighbour_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/10/2018</p>
<p><a name="PolygonArea"></a></p>
<a class="header" href="#polygonarea" id="polygonarea"><h1>PolygonArea</h1></a>
<p>This tool calculates the area of vector polygons, adding the result to the
vector's attribute table (AREA field). The area calculation will account
for any holes contained within polygons. The vector should be in a
projected coordinate system.</p>
<p>To calculate the area of raster polygons, use the <a href="./gis_analysis.html#rasterarea"><strong>RasterArea</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#rasterarea"><strong>RasterArea</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_area(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonArea -v --wd=&quot;/path/to/data/&quot; ^
--input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/polygon_area.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="PolygonLongAxis"></a></p>
<a class="header" href="#polygonlongaxis" id="polygonlongaxis"><h1>PolygonLongAxis</h1></a>
<p>This tool can be used to map the long axis of polygon features. The long axis is the
longer of the two primary axes of the minimum bounding box (MBB), i.e. the smallest box
to completely enclose a feature. The long axis is drawn for each polygon in the input
vector file such that it passes through the centre point of the MBB. The output file is
therefore a vector of simple two-point polylines forming a vector field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_long_axis(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonLongAxis -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/polygon_long_axis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2018</p>
<p><a name="PolygonPerimeter"></a></p>
<a class="header" href="#polygonperimeter" id="polygonperimeter"><h1>PolygonPerimeter</h1></a>
<p>This tool calculates the perimeter of vector polygons, adding the result
to the vector's attribute table (PERIMETER field). The area calculation will
account for any holes contained within polygons. The vector should be in a
a projected coordinate system.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_perimeter(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonPerimeter -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/polygon_perimeter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="PolygonShortAxis"></a></p>
<a class="header" href="#polygonshortaxis" id="polygonshortaxis"><h1>PolygonShortAxis</h1></a>
<p>This tool can be used to map the short axis of polygon features. The short axis is the
shorter of the two primary axes of the minimum bounding box (MBB), i.e. the smallest box
to completely enclose a feature. The short axis is drawn for each polygon in the input
vector file such that it passes through the centre point of the MBB. The output file is
therefore a vector of simple two-point polylines forming a vector field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygon_short_axis(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PolygonShortAxis -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/polygon_short_axis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/09/2018</p>
<p><a name="RasterArea"></a></p>
<a class="header" href="#rasterarea" id="rasterarea"><h1>RasterArea</h1></a>
<p>This tools estimates the area of each category, polygon, or patch in an input raster. The input raster must be categorical
in data scale. Rasters with floating-point cell values are not good candidates for an area analysis. The user must specify
whether the output is given in <code>grid cells</code> or <code>map units</code> (<code>--units</code>). Map Units are physical units, e.g. if the rasters's
scale is in metres, areas will report in square-metres. Notice that square-metres can be converted into hectares by dividing
by 10,000 and into square-kilometres by dividing by 1,000,000. If the input raster is in geographic coordinates (i.e.
latitude and longitude) a warning will be issued and areas will be estimated based on per-row calculated degree lengths.</p>
<p>The tool can be run with a raster output (<code>--output</code>), a text output (<code>--out_text</code>), or both. If niether outputs are specified,
the tool will automatically output a raster named <code>area.tif</code>.</p>
<p>Zero values in the input raster may be excluded from the area analysis if the <code>--zero_back</code> flag is used.</p>
<p>To calculate the area of vector polygons, use the <a href="./gis_analysis.html#polygonarea"><strong>PolygonArea</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#polygonarea"><strong>PolygonArea</strong></a>, <a href="./mathand_stats_tools.html#rasterhistogram"><strong>RasterHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_text         </td><td> Would you like to output polygon areas to text?</td></tr>
<tr><td>--units            </td><td> Area units; options include 'grid cells' and 'map units'</td></tr>
<tr><td>--zero_back        </td><td> Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_area(
    i, 
    output=None, 
    out_text=False, 
    units=&quot;grid cells&quot;, 
    zero_back=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterArea -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --out_text --units='grid cells' ^
--zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/raster_area.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/02/2019</p>
<p><a name="RasterCellAssignment"></a></p>
<a class="header" href="#rastercellassignment" id="rastercellassignment"><h1>RasterCellAssignment</h1></a>
<p>This tool can be used to create a new raster with the same coordinates and dimensions
(i.e. rows and columns) as an existing base image. Grid cells in the new raster will be
assigned either the row or column number or the x- or y-coordinate, depending on the
selected option (<code>--assign</code> flag). The user must also specify the name of the base
image (<code>--input</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#newrasterfrombase"><strong>NewRasterFromBase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>-a, --assign       </td><td> Which variable would you like to assign to grid cells? Options include 'column', 'row', 'x', and 'y'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_cell_assignment(
    i, 
    output, 
    assign=&quot;column&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterCellAssignment -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--assign='column' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/raster_cell_assignment.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Daniel Newman</p>
<p><em>Created</em>: August 10, 2017</p>
<p><a name="Reclass"></a></p>
<a class="header" href="#reclass" id="reclass"><h1>Reclass</h1></a>
<p>This tool creates a new raster in which the value of each grid cell is determined by an input raster (<code>--input</code>) and a
collection of user-defined classes. The user must specify the <em>New</em> value, the <em>From</em> value, and the <em>To Just Less Than</em>
value of each class triplet of the reclass string. Classes must be mutually exclusive, i.e. non-overlapping. For example:</p>
<blockquote>
<p>--reclass_vals='0.0;0.0;1.0;1.0;1.0;2.0'</p>
</blockquote>
<p>The above reclass string assigns 0.0 to all grid cells in the input image with values from 0.0-1.0 and an output
value of 1.0 from to inputs from 1.0-2.0. Alternatively, if the <code>--assign_mode</code> flag is specified, <a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a> will
operate in assign mode, using a reclass string composed of paired values:</p>
<blockquote>
<p>--reclass_vals='0.0;1.0;1.0;2.0'</p>
</blockquote>
<p>Here, 0.0 is assigned to input grid cell values of 1.0 and 1.0 is output for all input cells with a value of 2.0.</p>
<p>Any values in the input raster that do not fall within one of the classes will be assigned its original value in the
output raster. NoData values in the input raster will be assigned NoData values in the output raster, unless NoData is
used in one of the user-defined reclass ranges (notice that it is valid to enter 'NoData' in these ranges).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#reclassequalinterval"><strong>ReclassEqualInterval</strong></a>, <a href="./gis_analysis.html#reclassfromfile"><strong>ReclassFromFile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--reclass_vals     </td><td> Reclassification triplet values (new value; from value; to less than), e.g. '0.0;0.0;1.0;1.0;1.0;2.0'</td></tr>
<tr><td>--assign_mode      </td><td> Optional Boolean flag indicating whether to operate in assign mode, reclass_vals values are interpreted as new value; old value pairs</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass(
    i, 
    output, 
    reclass_vals, 
    assign_mode=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Reclass -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif ^
--reclass_vals='0.0;0.0;1.0;1.0;1.0;2.0'
&gt;&gt;./whitebox_tools ^
-r=Reclass -v --wd=&quot;/path/to/data/&quot; -i='input.tif' ^
-o=output.tif --reclass_vals='10;1;20;2;30;3;40;4' ^
--assign_mode 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/reclass.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/09/2017</p>
<p><a name="ReclassEqualInterval"></a></p>
<a class="header" href="#reclassequalinterval" id="reclassequalinterval"><h1>ReclassEqualInterval</h1></a>
<p>This tool reclassifies the values in an input raster (<code>--input</code>) file based on an equal-interval scheme, where the
user must specify the reclass interval value (<code>--interval</code>), the starting value (<code>--start_val</code>), and optionally,
the ending value (<code>--end_val</code>). Grid cells containing values that fall outside of the range defined by the starting
and ending values, will be assigned their original values in the output grid. If the user does not specify an ending
value, the tool will assign a very large positive value.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./gis_analysis.html#reclassfromfile"><strong>ReclassFromFile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--interval         </td><td> Class interval size</td></tr>
<tr><td>--start_val        </td><td> Optional starting value (default is input minimum value)</td></tr>
<tr><td>--end_val          </td><td> Optional ending value (default is input maximum value)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass_equal_interval(
    i, 
    output, 
    interval=10.0, 
    start_val=None, 
    end_val=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ReclassEqualInterval -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' -o=output.tif ^
--interval=10.0 --start_val=0.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/reclass_equal_interval.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/07/2017</p>
<p><a name="ReclassFromFile"></a></p>
<a class="header" href="#reclassfromfile" id="reclassfromfile"><h1>ReclassFromFile</h1></a>
<p>This tool creates a new raster image in which the value of each grid cell is determined by the values in an
input raster image (<code>--input</code>) and a reclass file (<code>--reclass_file</code>). The reclass file is a text file
containing two or three columns, delimited (i.e. separated) by either a space, tab, or comma. The columns
describe respectively the <em>New</em> value, the <em>From</em> value, and the <em>To Just Less Than</em> value. Classes must be
mutually exclusive, i.e. non-overlapping.</p>
<p>If only two columns are present in the reclass file, i.e. the <em>From</em> column is left blank, the tool will
operate in assign mode. That is, any cell in the input image that is equal to the <em>From</em> value (contained
in the second column) will be assigned the <em>New</em> value (contained in the first column) in the output image.</p>
<p>Any values in the input raster that do not fall within one of the classes will be assigned its original
value in the output raster. TNoData values in the input raster will be assigned NoData values in the output
raster.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#reclass"><strong>Reclass</strong></a>, <a href="./gis_analysis.html#reclassequalinterval"><strong>ReclassEqualInterval</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--reclass_file     </td><td> Input text file containing reclass ranges</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reclass_from_file(
    i, 
    reclass_file, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ReclassFromFile -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' ^
--reclass_file='reclass.txt' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/reclass_from_file.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/09/2017</p>
<p><a name="SmoothVectors"></a></p>
<a class="header" href="#smoothvectors" id="smoothvectors"><h1>SmoothVectors</h1></a>
<p>This tool smooths a vector coverage of either a POLYLINE or POLYGON base ShapeType. The algorithm
uses a simple moving average method for smoothing, where the size of the averaging window is specified
by the user. The default filter size is 3 and can be any odd integer larger than or equal to 3. The
larger the averaging window, the greater the degree of line smoothing.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector POLYLINE or POLYGON file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--filter           </td><td> The filter size, any odd integer greater than or equal to 3; default is 3</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.smooth_vectors(
    i, 
    output, 
    filter=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SmoothVectors -v --wd=&quot;/path/to/data/&quot; ^
-i=in_file.shp -o=out_file.shp --filter=9 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/smooth_vectors.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/10/2018</p>
<p><a name="TinGridding"></a></p>
<a class="header" href="#tingridding" id="tingridding"><h1>TinGridding</h1></a>
<p>Creates a raster grid based on a triangular irregular network (TIN) fitted to vector points
and linear interpolation within each triangular-shaped plane.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidartingridding"><strong>LidarTINGridding</strong></a>, <a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>--use_z            </td><td> Use the 'z' dimension of the Shapefile's geometry instead of an attribute field?</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tin_gridding(
    i, 
    output, 
    resolution, 
    field=None, 
    use_z=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TINGridding -v --wd=&quot;/path/to/data/&quot; ^
-i=points.shp --field=HEIGHT -o=tin.shp ^
--resolution=10.0
&gt;&gt;./whitebox_tools -r=TINGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=points.shp --use_z -o=tin.shp ^
--resolution=5.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/tin_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/09/2018</p>
<p><a name="VectorHexBinning"></a></p>
<a class="header" href="#vectorhexbinning" id="vectorhexbinning"><h1>VectorHexBinning</h1></a>
<p>The practice of binning point data to form a type of 2D histogram, density plot,
or what is sometimes called a heatmap, is quite useful as an alternative for the
cartographic display of of very dense points sets. This is particularly the case
when the points experience significant overlap at the displayed scale. The
<code>PointDensity</code> tool can be used to perform binning based on a regular grid (raster
output). This tool, by comparison, bases the binning on a hexagonal grid.</p>
<p>The tool is similar to the <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a> tool, however instead will
create an output hexagonal grid in which each hexagonal cell possesses a <code>COUNT</code>
attribute which specifies the number of points from an input points file (Shapefile
vector) that are contained within the hexagonal cell.</p>
<p>In addition to the names of the input points file and the output Shapefile, the user
must also specify the desired hexagon width (w), which is the distance between opposing
sides of each hexagon. The size (s) each side of the hexagon can then be calculated as,
s = w / [2 x cos(PI / 6)]. The area of each hexagon (A) is, A = 3s(w / 2). The user must
also specify the orientation of the grid with options of horizontal (pointy side up) and
vertical (flat side up).</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarhexbinning"><strong>LidarHexBinning</strong></a>, <code>PointDensity</code>, <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input base file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--width            </td><td> The grid cell width</td></tr>
<tr><td>--orientation      </td><td> Grid Orientation, 'horizontal' or 'vertical'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.vector_hex_binning(
    i, 
    output, 
    width, 
    orientation=&quot;horizontal&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VectorHexBinning -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.shp --width=10.0 ^
--orientation=vertical 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/vector_hex_bin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/09/2018</p>
<p><a name="VoronoiDiagram"></a></p>
<a class="header" href="#voronoidiagram" id="voronoidiagram"><h1>VoronoiDiagram</h1></a>
<p>This tool creates a vector Voronoi diagram for a set of vector points. The
Voronoi diagram is the dual graph of the Delaunay triangulation. The tool
operates by first constructing the Delaunay triangulation and then
connecting the circumcenters of each triangle. Each Voronoi cell contains
one point of the input vector points. All locations within the cell are
nearer to the contained point than any other input point.</p>
<p>A dense frame of 'ghost' (hidden) points is inserted around the input point
set to limit the spatial extent of the diagram. The frame is set back from
the bounding box of the input points by 2 x the average point  spacing. The
polygons of these ghost points are not output, however, points that are
situated along the edges of the data will have somewhat rounded (paraboloic)
exterior boundaries as a result of this edge condition. If this property is
unacceptable for application, clipping the Voronoi diagram to the convex
hull may be a better alternative.</p>
<p>This tool works on vector input data only. If a Voronoi diagram is needed
to tesselate regions associated with a set of raster points, use the
<a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a> tool instead. To use Voronoi diagrams for gridding
data (i.e. raster interpolation), use the <a href="./gis_analysis.html#nearestneighbourgridding"><strong>NearestNeighbourGridding</strong></a> tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a>, <a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a>, <a href="./gis_analysis.html#nearestneighbourgridding"><strong>NearestNeighbourGridding</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.voronoi_diagram(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=VoronoiDiagram -v --wd=&quot;/path/to/data/&quot; ^
-i=points.shp -o=tin.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/voronoi_diagram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/10/2018</p>
<a class="header" href="#gis-analysis--distance-tools" id="gis-analysis--distance-tools"><h1>GIS Analysis → Distance Tools</h1></a>
<ul>
<li><a href="#BufferRaster">BufferRaster</a></li>
<li><a href="#CostAllocation">CostAllocation</a></li>
<li><a href="#CostDistance">CostDistance</a></li>
<li><a href="#CostPathway">CostPathway</a></li>
<li><a href="#EuclideanAllocation">EuclideanAllocation</a></li>
<li><a href="#EuclideanDistance">EuclideanDistance</a></li>
</ul>
<p><a name="BufferRaster"></a></p>
<a class="header" href="#bufferraster" id="bufferraster"><h1>BufferRaster</h1></a>
<p>This tool can be used to identify an area of interest within a specified distance of
features of interest in a raster data set.</p>
<p>The Euclidean distance (i.e. straight-line distance) is calculated between each grid
cell and the nearest 'target cell' in the input image. Distance is calcualted using the
efficient method of Shih and Wu (2004). Target cells are all non-zero,
non-NoData grid cells. Because NoData values in the input image are assigned the NoData
value in the output image, the only valid background value in the input image is zero.</p>
<p>The user must specify the input and output image names, the desired buffer size (<code>--size</code>), and,
optionally, whether the distance units are measured in grid cells (i.e. <code>--gridcells</code> flag).
If the <code>--gridcells</code> flag is not specified, the linear units of the raster's coordinate
reference system will be used.</p>
<p><em>Reference</em>:</p>
<p>Shih FY and Wu Y-T (2004), Fast Euclidean distance transformation in two scans using a 3 x 3
neighborhood, <em>Computer Vision and Image Understanding</em>, 93: 195-205.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#euclideandistance"><strong>EuclideanDistance</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--size             </td><td> Buffer size</td></tr>
<tr><td>--gridcells        </td><td> Optional flag to indicate that the 'size' threshold should be measured in grid cells instead of the default map units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.buffer_raster(
    i, 
    output, 
    size, 
    gridcells=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BufferRaster -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/buffer_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="CostAllocation"></a></p>
<a class="header" href="#costallocation" id="costallocation"><h1>CostAllocation</h1></a>
<p>This tool can be used to identify the 'catchment area' of each source grid cell in a
cost-distance analysis. The user must specify the names of the input <em>source</em> and
<em>back-link</em> raster files. Source cells (i.e. starting points for the cost-distance or
least-cost path analysis) are designated as all positive, non-zero valued grid cells
in the <em>source</em> raster. A <em>back-link</em> raster file can be created using the <a href="./gis_analysis_distance_tools.html#costdistance"><strong>CostDistance</strong></a>
tool and is conceptually similar to the D8 flow-direction pointer raster grid in that
it describes the connectivity between neighbouring cells on the accumulated cost surface.</p>
<p>NoData values in the input <em>back-link</em> image are assigned NoData values in the output
image.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#costdistance"><strong>CostDistance</strong></a>, <a href="./gis_analysis_distance_tools.html#costpathway"><strong>CostPathway</strong></a>, <a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--source           </td><td> Input source raster file</td></tr>
<tr><td>--backlink         </td><td> Input backlink raster file generated by the cost-distance tool</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cost_allocation(
    source, 
    backlink, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CostAllocation -v --wd=&quot;/path/to/data/&quot; ^
--source='source.tif' --backlink='backlink.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/cost_allocation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 4, 2017</p>
<p><a name="CostDistance"></a></p>
<a class="header" href="#costdistance" id="costdistance"><h1>CostDistance</h1></a>
<p>This tool can be used to perform cost-distance or least-cost pathway analyses. Specifically,
this tool can be used to calculate the accumulated cost of traveling from the 'source grid
cell' to each other grid cell in a raster dataset. It is based on the costs associated with
traveling through each cell along a pathway represented in a cost (or friction) surface. If
there are multiple source grid cells, each cell in the resulting cost-accumulation surface
will reflect the accumulated cost to the source cell that is connected by the minimum accumulated
cost-path. The user must specify the names of the raster file containing the source cells
(<code>--source</code>), the raster file containing the cost surface information (<code>--cost</code>), the output
cost-accumulation surface raster (<code>--out_accum</code>), and the output back-link raster (<code>--out_backlink</code>).
Source cells are designated as all positive, non-zero valued grid cells in the source raster.
The cost (friction) raster can be created by combining the various cost factors associated with
the specific problem (e.g. slope gradient, visibility, etc.) using a raster calculator or the
<a href="./gis_analysis_overlay_tools.html#weightedoverlay"><strong>WeightedOverlay</strong></a> tool.</p>
<p>While the cost-accumulation surface raster can be helpful for visualizing
the three-dimensional characteristics of the 'cost landscape', it is actually the back-link raster
that is used as inputs to the other two cost-distance tools, <a href="./gis_analysis_distance_tools.html#costallocation"><strong>CostAllocation</strong></a> and <a href="./gis_analysis_distance_tools.html#costpathway"><strong>CostPathway</strong></a>, to
determine the least-cost linkages among neighbouring grid cells on the cost surface. If the
accumulated cost surface is analogous to a digital elevation model (DEM) then the back-link raster
is equivalent to the D8 flow-direction pointer. In fact, it is created in a similar way and uses
the same convention for designating 'flow directions' between neighbouring grid cells. The algorithm
for the cost distance accumulation operation uses a type of priority-flood method similar to
what is used for depression filling and flow accumulation operations.</p>
<p>NoData values in the input cost surface image are ignored during processing and assigned NoData values
in the outputs. The output cost accumulation raster is of the float data type and continuous data scale.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#costallocation"><strong>CostAllocation</strong></a>, <a href="./gis_analysis_distance_tools.html#costpathway"><strong>CostPathway</strong></a>, <a href="./gis_analysis_overlay_tools.html#weightedoverlay"><strong>WeightedOverlay</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--source           </td><td> Input source raster file</td></tr>
<tr><td>--cost             </td><td> Input cost (friction) raster file</td></tr>
<tr><td>--out_accum        </td><td> Output cost accumulation raster file</td></tr>
<tr><td>--out_backlink     </td><td> Output backlink raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cost_distance(
    source, 
    cost, 
    out_accum, 
    out_backlink, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CostDistance -v --wd=&quot;/path/to/data/&quot; ^
--source=src.tif --cost=cost.tif --out_accum=accum.tif ^
--out_backlink=backlink.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/cost_distance.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 4, 2017</p>
<p><a name="CostPathway"></a></p>
<a class="header" href="#costpathway" id="costpathway"><h1>CostPathway</h1></a>
<p>This tool can be used to map the least-cost pathway connecting each destination grid cell
in a cost-distance analysis to a source cell. The user must specify the names of the input
<em>destination</em> and <em>back-link</em> raster files. Destination cells (i.e. end points for the
least-cost path analysis) are designated as all positive, non-zero valued grid cells in the
<em>destination</em> raster. A <em>back-link</em> raster file can be created using the <a href="./gis_analysis_distance_tools.html#costdistance"><strong>CostDistance</strong></a>
tool and is conceptually similar to the D8 flow-direction pointer raster grid in that it
describes the connectivity between neighbouring cells on the accumulated cost surface. All
background grid cells in the output image are assigned the NoData value.</p>
<p>NoData values in the input <em>back-link</em> image are assigned NoData values in the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#costdistance"><strong>CostDistance</strong></a>, <a href="./gis_analysis_distance_tools.html#costallocation"><strong>CostAllocation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--destination      </td><td> Input destination raster file</td></tr>
<tr><td>--backlink         </td><td> Input backlink raster file generated by the cost-distance tool</td></tr>
<tr><td>-o, --output       </td><td> Output cost pathway raster file</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether zero values should be treated as a background</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cost_pathway(
    destination, 
    backlink, 
    output, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CostPathway -v --wd=&quot;/path/to/data/&quot; ^
--destination=dst.tif --backlink=backlink.tif ^
--output=cost_path.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/cost_pathway.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 4, 2017</p>
<p><a name="EuclideanAllocation"></a></p>
<a class="header" href="#euclideanallocation" id="euclideanallocation"><h1>EuclideanAllocation</h1></a>
<p>This tool assigns grid cells in the output image the value of the nearest target cell in
the input image, measured by the Euclidean distance (i.e. straight-line distance). Thus,
<a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a> essentially creates the Voronoi diagram for a set of target cells.
Target cells are all non-zero, non-NoData grid cells in the input image. Distances are
calculated using the same efficient algorithm (Shih and Wu, 2003) as the <a href="./gis_analysis_distance_tools.html#euclideandistance"><strong>EuclideanDistance</strong></a>
tool.</p>
<p><em>Reference</em>:</p>
<p>Shih FY and Wu Y-T (2004), Fast Euclidean distance transformation in two scans using a 3 x 3
neighborhood, <em>Computer Vision and Image Understanding</em>, 93: 195-205.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#euclideandistance"><strong>EuclideanDistance</strong></a>, <a href="./gis_analysis.html#voronoidiagram"><strong>VoronoiDiagram</strong></a>, <a href="./gis_analysis_distance_tools.html#costallocation"><strong>CostAllocation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.euclidean_allocation(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EuclideanAllocation -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/euclidean_allocation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 22 2017</p>
<p><a name="EuclideanDistance"></a></p>
<a class="header" href="#euclideandistance" id="euclideandistance"><h1>EuclideanDistance</h1></a>
<p>This tool will estimate the Euclidean distance (i.e. straight-line distance) between each
grid cell and the nearest 'target cell' in the input image. Target cells are all non-zero,
non-NoData grid cells. Distance in the output image is measured in the same units as the
horizontal units of the input image.</p>
<p><em>Algorithm Description</em>:</p>
<p>The algorithm is based on the highly efficient distance transform of Shih and Wu (2003).
It makes four passes of the image; the first pass initializes the output image; the second
and third passes calculate the minimum squared Euclidean distance by examining the 3 x 3
neighbourhood surrounding each cell; the last pass takes the square root of cell values,
transforming them into true Euclidean distances, and deals with NoData values that may be
present. All NoData value grid cells in the input image will contain NoData values in the
output image. As such, NoData is not a suitable background value for non-target cells.
Background areas should be designated with zero values.</p>
<p><em>Reference</em>:</p>
<p>Shih FY and Wu Y-T (2004), Fast Euclidean distance transformation in two scans using a 3 x 3
neighborhood, <em>Computer Vision and Image Understanding</em>, 93: 195-205.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_distance_tools.html#euclideanallocation"><strong>EuclideanAllocation</strong></a>, <a href="./gis_analysis_distance_tools.html#costdistance"><strong>CostDistance</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.euclidean_distance(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EuclideanDistance -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/euclidean_distance.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 22 2017</p>
<a class="header" href="#gis-analysis--overlay-tools" id="gis-analysis--overlay-tools"><h1>GIS Analysis → Overlay Tools</h1></a>
<ul>
<li><a href="#AverageOverlay">AverageOverlay</a></li>
<li><a href="#Clip">Clip</a></li>
<li><a href="#ClipRasterToPolygon">ClipRasterToPolygon</a></li>
<li><a href="#CountIf">CountIf</a></li>
<li><a href="#Difference">Difference</a></li>
<li><a href="#Erase">Erase</a></li>
<li><a href="#ErasePolygonFromRaster">ErasePolygonFromRaster</a></li>
<li><a href="#HighestPosition">HighestPosition</a></li>
<li><a href="#Intersect">Intersect</a></li>
<li><a href="#LineIntersections">LineIntersections</a></li>
<li><a href="#LowestPosition">LowestPosition</a></li>
<li><a href="#MaxAbsoluteOverlay">MaxAbsoluteOverlay</a></li>
<li><a href="#MaxOverlay">MaxOverlay</a></li>
<li><a href="#MergeLineSegments">MergeLineSegments</a></li>
<li><a href="#MinAbsoluteOverlay">MinAbsoluteOverlay</a></li>
<li><a href="#MinOverlay">MinOverlay</a></li>
<li><a href="#PercentEqualTo">PercentEqualTo</a></li>
<li><a href="#PercentGreaterThan">PercentGreaterThan</a></li>
<li><a href="#PercentLessThan">PercentLessThan</a></li>
<li><a href="#PickFromList">PickFromList</a></li>
<li><a href="#Polygonize">Polygonize</a></li>
<li><a href="#SplitWithLines">SplitWithLines</a></li>
<li><a href="#SumOverlay">SumOverlay</a></li>
<li><a href="#SymmetricalDifference">SymmetricalDifference</a></li>
<li><a href="#Union">Union</a></li>
<li><a href="#WeightedOverlay">WeightedOverlay</a></li>
<li><a href="#WeightedSum">WeightedSum</a></li>
</ul>
<p><a name="AverageOverlay"></a></p>
<a class="header" href="#averageoverlay" id="averageoverlay"><h1>AverageOverlay</h1></a>
<p>This tool can be used to find the average value in each cell of a grid from a set of input images (<code>--inputs</code>).
It is therefore similar to the <a href="./gis_analysis_overlay_tools.html#weightedsum"><strong>WeightedSum</strong></a> tool except that each input image is given equal weighting. This
tool operates on a cell-by-cell basis. Therefore, each of the input rasters must share the same number of rows
and columns and spatial extent. An error will be issued if this is not the case. At least two input rasters are
required to run this tool. Like each of the WhiteboxTools overlay tools, this tool has been optimized for
parallel processing.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#weightedsum"><strong>WeightedSum</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageOverlay -v --wd='/path/to/data/' ^
-i='image1.dep;image2.dep;image3.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/average_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="Clip"></a></p>
<a class="header" href="#clip" id="clip"><h1>Clip</h1></a>
<p>This tool will extract all the features, or parts of features, that overlap with the features
of the clip vector file. The clipping operation is one of the most common vector overlay
operations in GIS and effectively imposes the boundary of the clip layer on a set of input
vector features, or target features. The operation is sometimes likened to a 'cookie-cutter'.
The input vector file can be of any feature type (i.e. points, lines, polygons), however, the
clip vector must consist of polygons.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--clip             </td><td> Input clip polygon vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clip(
    i, 
    clip, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Clip -v --wd=&quot;/path/to/data/&quot; ^
-i=lines1.shp --clip=clip_poly.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/clip.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/10/2018</p>
<p><a name="ClipRasterToPolygon"></a></p>
<a class="header" href="#cliprastertopolygon" id="cliprastertopolygon"><h1>ClipRasterToPolygon</h1></a>
<p>This tool can be used to clip an input raster (<code>--input</code>) to the extent of a vector polygon (shapefile). The user
must specify the name of the input clip file (<code>--polygons</code>), wich must be a vector of a Polygon base shape type.
The clip file may contain multiple polygon features. Polygon hole parts will be respected during clipping, i.e.
polygon holes will be removed from the output raster by setting them to a NoData background value. Raster grid
cells that fall outside of a polygons in the clip file will be assigned the NoData background value in the output
file. By default, the output raster will be cropped to the spatial extent of the clip file, unless the
<code>--maintain_dimensions</code> parameter is used, in which case the output grid extent will match that of the input raster.
The grid resolution of output raster is the same as the input raster.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#erasepolygonfromraster"><strong>ErasePolygonFromRaster</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--polygons         </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--maintain_dimensions</td><td> Maintain input raster dimensions?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clip_raster_to_polygon(
    i, 
    polygons, 
    output, 
    maintain_dimensions=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ClipRasterToPolygon -v ^
--wd=&quot;/path/to/data/&quot; -i=raster.tif --polygons=poly.shp ^
-o=output.tif --maintain_dimensions 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/clip_raster_to_polygon.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/04/2018</p>
<p><a name="CountIf"></a></p>
<a class="header" href="#countif" id="countif"><h1>CountIf</h1></a>
<p>This tool counts the number of occurrences of a specified value (<code>--value</code>) in a stack of input rasters
(<code>--inputs</code>). Each grid cell in the output raster (<code>--output</code>) will contain the number of occurrences
of the specified value in the stack of cooresponding cells in the input image. At least two input rasters
are required to run this tool. Each of the input rasters must share the same number of rows and columns and
spatial extent. An error will be issued if this is not the case.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#pickfromlist"><strong>PickFromList</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--value            </td><td> Search value (e.g. countif value = 5.0)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.count_if(
    inputs, 
    output, 
    value, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CountIf -v --wd='/path/to/data/' ^
-i='image1.dep;image2.dep;image3.tif' -o=output.tif ^
--value=5.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/count_if.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/04/2018</p>
<p><a name="Difference"></a></p>
<a class="header" href="#difference" id="difference"><h1>Difference</h1></a>
<p>This tool will remove all the overlapping features, or parts of overlapping features, between
input and overlay vector files, outputting only the features that occur in one of the two
inputs but not both. The <em>Symmetrical Difference</em> is related to the Boolean
exclusive-or (<strong>XOR</strong>) operation in  set theory and is one of the common vector overlay
operations in GIS. The user must specify  the names of the input and overlay vector files
as well as the output vector file name. The tool operates on vector points,
lines, or polygon, but both the input and overlay files must contain the same ShapeType.</p>
<p>The <em>Symmetrical Difference</em> can also be derived using a combination of other vector
overlay operations, as either <code>(A union B) difference (A intersect B)</code>, or
<code>(A difference B) union (B difference A)</code>.</p>
<p>The attributes of the two input vectors will be merged in the output attribute table.
Fields that are duplicated between the inputs will share a single attribute in the
output. Fields that only exist in one of the two inputs will be populated by <code>null</code>
in the output table. Multipoint ShapeTypes however will simply contain a single
ouptut feature indentifier (<code>FID</code>) attribute. Also, note that depending on the
ShapeType (polylines and polygons), <code>Measure</code> and <code>Z</code> ShapeDimension data will not
be transfered to the output geometries. If the input attribute table contains fields
that measure the geometric properties of their associated features (e.g. length or area),
these fields will not be updated to reflect changes in geometry shape and size
resulting from the overlay operation.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#intersect"><strong>Intersect</strong></a>, <a href="./gis_analysis_overlay_tools.html#difference"><strong>Difference</strong></a>, <a href="./gis_analysis_overlay_tools.html#union"><strong>Union</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--overlay          </td><td> Input overlay vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.difference(
    i, 
    overlay, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Difference -v --wd=&quot;/path/to/data/&quot; ^
-input=layer1.shp --overlay=layer2.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/difference.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 8/11/2018</p>
<p><a name="Erase"></a></p>
<a class="header" href="#erase" id="erase"><h1>Erase</h1></a>
<p>This tool will remove all the features, or parts of features, that overlap with the features
of the erase vector file. The erasing operation is one of the most common vector overlay
operations in GIS and effectively imposes the boundary of the erase layer on a set of input
vector features, or target features.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--erase            </td><td> Input erase polygon vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.erase(
    i, 
    erase, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Erase -v --wd=&quot;/path/to/data/&quot; ^
-i=lines1.shp --erase=erase_poly.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/erase.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 4/11/2018</p>
<p><a name="ErasePolygonFromRaster"></a></p>
<a class="header" href="#erasepolygonfromraster" id="erasepolygonfromraster"><h1>ErasePolygonFromRaster</h1></a>
<p>This tool can be used to set values an input raster (<code>--input</code>) to a NoData background value with a vector
erasing polygon (<code>--polygons</code>). The input erase polygon file must be a vector of a Polygon base shape type.
The erase file may contain multiple polygon features. Polygon hole parts will be respected during clipping, i.e.
polygon holes will not be removed from the output raster. Raster grid cells that fall inside of a polygons in
the erase file will be assigned the NoData background value in the output file.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#cliprastertopolygon"><strong>ClipRasterToPolygon</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--polygons         </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.erase_polygon_from_raster(
    i, 
    polygons, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ErasePolygonFromRaster -v ^
--wd=&quot;/path/to/data/&quot; -i='DEM.tif' --polygons='lakes.shp' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/erase_polygon_from_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/03/2018</p>
<p><a name="HighestPosition"></a></p>
<a class="header" href="#highestposition" id="highestposition"><h1>HighestPosition</h1></a>
<p>This tool identifies the stack position (index) of the maximum value within a raster stack on a cell-by-cell
basis. For example, if five raster images (<code>--inputs</code>) are input to the tool, the output raster (<code>--output</code>)
would show which of the five input rasters contained the highest value for each grid cell. The index value in
the output raster is the zero-order number of the raster stack, i.e. if the highest value in the stack is
contained in the first image, the output value would be 0; if the highest stack value were the second image,
the output value would be 1, and so on. If any of the cell values within the stack is NoData, the output raster
will contain the NoData value for the corresponding grid cell. The index value is related to the order of the
input images.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#lowestposition"><strong>LowestPosition</strong></a>, <a href="./gis_analysis_overlay_tools.html#pickfromlist"><strong>PickFromList</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.highest_position(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HighestPosition -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/highest_pos.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="Intersect"></a></p>
<a class="header" href="#intersect" id="intersect"><h1>Intersect</h1></a>
<p>The result of the <a href="./gis_analysis_overlay_tools.html#intersect"><strong>Intersect</strong></a> vector overlay operation includes all the feature parts that
occur in both input layers, excluding all other parts. It is analogous to the <strong>OR</strong>
logical operator and multiplication in arithmetic. This tool is one of the common vector overlay
operations in GIS. The user must specify the names of the input and overlay vector files
as well as the output vector file name. The tool operates on vector points,
lines, or polygon, but both the input and overlay files must contain the same ShapeType.</p>
<p>The <a href="./gis_analysis_overlay_tools.html#intersect"><strong>Intersect</strong></a> tool is similar to the <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a> tool. The difference is that the overlay vector
layer in a <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a> operation must always be polygons, regardless of whether the input layer
consists of points or polylines.</p>
<p>The attributes of the two input vectors will be merged in the output attribute table.
Note, duplicate fields should not exist between the inputs layers, as they will share a
single attribute in the output (assigned from the first layer). Multipoint ShapeTypes will
simply contain a single  ouptut feature indentifier (<code>FID</code>) attribute. Also, note that depending
on the ShapeType (polylines and polygons), <code>Measure</code> and <code>Z</code> ShapeDimension data will not
be transfered to the output geometries. If the input attribute table contains fields
that measure the geometric properties of their associated features (e.g. length or area),
these fields will not be updated to reflect changes in geometry shape and size
resulting from the overlay operation.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#difference"><strong>Difference</strong></a>, <a href="./gis_analysis_overlay_tools.html#union"><strong>Union</strong></a>, <a href="./gis_analysis_overlay_tools.html#symmetricaldifference"><strong>SymmetricalDifference</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--overlay          </td><td> Input overlay vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap             </td><td> Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.intersect(
    i, 
    overlay, 
    output, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Intersect -v --wd=&quot;/path/to/data/&quot; ^
-input=layer1.shp --overlay=layer2.shp -o=out_file.shp ^
--snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/intersect.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 8/11/2018</p>
<p><a name="LineIntersections"></a></p>
<a class="header" href="#lineintersections" id="lineintersections"><h1>LineIntersections</h1></a>
<p>This tool identifies points where the features of two vector line/polygon layers
intersect. The user must specify the names of two input vector line files and the
output file. The output file will be a vector of POINT ShapeType. If the input
vectors intersect at a line segment, the beginning and end vertices of the segment
will be present in the output file. A warning is issued if intersection line segments
are identified during analysis. If no intersections are found between the input line
files, the output file will not be saved and a warning will be issued.</p>
<p>Each intersection point will contain <code>PARENT1</code> and <code>PARENT2</code> attribute fields,
identifying the instersecting features in the first and second input line files
respectively. Additionally, the output attribute table will contain all of the
attributes (excluding <code>FID</code>s) of the two parent line features.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input vector polyline file</td></tr>
<tr><td>--i2, --input2    </td><td> Input vector polyline file</td></tr>
<tr><td>-o, --output       </td><td> Output vector point file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.line_intersections(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LineIntersections -v ^
--wd=&quot;/path/to/data/&quot; --i1=lines1.shp --i2=lines2.shp ^
-o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/line_intersections.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/10/2018</p>
<p><a name="LowestPosition"></a></p>
<a class="header" href="#lowestposition" id="lowestposition"><h1>LowestPosition</h1></a>
<p>This tool identifies the stack position (index) of the minimum value within a raster stack on a cell-by-cell
basis. For example, if five raster images (<code>--inputs</code>) are input to the tool, the output raster (<code>--output</code>)
would show which of the five input rasters contained the lowest value for each grid cell. The index value in
the output raster is the zero-order number of the raster stack, i.e. if the lowest value in the stack is
contained in the first image, the output value would be 0; if the lowest stack value were the second image,
the output value would be 1, and so on. If any of the cell values within the stack is NoData, the output raster
will contain the NoData value for the corresponding grid cell. The index value is related to the order of the
input images.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#highestposition"><strong>HighestPosition</strong></a>, <a href="./gis_analysis_overlay_tools.html#pickfromlist"><strong>PickFromList</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lowest_position(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LowestPosition -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/lowest_pos.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/07/2017</p>
<p><a name="MaxAbsoluteOverlay"></a></p>
<a class="header" href="#maxabsoluteoverlay" id="maxabsoluteoverlay"><h1>MaxAbsoluteOverlay</h1></a>
<p>This tool can be used to find the maximum absolute (non-negative) value in each cell of a grid from a set of
input images (<code>--inputs</code>). NoData values in any of the input images will result in a NoData pixel in the output
image.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows
and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#maxoverlay"><strong>MaxOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#minabsoluteoverlay"><strong>MinAbsoluteOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#minoverlay"><strong>MinOverlay</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_absolute_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxAbsoluteOverlay -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/max_abs_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="MaxOverlay"></a></p>
<a class="header" href="#maxoverlay" id="maxoverlay"><h1>MaxOverlay</h1></a>
<p>This tool can be used to find the maximum value in each cell of a grid from a set of input images (<code>--inputs</code>).
NoData values in any of the input images will result in a NoData pixel in the output image (<code>--output</code>). It is
similar to the <a href="./mathand_stats_tools.html#max"><strong>Max</strong></a> mathematical tool, except that it will accept more than two input images.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#minoverlay"><strong>MinOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#maxabsoluteoverlay"><strong>MaxAbsoluteOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#minabsoluteoverlay"><strong>MinAbsoluteOverlay</strong></a>, <a href="./mathand_stats_tools.html#max"><strong>Max</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxOverlay -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/max_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="MergeLineSegments"></a></p>
<a class="header" href="#mergelinesegments" id="mergelinesegments"><h1>MergeLineSegments</h1></a>
<p>Vector lines can sometimes contain two features that are connected by a shared end vertex. This tool
identifies connected line features in an input vector file (<code>--input</code>) and merges them in the output
file (<code>--output</code>). Two line features are merged if their ends are coincident, and are not coincident
with any other feature (i.e. a bifurcation junction). End vertices are considered to be coincident if
they are within the specified snap distance (<code>--snap</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#splitwithlines"><strong>SplitWithLines</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap             </td><td> Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.merge_line_segments(
    i, 
    output, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MergeLineSegments -v ^
--wd=&quot;/path/to/data/&quot; --input=layer1.shp -o=out_file.shp ^
--snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/merge_line_segments.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 09/04/2019</p>
<p><a name="MinAbsoluteOverlay"></a></p>
<a class="header" href="#minabsoluteoverlay" id="minabsoluteoverlay"><h1>MinAbsoluteOverlay</h1></a>
<p>This tool can be used to find the minimum absolute (non-negative) value in each cell of a grid from a set of
input images (<code>--inputs</code>). NoData values in any of the input images will result in a NoData pixel in the output
image.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows
and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#minoverlay"><strong>MinOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#maxabsoluteoverlay"><strong>MaxAbsoluteOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#maxoverlay"><strong>MaxOverlay</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_absolute_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinAbsoluteOverlay -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/min_abs_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="MinOverlay"></a></p>
<a class="header" href="#minoverlay" id="minoverlay"><h1>MinOverlay</h1></a>
<p>This tool can be used to find the minimum value in each cell of a grid from a set of input images (<code>--inputs</code>).
NoData values in any of the input images will result in a NoData pixel in the output image (<code>--output</code>). It is
similar to the <a href="./mathand_stats_tools.html#min"><strong>Min</strong></a> mathematical tool, except that it will accept more than two input images.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#maxoverlay"><strong>MaxOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#maxabsoluteoverlay"><strong>MaxAbsoluteOverlay</strong></a>, <a href="./gis_analysis_overlay_tools.html#minabsoluteoverlay"><strong>MinAbsoluteOverlay</strong></a>, <a href="./mathand_stats_tools.html#min"><strong>Min</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinOverlay -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/min_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PercentEqualTo"></a></p>
<a class="header" href="#percentequalto" id="percentequalto"><h1>PercentEqualTo</h1></a>
<p>This tool calculates the percentage of a raster stack (<code>--inputs</code>) that have cell values equal to an input <em>comparison</em>
raster. The user must specify the name of the value raster (<code>--comparison</code>), the names of the raster files contained
in the stack, and an output raster file name (<code>--output</code>). The tool, working on a cell-by-cell basis, will count the
number of rasters within the stack that have the same grid cell value as the corresponding grid cell in the <em>comparison</em>
raster. This count is then expressed as a percentage of the number of rasters contained within the stack and output.
If any of the rasters within the stack contain the NoData value, the corresponding grid cell in the output raster will
be assigned NoData.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#percentgreaterthan"><strong>PercentGreaterThan</strong></a>, <a href="./gis_analysis_overlay_tools.html#percentlessthan"><strong>PercentLessThan</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--comparison       </td><td> Input comparison raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_equal_to(
    inputs, 
    comparison, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentEqualTo -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' --comparison='comp.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/percent_equal_to.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PercentGreaterThan"></a></p>
<a class="header" href="#percentgreaterthan" id="percentgreaterthan"><h1>PercentGreaterThan</h1></a>
<p>This tool calculates the percentage of a raster stack (<code>--inputs</code>) that have cell values greater than an input <em>comparison</em>
raster. The user must specify the name of the value raster (<code>--comparison</code>), the names of the raster files contained
in the stack, and an output raster file name (<code>--output</code>). The tool, working on a cell-by-cell basis, will count the
number of rasters within the stack with larger grid cell values greater than the corresponding grid cell in the <em>comparison</em>
raster. This count is then expressed as a percentage of the number of rasters contained within the stack and output.
If any of the rasters within the stack contain the NoData value, the corresponding grid cell in the output raster will
be assigned NoData.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#percentlessthan"><strong>PercentLessThan</strong></a>, <a href="./gis_analysis_overlay_tools.html#percentequalto"><strong>PercentEqualTo</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--comparison       </td><td> Input comparison raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_greater_than(
    inputs, 
    comparison, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentGreaterThan -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
--comparison='comp.tif' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/percent_greater_than.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PercentLessThan"></a></p>
<a class="header" href="#percentlessthan" id="percentlessthan"><h1>PercentLessThan</h1></a>
<p>This tool calculates the percentage of a raster stack (<code>--inputs</code>) that have cell values less than an input <em>comparison</em>
raster. The user must specify the name of the value raster (<code>--comparison</code>), the names of the raster files contained
in the stack, and an output raster file name (<code>--output</code>). The tool, working on a cell-by-cell basis, will count the
number of rasters within the stack with larger grid cell values less than the corresponding grid cell in the <em>comparison</em>
raster. This count is then expressed as a percentage of the number of rasters contained within the stack and output.
If any of the rasters within the stack contain the NoData value, the corresponding grid cell in the output raster will
be assigned NoData.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#percentgreaterthan"><strong>PercentGreaterThan</strong></a>, <a href="./gis_analysis_overlay_tools.html#percentequalto"><strong>PercentEqualTo</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--comparison       </td><td> Input comparison raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percent_less_than(
    inputs, 
    comparison, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentLessThan -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
--comparison='comp.tif' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/percent_less_than.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PickFromList"></a></p>
<a class="header" href="#pickfromlist" id="pickfromlist"><h1>PickFromList</h1></a>
<p>This tool outputs the cell value from a raster stack specified (<code>--inputs</code>) by a position raster (<code>--pos_input</code>). The
user must specify the name of the position raster, the names of the raster files contained in the stack (i.e. group
of rasters), and an output raster file name (<code>--output</code>). The tool, working on a cell-by-cell basis, will assign the
value to the output grid cell contained in the corresponding cell in the stack image in the position specified by the
cell value in the position raster. Importantly, the positions raster should be in zero-based order. That is, the first
image in the stack should be assigned the value zero, the second raster is assigned 1, and so on.</p>
<p>At least two input rasters are required to run this tool. Each of the input rasters must share the same number of rows
and columns and spatial extent. An error will be issued if this is not the case.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#countif"><strong>CountIf</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--pos_input        </td><td> Input position raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.pick_from_list(
    inputs, 
    pos_input, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PickFromList -v --wd='/path/to/data/' ^
--pos_input=position.tif -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/pick_from_list.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="Polygonize"></a></p>
<a class="header" href="#polygonize" id="polygonize"><h1>Polygonize</h1></a>
<p>This tool outputs a vector polygon layer from two or more intersecting line features
contained in one or more input vector line files. Each space enclosed by the intersecting
line set is converted to polygon added to the output layer. This tool should not be
confused with the <a href="./data_tools.html#linestopolygons"><strong>LinesToPolygons</strong></a> tool, which can be used to convert a vector file of
polylines into a set of polygons, simply by closing each line feature. The <a href="./data_tools.html#linestopolygons"><strong>LinesToPolygons</strong></a>
tool does not deal with line intersection in the same way that the <a href="./gis_analysis_overlay_tools.html#polygonize"><strong>Polygonize</strong></a> tool does.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#linestopolygons"><strong>LinesToPolygons</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input vector polyline file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.polygonize(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Polygonize -v --wd=&quot;/path/to/data/&quot; ^
-i='lines1.shp;lines2.shp;lines3.shp' -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/polygonize.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/10/2018</p>
<p><a name="SplitWithLines"></a></p>
<a class="header" href="#splitwithlines" id="splitwithlines"><h1>SplitWithLines</h1></a>
<p>This tool splits the lines or polygons in one layer using the lines in another layer
to define the breaking points. Intersection points between geometries in both layers
are considered as split points. The input layer (<code>--input</code>) can be of either
POLYLINE or POLYGON ShapeType and the output file will share this geometry type.
The user must also specify an split layer (<code>--split</code>), of POLYLINE ShapeType, used
to bisect the input geometries.</p>
<p>Each split geometry's attribute record will contain <code>FID</code> and <code>PARENT_FID</code> values
and all of the attributes (excluding <code>FID</code>'s) of the input layer.</p>
<p><em>See Also</em>:</p>
<p>'MergeLineSegments'</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector line or polygon file</td></tr>
<tr><td>--split            </td><td> Input vector polyline file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.split_with_lines(
    i, 
    split, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SplitWithLines -v --wd=&quot;/path/to/data/&quot; ^
--input=polygons.shp --split=lines.shp -o=out_file.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/split_with_lines.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/10/2018</p>
<p><a name="SumOverlay"></a></p>
<a class="header" href="#sumoverlay" id="sumoverlay"><h1>SumOverlay</h1></a>
<p>This tool calculates the sum for each grid cell from a group of raster images (<code>--inputs</code>). NoData values in any of the input
images will result in a NoData pixel in the output image (<code>--output</code>).</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#weightedsum"><strong>WeightedSum</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sum_overlay(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SumOverlay -v --wd='/path/to/data/' ^
-i='image1.dep;image2.dep;image3.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/sum_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/09/2018</p>
<p><a name="SymmetricalDifference"></a></p>
<a class="header" href="#symmetricaldifference" id="symmetricaldifference"><h1>SymmetricalDifference</h1></a>
<p>This tool will remove all the overlapping features, or parts of overlapping features, between
input and overlay vector files, outputting only the features that occur in one of the two
inputs but not both. The <em>Symmetrical Difference</em> is related to the Boolean
exclusive-or (<strong>XOR</strong>) operation in  set theory and is one of the common vector overlay
operations in GIS. The user must specify  the names of the input and overlay vector files
as well as the output vector file name. The tool operates on vector points,
lines, or polygon, but both the input and overlay files must contain the same ShapeType.</p>
<p>The <em>Symmetrical Difference</em> can also be derived using a combination of other vector
overlay operations, as either <code>(A union B) difference (A intersect B)</code>, or
<code>(A difference B) union (B difference A)</code>.</p>
<p>The attributes of the two input vectors will be merged in the output attribute table.
Fields that are duplicated between the inputs will share a single attribute in the
output. Fields that only exist in one of the two inputs will be populated by <code>null</code>
in the output table. Multipoint ShapeTypes however will simply contain a single
ouptut feature indentifier (<code>FID</code>) attribute. Also, note that depending on the
ShapeType (polylines and polygons), <code>Measure</code> and <code>Z</code> ShapeDimension data will not
be transfered to the output geometries. If the input attribute table contains fields
that measure the geometric properties of their associated features (e.g. length or area),
these fields will not be updated to reflect changes in geometry shape and size
resulting from the overlay operation.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#intersect"><strong>Intersect</strong></a>, <a href="./gis_analysis_overlay_tools.html#difference"><strong>Difference</strong></a>, <a href="./gis_analysis_overlay_tools.html#union"><strong>Union</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--overlay          </td><td> Input overlay vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap             </td><td> Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.symmetrical_difference(
    i, 
    overlay, 
    output, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SymmetricalDifference -v ^
--wd=&quot;/path/to/data/&quot; -input=layer1.shp --overlay=layer2.shp ^
-o=out_file.shp --snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/symmetrical_difference.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 5/11/2018</p>
<p><a name="Union"></a></p>
<a class="header" href="#union" id="union"><h1>Union</h1></a>
<p>This tool splits vector layers at their overlaps, creating a layer containing all the portions from both
input and overlay layers. The <em>Union</em> is related to the Boolean
<strong>OR</strong> operation in  set theory and is one of the common vector overlay
operations in GIS. The user must specify  the names of the input and overlay vector files
as well as the output vector file name. The tool operates on vector points,
lines, or polygon, but both the input and overlay files must contain the same ShapeType.</p>
<p>The attributes of the two input vectors will be merged in the output attribute table.
Fields that are duplicated between the inputs will share a single attribute in the
output. Fields that only exist in one of the two inputs will be populated by <code>null</code>
in the output table. Multipoint ShapeTypes however will simply contain a single
ouptut feature indentifier (<code>FID</code>) attribute. Also, note that depending on the
ShapeType (polylines and polygons), <code>Measure</code> and <code>Z</code> ShapeDimension data will not
be transfered to the output geometries. If the input attribute table contains fields
that measure the geometric properties of their associated features (e.g. length or area),
these fields will not be updated to reflect changes in geometry shape and size
resulting from the overlay operation.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#intersect"><strong>Intersect</strong></a>, <a href="./gis_analysis_overlay_tools.html#difference"><strong>Difference</strong></a>, <a href="./gis_analysis_overlay_tools.html#symmetricaldifference"><strong>SymmetricalDifference</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#erase"><strong>Erase</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector file</td></tr>
<tr><td>--overlay          </td><td> Input overlay vector file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap             </td><td> Snap tolerance</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.union(
    i, 
    overlay, 
    output, 
    snap=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Union -v --wd=&quot;/path/to/data/&quot; ^
-input=layer1.shp --overlay=layer2.shp -o=out_file.shp ^
--snap=0.0000001 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/union.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/11/2018</p>
<p><a name="WeightedOverlay"></a></p>
<a class="header" href="#weightedoverlay" id="weightedoverlay"><h1>WeightedOverlay</h1></a>
<p>This tool performs a weighted overlay on multiple input images. It can be used to
combine multiple factors with varying levels of weight or relative importance. The
WeightedOverlay tool is similar to the WeightedSum tool but is more powerful because
it automatically converts the input factors to a common user-defined scale and allows
the user to specify benefit factors and cost factors. A benefit factor is a factor
for which higher values are more suitable. A cost factor is a factor for which higher
values are less suitable. By default, WeightedOverlay assumes that input images are
benefit factors, unless a cost value of 'true' is entered in the cost array.
Constraints are absolute restriction with values of 0 (unsuitable) and 1 (suitable).
This tool is particularly useful for performing multi-criteria evaluations (MCE).</p>
<p>Notice that the algorithm will convert the user-defined factor weights internally such
that the sum of the weights is always equal to one. As such, the user can specify the
relative weights as decimals, percentages, or relative weightings (e.g. slope is 2 times
more important than elevation, in which case the weights may not sum to 1 or 100).</p>
<p>NoData valued grid cells in any of the input images will be assigned NoData values in
the output image. The output raster is of the float data type and continuous data scale.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows
and columns.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--factors          </td><td> Input factor raster files</td></tr>
<tr><td>-w, --weights      </td><td> Weight values, contained in quotes and separated by commas or semicolons. Must have the same number as factors</td></tr>
<tr><td>--cost             </td><td> Weight values, contained in quotes and separated by commas or semicolons. Must have the same number as factors</td></tr>
<tr><td>--constraints      </td><td> Input constraints raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--scale_max        </td><td> Suitability scale maximum value (common values are 1.0, 100.0, and 255.0)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.weighted_overlay(
    factors, 
    weights, 
    output, 
    cost=None, 
    constraints=None, 
    scale_max=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WeightedOverlay -v ^
--wd='/path/to/data/' ^
--factors='image1.tif;image2.tif;image3.tif' ^
--weights='0.3;0.2;0.5' --cost='false;false;true' -o=output.tif ^
--scale_max=100.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/weighted_overlay.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 07/05/2018</p>
<p><a name="WeightedSum"></a></p>
<a class="header" href="#weightedsum" id="weightedsum"><h1>WeightedSum</h1></a>
<p>This tool performs a weighted-sum overlay on multiple input raster images.
If you have a stack of rasters that you would like to sum, each with an
equal weighting (1.0), then use the <a href="./gis_analysis_overlay_tools.html#sumoverlay"><strong>SumOverlay</strong></a> tool instead.</p>
<p><em>Warning</em>:</p>
<p>Each of the input rasters must have the same spatial extent and number of rows
and columns.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_overlay_tools.html#sumoverlay"><strong>SumOverlay</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-w, --weights      </td><td> Weight values, contained in quotes and separated by commas or semicolons</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.weighted_sum(
    inputs, 
    weights, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WeightedSum -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' --weights='0.3;0.2;0.5' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/weighted_sum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<a class="header" href="#gis-analysis--patch-shape-tools" id="gis-analysis--patch-shape-tools"><h1>GIS Analysis → Patch Shape Tools</h1></a>
<ul>
<li><a href="#BoundaryShapeComplexity">BoundaryShapeComplexity</a></li>
<li><a href="#CompactnessRatio">CompactnessRatio</a></li>
<li><a href="#EdgeProportion">EdgeProportion</a></li>
<li><a href="#ElongationRatio">ElongationRatio</a></li>
<li><a href="#FindPatchOrClassEdgeCells">FindPatchOrClassEdgeCells</a></li>
<li><a href="#HoleProportion">HoleProportion</a></li>
<li><a href="#LinearityIndex">LinearityIndex</a></li>
<li><a href="#NarrownessIndex">NarrownessIndex</a></li>
<li><a href="#PatchOrientation">PatchOrientation</a></li>
<li><a href="#PerimeterAreaRatio">PerimeterAreaRatio</a></li>
<li><a href="#RadiusOfGyration">RadiusOfGyration</a></li>
<li><a href="#RelatedCircumscribingCircle">RelatedCircumscribingCircle</a></li>
<li><a href="#ShapeComplexityIndex">ShapeComplexityIndex</a></li>
<li><a href="#ShapeComplexityIndexRaster">ShapeComplexityIndexRaster</a></li>
</ul>
<p><a name="BoundaryShapeComplexity"></a></p>
<a class="header" href="#boundaryshapecomplexity" id="boundaryshapecomplexity"><h1>BoundaryShapeComplexity</h1></a>
<p>This tools calculates a type of shape complexity index for raster objects, focused on the complexity of the
boundary of polygons. The index uses the <a href="./image_processing_tools.html#linethinning"><strong>LineThinning</strong></a> tool to estimate a skeletonized network for each
input raster polygon. The Boundary Shape Complexity (BSC) index is then calculated as the percentage of the
skeletonized network belonging to exterior links. Polygons with more complex boundaries will possess
more branching skeletonized networks, with each spur in the boundary possessing a short exterior branch. The
two longest exterior links in the network are considered to be part of the main network.  Therefore,
polygons of complex shaped boundaries will have a higher percentage of their skeleton networks consisting
of exterior links. It is expected that simple convex hulls should have relatively low BSC index values.</p>
<p>Objects in the input raster (<code>--input</code>) are designated by their unique identifers. Identifer values should be
positive, non-zero whole numbers.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindexraster"><strong>ShapeComplexityIndexRaster</strong></a>, <a href="./image_processing_tools.html#linethinning"><strong>LineThinning</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.boundary_shape_complexity(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BoundaryShapeComplexity -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/boundary_shape_complexity.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/02/2019</p>
<p><a name="CompactnessRatio"></a></p>
<a class="header" href="#compactnessratio" id="compactnessratio"><h1>CompactnessRatio</h1></a>
<p>The compactness ratio is an indicator of polygon shape complexity. The compactness
ratio is defined as the polygon area divided by its perimeter. Unlike some other
shape parameters (e.g. <a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindex"><strong>ShapeComplexityIndex</strong></a>), compactness ratio does not standardize
to a simple Euclidean shape. Although widely used for landscape analysis, compactness
ratio, like its inverse, the <a href="./gis_analysis_patch_shape_tools.html#perimeterarearatio"><strong>PerimeterAreaRatio</strong></a>, exhibits the undesirable property
of polygon size dependence (Mcgarigal et al. 2002). That is, holding shape constant,
an increase in polygon size will cause a change in the compactness ratio.</p>
<p>The output data will be contained in the input vector's attribute table as a new field
(COMPACT).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#perimeterarearatio"><strong>PerimeterAreaRatio</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindex"><strong>ShapeComplexityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#relatedcircumscribingcircle"><strong>RelatedCircumscribingCircle</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.compactness_ratio(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CompactnessRatio -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/compactness_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2018</p>
<p><a name="EdgeProportion"></a></p>
<a class="header" href="#edgeproportion" id="edgeproportion"><h1>EdgeProportion</h1></a>
<p>This tool will measure the edge proportion, i.e. the proportion of grid cells in a patch that are located along the
patch's boundary, for an input raster image (<code>--input</code>). Edge proportion is an indicator of polygon shape complexity
and elongation. The user must specify the name of the output raster file (<code>--output</code>), which will be raster layer
containing the input features assigned the edge proportion. The user may also optionally choose to output text data
for easy input to a spreadsheet or database.</p>
<p>Objects in the input raster are designated by their unique identifers. Identifer values must
be positive, non-zero whole numbers.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindexraster"><strong>ShapeComplexityIndexRaster</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#linearityindex"><strong>LinearityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--output_text      </td><td> flag indicating whether a text report should also be output</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.edge_proportion(
    i, 
    output, 
    output_text=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgeProportion -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --output_text 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/edge_proportion.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="ElongationRatio"></a></p>
<a class="header" href="#elongationratio" id="elongationratio"><h1>ElongationRatio</h1></a>
<p>This tool can be used to calculate the elongation ratio for vector polygons. The
elongation ratio values calculated for each vector polygon feature will be placed
in the accompanying database file (.dbf) as an elongation field (ELONGATION).</p>
<p>The elongation ratio (<code>E</code>) is:</p>
<blockquote>
<p>E = 1 - S / L</p>
</blockquote>
<p>Where <code>S</code> is the short-axis length, and <code>L</code> is the long-axis length. Axes
lengths are determined by estimating the minimum bounding box.</p>
<p>The elongation ratio provides similar information as the Linearity Index. The
ratio is not an adequate measure of overall polygon narrowness, because a highly
sinuous but narrow polygon will have a low linearity (elongation) owing to the
compact nature of these polygon.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elongation_ratio(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElongationRatio -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/elongation_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="FindPatchOrClassEdgeCells"></a></p>
<a class="header" href="#findpatchorclassedgecells" id="findpatchorclassedgecells"><h1>FindPatchOrClassEdgeCells</h1></a>
<p>This tool will identify all grid cells situated along the edges of patches or class features within an
input raster (<code>--input</code>). Edge cells in the output raster (<code>--output</code>) will have the patch identifier value
assigned in the correponding grid cell. All non-edge cells will be assigned zero in the output raster.
Patches (or classes) are designated by positive, non-zero values in the input image. Zero-valued
and NoData-valued grid cells are interpreted as background cells by the tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#edgeproportion"><strong>EdgeProportion</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_patch_or_class_edge_cells(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindPatchOrClassEdgeCells -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/find_patch_edge_cells.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/07/2017</p>
<p><a name="HoleProportion"></a></p>
<a class="header" href="#holeproportion" id="holeproportion"><h1>HoleProportion</h1></a>
<p>This calculates the proportion of the total area of a polygon's holes (i.e. islands)
relative to the area of the polygon's hull. It can be a useful measure of shape
complexity, or how discontinuous a patch is. The user must specify the name of the
input vector file and the output data will be contained within the input vector's
database file as a new field (HOLE_PROP).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindex"><strong>ShapeComplexityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#perimeterarearatio"><strong>PerimeterAreaRatio</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hole_proportion(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HoleProportion -v --wd=&quot;/path/to/data/&quot; ^
--input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/hole_proportion.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/09/2018</p>
<p><a name="LinearityIndex"></a></p>
<a class="header" href="#linearityindex" id="linearityindex"><h1>LinearityIndex</h1></a>
<p>This tool calculates the linearity index of polygon features based on a regression analysis.
The index is simply the coefficient of determination (r-squared) calculated from a regression
analysis of the x and y coordinates of the exterior hull nodes of a vector polygon. Linearity
index is a measure of how well a polygon can be described by a straight line. It is a related
index to the <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a>, but is more efficient to calculate as it does not require
finding the minimum bounding box. The Pearson correlation coefficient between linearity index
and the elongation ratio for a large data set of lake polygons in northern Canada was found
to be 0.656, suggesting a moderate level of association between the two measures of polygon
linearity. Note that this index is not useful for identifying narrow yet sinuous polygons, such
as meandering rivers.</p>
<p>The only required input is the name of the file. The linearity values calculated for each vector
polygon feature will be placed in the accompanying attribute table as a new field (LINEARITY).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#patchorientation"><strong>PatchOrientation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.linearity_index(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LinearityIndex -v --wd=&quot;/path/to/data/&quot; ^
--input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/linearity_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/10/2018</p>
<p><a name="NarrownessIndex"></a></p>
<a class="header" href="#narrownessindex" id="narrownessindex"><h1>NarrownessIndex</h1></a>
<p>This tools calculates a type of shape narrowness index (<em>NI</em>) for raster objects. The index is equal to:</p>
<blockquote>
<p><em>NI</em> = <em>A</em> / (π<em>MD</em><sup>2</sup>)</p>
</blockquote>
<p>where <em>A</em> is the patch area and <em>MD</em> is the maximum distance-to-edge of the patch. Circular-shaped patches
will have a narrowness index near 1.0, while more narrow patche shapes will have higher index values. The
index may be conceptualized as the ratio of the patch area to the area of the largest contained circle,
although in practice the circle defined by the radius of the maximum distance-to-edge will often fall
outside the patch boundaries.</p>
<p>Objects in the input raster (<code>--input</code>) are designated by their unique identifers. Identifer values must
be positive, non-zero whole numbers.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#linearityindex"><strong>LinearityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.narrowness_index(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NarrownessIndex -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/narrowness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 17/02/2019</p>
<p><a name="PatchOrientation"></a></p>
<a class="header" href="#patchorientation" id="patchorientation"><h1>PatchOrientation</h1></a>
<p>This tool calculates the orientation of polygon features based on the slope of a reduced major
axis (RMA) regression line. The regression analysis use the vertices of the exterior hull nodes
of a vector polygon. The only required input is the name of the vector polygon file. The
orientation values, measured in degrees from north, will be placed in the accompanying attribute
table as a new field (ORIENT). The value of the orientation measure for any polygon will
depend on how elongated the feature is.</p>
<p>Note that the output values are polygon orientations and not true directions. While directions
may take values ranging from 0-360, orientation is expressed as an angle between 0 and 180 degrees
clockwise from north. Lastly, the orientation measure may become unstable when polygons are
oriented nearly vertical or horizontal.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#linearityindex"><strong>LinearityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.patch_orientation(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PatchOrientation -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/patch_orientation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/10/2018</p>
<p><a name="PerimeterAreaRatio"></a></p>
<a class="header" href="#perimeterarearatio" id="perimeterarearatio"><h1>PerimeterAreaRatio</h1></a>
<p>The perimeter-area ratio is an indicator of polygon shape complexity. Unlike some
other shape parameters (e.g. shape complexity index), perimeter-area ratio does not
standardize to a simple Euclidean shape. Although widely used for landscape analysis,
perimeter-area ratio exhibits the undesirable property of polygon size dependence
(Mcgarigal et al. 2002). That is, holding shape constant, an increase in polygon
size will cause a decrease in the perimeter-area ratio. The perimeter-area ratio is
the inverse of the compactness ratio.</p>
<p>The output data will be displayed as a new field (P-A_RATIO) in the input vector's
database file.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.perimeter_area_ratio(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PerimeterAreaRatio -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/perimeter_area_ratio.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/09/2018</p>
<p><a name="RadiusOfGyration"></a></p>
<a class="header" href="#radiusofgyration" id="radiusofgyration"><h1>RadiusOfGyration</h1></a>
<p>This can be used to calculate the radius of gyration (RoG) for the polygon
features within a raster image. RoG measures how far across the landscape a polygon
extends its reach on average, given by the mean distance between cells in a patch
(Mcgarigal et al. 2002). The radius of gyration can be considered a measure of the
average distance an organism can move within a patch before encountering the patch
boundary from a random starting point (Mcgarigal et al. 2002). The input raster grid
should contain polygons with unique identifiers greater than zero. The user must also
specify the name of the output raster file (where the radius of gyration will be
assigned to each feature in the input file) and the specified option of outputting text
data.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--text_output      </td><td> Optional text output</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.radius_of_gyration(
    i, 
    output, 
    text_output=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RadiusOfGyration -v ^
--wd=&quot;/path/to/data/&quot; -i=polygons.tif -o=output.tif ^
--text_output 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/radius_of_gyration.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: December 31 2017</p>
<p><a name="RelatedCircumscribingCircle"></a></p>
<a class="header" href="#relatedcircumscribingcircle" id="relatedcircumscribingcircle"><h1>RelatedCircumscribingCircle</h1></a>
<p>This tool can be used to calculate the related circumscribing circle (Mcgarigal et al. 2002)
for vector polygon features. The related circumscribing circle values calculated for each
vector polygon feature will be placed in the accompanying attribute table as a new field
(RC_CIRCLE).</p>
<p>Related circumscribing circle (RCC) is defined as:</p>
<blockquote>
<p>RCC = 1 - A / Ac</p>
</blockquote>
<p>Where <code>A</code> is the polygon's area and <code>Ac</code> the area of the smallest circumscribing circle.</p>
<p>Theoretically, <a href="./gis_analysis_patch_shape_tools.html#relatedcircumscribingcircle"><strong>RelatedCircumscribingCircle</strong></a> ranges from 0 to 1, where a value of 0 indicates
a circular polygon and a value of 1 indicates a highly elongated shape. The circumscribing
circle provides a measure of polygon elongation. Unlike the <a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a>, however, it
does not provide a measure of polygon direction in addition to overall elongation. Like the
<a href="./gis_analysis_patch_shape_tools.html#elongationratio"><strong>ElongationRatio</strong></a> and <a href="./gis_analysis_patch_shape_tools.html#linearityindex"><strong>LinearityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#relatedcircumscribingcircle"><strong>RelatedCircumscribingCircle</strong></a> is not an adequate
measure of overall polygon narrowness, because a highly sinuous but narrow patch will have
a low related circumscribing circle index owing to the compact nature of these polygon.</p>
<p>Note: Holes are excluded from the area calculation of polygons.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.related_circumscribing_circle(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RelatedCircumscribingCircle -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/related_circumscribing_circle.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2018</p>
<p><a name="ShapeComplexityIndex"></a></p>
<a class="header" href="#shapecomplexityindex" id="shapecomplexityindex"><h1>ShapeComplexityIndex</h1></a>
<p>This tool provides a measure of overall polygon shape complexity, or irregularity,
for vector polygons. Several shape indices have been created to compare a polygon's
shape to simple Euclidean shapes (e.g. circles, squares, etc.). One of the problems
with this approach is that it inherently convolves the characteristics of polygon
complexity and elongation. The Shape Complexity Index (SCI) was developed as a
parameter for assessing the complexity of a polygon that is independent of its
elongation.</p>
<p>SCI relates a polygon's shape to that of an encompassing convex hull. It is
defined as:</p>
<blockquote>
<p>SCI = 1 - A / Ah</p>
</blockquote>
<p>Where <code>A</code> is the polygon's area and <code>Ah</code> is the area of the convex hull containing
the polygon. Convex polygons, i.e. those that do not contain concavities or holes,
have a value of 0. As the shape of the polygon becomes more complex, the SCI
approaches 1. Note that polygon shape complexity also increases with the greater
number of holes (i.e. islands), since holes have the effect of reducing the lake
area.</p>
<p>The SCI values calculated for each vector polygon feature will be placed in the
accompanying database file (.dbf) as a complexity field (COMPLEXITY).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindexraster"><strong>ShapeComplexityIndexRaster</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector polygon file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.shape_complexity_index(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ShapeComplexityIndex -v ^
--wd=&quot;/path/to/data/&quot; --input=polygons.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/shape_complexity_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/09/2018</p>
<p><a name="ShapeComplexityIndexRaster"></a></p>
<a class="header" href="#shapecomplexityindexraster" id="shapecomplexityindexraster"><h1>ShapeComplexityIndexRaster</h1></a>
<p>This tools calculates a type of shape complexity index for raster objects. The index is equal to the average
number of intersections of the group of vertical and horizontal transects passing through an object. Simple
objects will have a shape complexity index of 1.0 and more complex shapes, including those containing numberous
holes or are winding in shape, will have higher index values. Objects in the input raster (<code>--input</code>) are
designated by their unique identifers. Identifer values should be positive, non-zero whole numbers.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis_patch_shape_tools.html#shapecomplexityindex"><strong>ShapeComplexityIndex</strong></a>, <a href="./gis_analysis_patch_shape_tools.html#boundaryshapecomplexity"><strong>BoundaryShapeComplexity</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.shape_complexity_index_raster(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ShapeComplexityIndexRaster -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --zero_back 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/gis_analysis/shape_complexity_raster.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/02/2019</p>
<a class="header" href="#hydrological-analysis" id="hydrological-analysis"><h1>Hydrological Analysis</h1></a>
<ul>
<li><a href="#AverageFlowpathSlope">AverageFlowpathSlope</a></li>
<li><a href="#AverageUpslopeFlowpathLength">AverageUpslopeFlowpathLength</a></li>
<li><a href="#Basins">Basins</a></li>
<li><a href="#BreachDepressions">BreachDepressions</a></li>
<li><a href="#BreachSingleCellPits">BreachSingleCellPits</a></li>
<li><a href="#D8FlowAccumulation">D8FlowAccumulation</a></li>
<li><a href="#D8MassFlux">D8MassFlux</a></li>
<li><a href="#D8Pointer">D8Pointer</a></li>
<li><a href="#DInfFlowAccumulation">DInfFlowAccumulation</a></li>
<li><a href="#DInfMassFlux">DInfMassFlux</a></li>
<li><a href="#DInfPointer">DInfPointer</a></li>
<li><a href="#DepthInSink">DepthInSink</a></li>
<li><a href="#DownslopeDistanceToStream">DownslopeDistanceToStream</a></li>
<li><a href="#DownslopeFlowpathLength">DownslopeFlowpathLength</a></li>
<li><a href="#ElevationAboveStream">ElevationAboveStream</a></li>
<li><a href="#ElevationAboveStreamEuclidean">ElevationAboveStreamEuclidean</a></li>
<li><a href="#Fd8FlowAccumulation">Fd8FlowAccumulation</a></li>
<li><a href="#Fd8Pointer">Fd8Pointer</a></li>
<li><a href="#FillBurn">FillBurn</a></li>
<li><a href="#FillDepressions">FillDepressions</a></li>
<li><a href="#FillSingleCellPits">FillSingleCellPits</a></li>
<li><a href="#FindNoFlowCells">FindNoFlowCells</a></li>
<li><a href="#FindParallelFlow">FindParallelFlow</a></li>
<li><a href="#FlattenLakes">FlattenLakes</a></li>
<li><a href="#FloodOrder">FloodOrder</a></li>
<li><a href="#FlowAccumulationFullWorkflow">FlowAccumulationFullWorkflow</a></li>
<li><a href="#FlowLengthDiff">FlowLengthDiff</a></li>
<li><a href="#Hillslopes">Hillslopes</a></li>
<li><a href="#ImpoundmentSizeIndex">ImpoundmentSizeIndex</a></li>
<li><a href="#Isobasins">Isobasins</a></li>
<li><a href="#JensonSnapPourPoints">JensonSnapPourPoints</a></li>
<li><a href="#LongestFlowpath">LongestFlowpath</a></li>
<li><a href="#MaxUpslopeFlowpathLength">MaxUpslopeFlowpathLength</a></li>
<li><a href="#NumInflowingNeighbours">NumInflowingNeighbours</a></li>
<li><a href="#RaiseWalls">RaiseWalls</a></li>
<li><a href="#Rho8Pointer">Rho8Pointer</a></li>
<li><a href="#Sink">Sink</a></li>
<li><a href="#SnapPourPoints">SnapPourPoints</a></li>
<li><a href="#StochasticDepressionAnalysis">StochasticDepressionAnalysis</a></li>
<li><a href="#StrahlerOrderBasins">StrahlerOrderBasins</a></li>
<li><a href="#Subbasins">Subbasins</a></li>
<li><a href="#TraceDownslopeFlowpaths">TraceDownslopeFlowpaths</a></li>
<li><a href="#UnnestBasins">UnnestBasins</a></li>
<li><a href="#Watershed">Watershed</a></li>
</ul>
<p><a name="AverageFlowpathSlope"></a></p>
<a class="header" href="#averageflowpathslope" id="averageflowpathslope"><h1>AverageFlowpathSlope</h1></a>
<p>This tool calculates the average slope gradient (i.e. slope steepness in degrees) of the flowpaths that
pass through each grid cell in an input digital elevation model (DEM). The user must specify the name of
a DEM raster (<code>--dem</code>). It is important that this DEM is pre-processed to remove all topographic depressions and
flat areas using a tool such as <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>. Several intermediate rasters are created and stored in
memory during the operation of this tool, which may limit the size of DEM that can be processed, depending
on available system resources.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#averageupslopeflowpathlength"><strong>AverageUpslopeFlowpathLength</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_flowpath_slope(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageFlowpathSlope -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/average_flowpath_slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/07/2017</p>
<p><a name="AverageUpslopeFlowpathLength"></a></p>
<a class="header" href="#averageupslopeflowpathlength" id="averageupslopeflowpathlength"><h1>AverageUpslopeFlowpathLength</h1></a>
<p>This tool calculates the average length of the flowpaths that run through each grid cell (in map horizontal units)
in in an input digital elevation model (DEM). The user must specify the name of
a DEM raster (<code>--dem</code>). It is important that this DEM is pre-processed to remove all topographic depressions and
flat areas using a tool such as <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>. Several intermediate rasters are created and stored in
memory during the operation of this tool, which may limit the size of DEM that can be processed, depending
on available system resources.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#averageflowpathslope"><strong>AverageFlowpathSlope</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.average_upslope_flowpath_length(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AverageUpslopeFlowpathLength -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/average_upslope_flowpath_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/07/2017</p>
<p><a name="Basins"></a></p>
<a class="header" href="#basins" id="basins"><h1>Basins</h1></a>
<p>This tool can be used to delineate all of the drainage basins contained within a local drainage direction,
or flow pointer raster (<code>--d8_pntr</code>), and draining to the edge of the data. The flow pointer raster must be derived using
the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> tool and should have been extracted from a digital elevation model (DEM) that has been
hydrologically pre-processed to remove topographic depressions and flat areas, e.g. using the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>
tool. By default, the flow pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools:</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 64 </td><td align="center"> 128 </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 32 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> 16 </td><td align="center">  8  </td><td align="center"> 4  </td></tr>
</tbody></table>
<p>If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>The <a href="./hydrological_analysis.html#basins"><strong>Basins</strong></a> and <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tools are similar in function but while the <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tool identifies the upslope areas
that drain to one or more user-specified outlet points, the <a href="./hydrological_analysis.html#basins"><strong>Basins</strong></a> tool automatically sets outlets to all grid cells
situated along the edge of the data that do not have a defined flow direction (i.e. they do not have a lower neighbour).
Notice that these edge outlets need not be situated along the edges of the flow-pointer raster, but rather along the
edges of the region of valid data. That is, the DEM from which the flow-pointer has been extracted may incompletely
fill the containing raster, if it is irregular shaped, and NoData regions may occupy the peripherals. Thus, the entire
region of valid data in the flow pointer raster will be divided into a set of mutually exclusive basins using this tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.basins(
    d8_pntr, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Basins -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr='d8pntr.tif' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/basins.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="BreachDepressions"></a></p>
<a class="header" href="#breachdepressions" id="breachdepressions"><h1>BreachDepressions</h1></a>
<p>This tool can be used to remove the depressions in a digital elevation model (DEM), a
common requirement of spatial hydrological operations such as flow accumulation
and watershed modelling. The tool based on on the efficient hybrid depression
breaching algorithm described by Lindsay (2016). It uses a breach-first, fill-second
approach to resolving continous flowpaths through depressions.</p>
<p>Notice that when the input DEM (<code>--dem</code>) contains deep, single-cell pits, it can be useful
to raise the pits elevation to that of the lowest neighbour (<code>--fill_pits</code>), to avoid the
creation of deep breach trenches. Deep pits can be common in DEMs containing speckle-type noise.
This option, however, does add slightly to the computation time of the tool.</p>
<p>The user may optionally (<code>--flat_increment</code>) override the default value applied to increment elevations on
flat areas (often formed by the subsequent depression filling operation). The default value is
dependent upon the elevation range in the input DEM and is generally a very small elevation value (e.g.
0.001). It may be necessary to override the default elevation increment value in landscapes where there
are extensive flat areas resulting from depression filling (and along breach channels). Values in the range
0.00001 to 0.01 are generally appropriate. increment values that are too large can result in obvious artifacts
along flattened sites, which may extend beyond the flats, and values that are too small (i.e. smaller than the
numerical precision) may result in the presence of grid cells with no downslope neighbour in the
output DEM. The output DEM will always use 64-bit floating point values for storing elevations because of
the need to precisely represent small elevation differences along flats. Therefore, if the input DEM is stored
at a lower level of precision (e.g. 32-bit floating point elevations), this may result in a doubling of
the size of the DEM.</p>
<p><em>Reference</em>:</p>
<p>Lindsay JB. 2016. <em>Efficient hybrid breaching-filling sink removal methods for
flow path enforcement in digital elevation models.</em> <strong>Hydrological Processes</strong>,
30(6): 846–857. DOI: 10.1002/hyp.10648</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, <a href="./hydrological_analysis.html#fillsinglecellpits"><strong>FillSingleCellPits</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--max_depth        </td><td> Optional maximum breach depth (default is Inf)</td></tr>
<tr><td>--max_length       </td><td> Optional maximum breach channel length (in grid cells; default is Inf)</td></tr>
<tr><td>--flat_increment   </td><td> Optional elevation increment applied to flat areas</td></tr>
<tr><td>--fill_pits        </td><td> Optional flag indicating whether to fill single-cell pits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.breach_depressions(
    dem, 
    output, 
    max_depth=None, 
    max_length=None, 
    flat_increment=None, 
    fill_pits=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BreachDepressions -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/breach_depressions.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="BreachSingleCellPits"></a></p>
<a class="header" href="#breachsinglecellpits" id="breachsinglecellpits"><h1>BreachSingleCellPits</h1></a>
<p>This tool can be used to remove pits from a digital elevation model (DEM). Pits are single grid cells
with no downslope neighbours. They are important because they impede overland flow-paths. This tool will
remove any pit in the input DEM (<code>--dem</code>) that can be resolved by lowering one of the eight neighbouring
cells such that a flow-path can be created linking the pit to a second-order neighbour, i.e. a neighbouring
cell of a neighbouring cell. Notice that this tool can be a useful pre-processing technique before running
one of the more robust depression filling or breaching techniques (e.g. <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> and
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>), which are designed to remove larger depression features.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#fillsinglecellpits"><strong>FillSingleCellPits</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.breach_single_cell_pits(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BreachSingleCellPits -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/breach_pits.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="D8FlowAccumulation"></a></p>
<a class="header" href="#d8flowaccumulation" id="d8flowaccumulation"><h1>D8FlowAccumulation</h1></a>
<p>This tool is used to generate a flow accumulation grid (i.e. catchment area) using the
D8 (O'Callaghan and Mark, 1984) algorithm. This algorithm is an example of single-flow-direction
(SFD) method because the flow entering each grid cell is routed to only one downslope neighbour,
i.e. flow divergence is not permitted. The user must specify the name of the input digital
elevation model (DEM). The DEM must have been hydrologically corrected to remove all spurious
depressions and flat areas. DEM pre-processing is usually achieved using the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or
<a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tools.</p>
<p>In addition to the input DEM, the user must specify the output type. The output flow-accumulation
can be 1) <code>cells</code> (i.e. the number of inflowing grid cells), <code>catchment area</code> (i.e. the upslope area),
or <code>specific contributing area</code> (i.e. the catchment area divided by the flow width. The default value
is <code>cells</code>. The user must also specify whether the output flow-accumulation grid should be
log-tranformed (<code>--log</code>), i.e. the output, if this option is selected, will be the natural-logarithm of the
accumulated flow value. This is a transformation that is often performed to better visualize the
contributing area distribution. Because contributing areas tend to be very high along valley bottoms
and relatively low on hillslopes, when a flow-accumulation image is displayed, the distribution of
values on hillslopes tends to be 'washed out' because the palette is stretched out to represent the
highest values. Log-transformation provides a means of compensating for this phenomenon. Importantly,
however, log-transformed flow-accumulation grids must not be used to estimate other secondary terrain
indices, such as the wetness index, or relative stream power index.</p>
<p>Grid cells possessing the <strong>NoData</strong> value in the input flow-pointer grid are assigned the <strong>NoData</strong>
value in the output flow-accumulation image.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'cells' (default), 'catchment area', and 'specific contributing area'</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
<tr><td>--clip             </td><td> Optional flag to request clipping the display max by 1%</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d8_flow_accumulation(
    dem, 
    output, 
    out_type=&quot;cells&quot;, 
    log=False, 
    clip=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=D8FlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type='cells'
&gt;&gt;./whitebox_tools -r=D8FlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type='specific catchment area' --log --clip 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/d8_flow_accum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="D8MassFlux"></a></p>
<a class="header" href="#d8massflux" id="d8massflux"><h1>D8MassFlux</h1></a>
<p>Performs a D8 mass flux calculation.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>--loading          </td><td> Input loading raster file</td></tr>
<tr><td>--efficiency       </td><td> Input efficiency raster file</td></tr>
<tr><td>--absorption       </td><td> Input absorption raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d8_mass_flux(
    dem, 
    loading, 
    efficiency, 
    absorption, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=D8MassFlux -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif --loading=load.tif --efficiency=eff.tif ^
--absorption=abs.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/d8_mass_flux.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: Dec. 29, 2017</p>
<p><a name="D8Pointer"></a></p>
<a class="header" href="#d8pointer" id="d8pointer"><h1>D8Pointer</h1></a>
<p>This tool is used to generate a flow pointer grid using the simple D8 (O'Callaghan and Mark, 1984) algorithm. The
user must specify the name (<code>--dem</code>) of a digital elevation model (DEM) that has been hydrologically
corrected to remove all spurious depressions and flat areas. DEM pre-processing is usually achived using
either the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. The local drainage direction raster output (<code>--output</code>)
by this tool serves as a necessary input for several other spatial hydrology and stream network analysis tools
in the toolset. Some tools will calculate this flow pointer raster directly from the input DEM.</p>
<p>By default, D8 flow pointers use the following clockwise, base-2 numeric index convention:</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 64 </td><td align="center"> 128 </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 32 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> 16 </td><td align="center">  8  </td><td align="center"> 4  </td></tr>
</tbody></table>
<p>Notice that grid cells that have no lower neighbours are assigned a flow direction of zero. In a DEM that has been
pre-processed to remove all depressions and flat areas, this condition will only occur along the edges of the grid.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>Grid cells possessing the NoData value in the input DEM are assigned the NoData value in the output image.</p>
<p><em>Reference</em>:</p>
<p>O'Callaghan, J. F., &amp; Mark, D. M. (1984). The extraction of drainage networks from digital elevation data.
Computer vision, graphics, and image processing, 28(3), 323-344.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#dinfpointer"><strong>DInfPointer</strong></a>, <a href="./hydrological_analysis.html#fd8pointer"><strong>FD8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d8_pointer(
    dem, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=D8Pointer -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/d8_pointer.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/06/2017</p>
<p><a name="DInfFlowAccumulation"></a></p>
<a class="header" href="#dinfflowaccumulation" id="dinfflowaccumulation"><h1>DInfFlowAccumulation</h1></a>
<p>This tool is used to generate a flow accumulation grid (i.e. contributing area) using the D-infinity algorithm
(Tarboton, 1997). This algorithm is an examples of a multiple-flow-direction (MFD) method because the flow entering
each grid cell is routed to one or two downslope neighbour, i.e. flow divergence is permitted. The user must
specify the name of the input pointer-grid, which has been created either from the Dinf flow-pointer tool. The
flow-pointer grid should be created from a digital elevation model (DEM) that has been hydrologically corrected
to remove all spurious depressions and flat areas. DEM pre-processing is usually achieved using the
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool.</p>
<p>In addition to the input flow-pointer grid name, the user must specify the output type (<code>--out_type</code>). The output
flow-accumulation
can be 1) specific catchment area (SCA), which is the upslope contributing area divided by the contour length (taken
as the grid resolution), 2) total catchment area in square-metres, or 3) the number of upslope grid cells. The user
must also specify whether the output flow-accumulation grid should be log-tranformed, i.e. the output, if this option
is selected, will be the natural-logarithm of the accumulated area. This is a transformation that is often performed
to better visualize the contributing area distribution. Because contributing areas tend to be very high along valley
bottoms and relatively low on hillslopes, when a flow-accumulation image is displayed, the distribution of values on
hillslopes tends to be 'washed out' because the palette is stretched out to represent the highest values.
Log-transformation (<code>--log</code>) provides a means of compensating for this phenomenon. Importantly, however, log-transformed
flow-accumulation grids must not be used to estimate other secondary terrain indices, such as the wetness index, or
relative stream power index.</p>
<p>Grid cells possessing the NoData value in the input flow-pointer grid are assigned the NoData value in the output
flow-accumulation image. The output raster is of the float data type and continuous data scale.</p>
<p><em>Reference</em>:</p>
<p>Tarboton, D. G. (1997). A new method for the determination of flow directions and upslope areas in grid digital
elevation models. Water resources research, 33(2), 309-319.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'cells', 'sca' (default), and 'ca'</td></tr>
<tr><td>--threshold        </td><td> Optional convergence threshold parameter, in grid cells; default is inifinity</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
<tr><td>--clip             </td><td> Optional flag to request clipping the display max by 1%</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d_inf_flow_accumulation(
    dem, 
    output, 
    out_type=&quot;Specific Contributing Area&quot;, 
    threshold=None, 
    log=False, 
    clip=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DInfFlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type=sca
&gt;&gt;./whitebox_tools -r=DInfFlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type=sca --threshold=10000 --log --clip 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/dinf_flow_accum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/06/2017</p>
<p><a name="DInfMassFlux"></a></p>
<a class="header" href="#dinfmassflux" id="dinfmassflux"><h1>DInfMassFlux</h1></a>
<p>Performs a D-infinity mass flux calculation.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>--loading          </td><td> Input loading raster file</td></tr>
<tr><td>--efficiency       </td><td> Input efficiency raster file</td></tr>
<tr><td>--absorption       </td><td> Input absorption raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d_inf_mass_flux(
    dem, 
    loading, 
    efficiency, 
    absorption, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DInfMassFlux -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif --loading=load.tif --efficiency=eff.tif ^
--absorption=abs.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/dinf_mass_flux.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: Dec. 29, 2017</p>
<p><a name="DInfPointer"></a></p>
<a class="header" href="#dinfpointer" id="dinfpointer"><h1>DInfPointer</h1></a>
<p>Calculates a D-infinity flow pointer (flow direction) raster from an input DEM.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.d_inf_pointer(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DInfPointer -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/dinf_pointer.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="DepthInSink"></a></p>
<a class="header" href="#depthinsink" id="depthinsink"><h1>DepthInSink</h1></a>
<p>This tool measures the depth that each grid cell in an input (<code>--dem</code>) raster digital elevation model (DEM)
lies within a sink feature, i.e. a closed topographic depression. A sink, or depression, is a bowl-like
landscape feature, which is characterized by interior drainage and groundwater recharge. The <a href="./hydrological_analysis.html#depthinsink"><strong>DepthInSink</strong></a> tool
operates by differencing a filled DEM, using the same depression filling method as <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, and the
original surface model.</p>
<p>In addition to the names of the input DEM (<code>--dem</code>) and the output raster (<code>--output</code>), the user must specify
whether the background value (i.e. the value assigned to grid cells that are not contained within sinks) should be
set to 0.0 (<code>--zero_background</code>) Without this optional parameter specified, the tool will use the NoData value
as the background value.</p>
<p><em>Reference</em>:</p>
<p>Antonić, O., Hatic, D., &amp; Pernar, R. (2001). DEM-based depth in sink as an environmental estimator. Ecological
Modelling, 138(1-3), 247-254.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether the background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.depth_in_sink(
    dem, 
    output, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DepthInSink -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/depth_in_sink.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="DownslopeDistanceToStream"></a></p>
<a class="header" href="#downslopedistancetostream" id="downslopedistancetostream"><h1>DownslopeDistanceToStream</h1></a>
<p>This tool can be used to calculate the distance from each grid cell in a raster to the nearest stream cell,
measured along the downslope flowpath. The user must specify the name of an input digital elevation model (<code>--dem</code>)
and streams raster (<code>--streams</code>). The DEM must have been pre-processed to remove artifact topographic depressions
and flat areas (see <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>). The streams raster should have been created using one of the DEM-based
stream mapping methods, i.e. contributing area thresholding. Stream cells are designated in this raster as all
non-zero values. The output of this tool, along with the <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a> tool, can be useful for preliminary
flood plain mapping when combined with high-accuracy DEM data.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./stream_network_analysis.html#distancetooutlet"><strong>DistanceToOutlet</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.downslope_distance_to_stream(
    dem, 
    streams, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DownslopeDistanceToStream -v ^
--wd=&quot;/path/to/data/&quot; --dem='dem.tif' --streams='streams.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/downslope_distance_to_stream.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 9/07/2017</p>
<p><a name="DownslopeFlowpathLength"></a></p>
<a class="header" href="#downslopeflowpathlength" id="downslopeflowpathlength"><h1>DownslopeFlowpathLength</h1></a>
<p>Calculates the downslope flowpath length from each cell to basin outlet.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>--watersheds       </td><td> Optional input watershed raster file</td></tr>
<tr><td>--weights          </td><td> Optional input weights raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.downslope_flowpath_length(
    d8_pntr, 
    output, 
    watersheds=None, 
    weights=None, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DownslopeFlowpathLength -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=pointer.tif ^
-o=flowpath_len.tif
&gt;&gt;./whitebox_tools ^
-r=DownslopeFlowpathLength -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr=pointer.tif --watersheds=basin.tif ^
--weights=weights.tif -o=flowpath_len.tif --esri_pntr 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/downslope_flowpath_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 8, 2017</p>
<p><a name="ElevationAboveStream"></a></p>
<a class="header" href="#elevationabovestream" id="elevationabovestream"><h1>ElevationAboveStream</h1></a>
<p>This tool can be used to calculate the elevation of each grid cell in a raster above the nearest stream cell,
measured along the downslope flowpath. This terrain index, a measure of relative topographic position, is
essentially equivalent to the 'height above drainage' (HAND), as described by Renno et al. (2008). The user must
specify the name of an input digital elevation model (<code>--dem</code>) and streams raster (<code>--streams</code>). The DEM
must have been pre-processed to remove artifact topographic depressions and flat areas (see <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>).
The streams raster should have been created using one of the DEM-based stream mapping methods, i.e. contributing
area thresholding. Stream cells are designated in this raster as all non-zero values. The output of this tool,
along with the <a href="./hydrological_analysis.html#downslopedistancetostream"><strong>DownslopeDistanceToStream</strong></a> tool, can be useful for preliminary flood plain mapping when combined
with high-accuracy DEM data.</p>
<p>The difference between <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a> and <a href="./hydrological_analysis.html#elevationabovestreameuclidean"><strong>ElevationAboveStreamEuclidean</strong></a> is that the former calculates
distances along drainage flow-paths while the latter calculates straight-line distances to streams channels.</p>
<p><em>Reference</em>:</p>
<p>Renno, C. D., Nobre, A. D., Cuartas, L. A., Soares, J. V., Hodnett, M. G., Tomasella, J., &amp; Waterloo, M. J.
(2008). HAND, a new terrain descriptor using SRTM-DEM: Mapping terra-firme rainforest environments in Amazonia.
Remote Sensing of Environment, 112(9), 3469-3481.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#elevationabovestreameuclidean"><strong>ElevationAboveStreamEuclidean</strong></a>, <a href="./hydrological_analysis.html#downslopedistancetostream"><strong>DownslopeDistanceToStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elevation_above_stream(
    dem, 
    streams, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevationAboveStream -v ^
--wd=&quot;/path/to/data/&quot; --dem='dem.tif' --streams='streams.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/elevation_above_stream.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 9, 2017</p>
<p><a name="ElevationAboveStreamEuclidean"></a></p>
<a class="header" href="#elevationabovestreameuclidean" id="elevationabovestreameuclidean"><h1>ElevationAboveStreamEuclidean</h1></a>
<p>This tool can be used to calculate the elevation of each grid cell in a raster above the nearest stream cell,
measured along the straight-line distance. This terrain index, a measure of relative topographic position, is
related to the 'height above drainage' (HAND), as described by Renno et al. (2008). HAND is generally estimated
with distances measured along drainage flow-paths, which can be calculated using the <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a> tool.
The user must specify the name of an input digital elevation model (<code>--dem</code>) and streams raster (<code>--streams</code>).
Stream cells are designated in this raster as all non-zero values. The output of this tool,
along with the <a href="./hydrological_analysis.html#downslopedistancetostream"><strong>DownslopeDistanceToStream</strong></a> tool, can be useful for preliminary flood plain mapping when combined
with high-accuracy DEM data.</p>
<p>The difference between <a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a> and <a href="./hydrological_analysis.html#elevationabovestreameuclidean"><strong>ElevationAboveStreamEuclidean</strong></a> is that the former calculates
distances along drainage flow-paths while the latter calculates straight-line distances to streams channels.</p>
<p><em>Reference</em>:</p>
<p>Renno, C. D., Nobre, A. D., Cuartas, L. A., Soares, J. V., Hodnett, M. G., Tomasella, J., &amp; Waterloo, M. J.
(2008). HAND, a new terrain descriptor using SRTM-DEM: Mapping terra-firme rainforest environments in Amazonia.
Remote Sensing of Environment, 112(9), 3469-3481.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#elevationabovestream"><strong>ElevationAboveStream</strong></a>, <a href="./hydrological_analysis.html#downslopedistancetostream"><strong>DownslopeDistanceToStream</strong></a>, <a href="./geomorphometric_analysis.html#elevabovepit"><strong>ElevAbovePit</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.elevation_above_stream_euclidean(
    dem, 
    streams, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ElevationAboveStreamEuclidean -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif --streams=streams.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/elevation_above_stream_euclidean.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/03/2018</p>
<p><a name="Fd8FlowAccumulation"></a></p>
<a class="header" href="#fd8flowaccumulation" id="fd8flowaccumulation"><h1>Fd8FlowAccumulation</h1></a>
<p>This tool is used to generate a flow accumulation grid (i.e. contributing area) using the FD8 algorithm (Freeman,
1991). This algorithm is an examples of a multiple-flow-direction (MFD) method because the flow entering each
grid cell is routed to each downslope neighbour, i.e. flow divergence is permitted. The user must specify the
name (<code>--dem</code>) of the input digital elevation model (DEM). The DEM must have been hydrologically
corrected to remove all spurious depressions and flat areas. DEM pre-processing is usually achived using
either the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. A value must also be specified for the exponent parameter
(<code>--exponent</code>), a number that controls the degree of dispersion in the resulting flow-accumulation grid. A lower
value yields greater apparent flow dispersion across divergent hillslopes. Some experimentation suggests that a
value of 1.1 is appropriate (Freeman, 1991), although this is almost certainly landscape-dependent.</p>
<p>In addition to the input DEM, the user must specify the output type. The output flow-accumulation
can be 1) <code>cells</code> (i.e. the number of inflowing grid cells), <code>catchment area</code> (i.e. the upslope area),
or <code>specific contributing area</code> (i.e. the catchment area divided by the flow width. The default value
is <code>cells</code>. The user must also specify whether the output flow-accumulation grid should be
log-tranformed (<code>--log</code>), i.e. the output, if this option is selected, will be the natural-logarithm of the
accumulated flow value. This is a transformation that is often performed to better visualize the
contributing area distribution. Because contributing areas tend to be very high along valley bottoms
and relatively low on hillslopes, when a flow-accumulation image is displayed, the distribution of
values on hillslopes tends to be 'washed out' because the palette is stretched out to represent the
highest values. Log-transformation provides a means of compensating for this phenomenon. Importantly,
however, log-transformed flow-accumulation grids must not be used to estimate other secondary terrain
indices, such as the wetness index, or relative stream power index.</p>
<p>The non-dispersive threshold (<code>--threshold</code>) is a flow-accumulation value (measured in upslope grid cells,
which is directly proportional to area) above which flow dispersion is not longer permited. Grid cells with
flow-accumulation values above this threshold will have their flow routed in a manner that is similar to
the D8 single-flow-direction algorithm, directing all flow towards the steepest downslope neighbour. This
is usually done under the assumption that flow dispersion, whilst appropriate on hillslope areas, is not
realistic once flow becomes channelized.</p>
<p>Grid cells possessing the NoData value in the input flow-pointer grid are assigned the NoData value in the
output flow-accumulation image.</p>
<p><em>Reference</em>:</p>
<p>Freeman, T. G. (1991). Calculating catchment area with divergent flow based on a regular grid. Computers and
Geosciences, 17(3), 413-422.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#dinfflowaccumulation"><strong>DInfFlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'cells', 'specific contributing area' (default), and 'catchment area'</td></tr>
<tr><td>--exponent         </td><td> Optional exponent parameter; default is 1.1</td></tr>
<tr><td>--threshold        </td><td> Optional convergence threshold parameter, in grid cells; default is inifinity</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
<tr><td>--clip             </td><td> Optional flag to request clipping the display max by 1%</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fd8_flow_accumulation(
    dem, 
    output, 
    out_type=&quot;specific contributing area&quot;, 
    exponent=1.1, 
    threshold=None, 
    log=False, 
    clip=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FD8FlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type='cells'
&gt;&gt;./whitebox_tools -r=FD8FlowAccumulation -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--out_type='catchment area' --exponent=1.5 --threshold=10000 ^
--log --clip 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/fd8_flow_accum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="Fd8Pointer"></a></p>
<a class="header" href="#fd8pointer" id="fd8pointer"><h1>Fd8Pointer</h1></a>
<p>This tool is used to generate a flow pointer grid (i.e. flow direction) using the FD8 (Freeman, 1991) algorithm.
FD8 is a multiple-flow-direction (MFD) method because the flow entering each grid cell is routed one or more
downslope neighbours, i.e. flow divergence is permitted. The user must specify the name of a digital elevation model
(DEM; <code>--dem</code>) that has been hydrologically corrected to remove all spurious depressions and flat areas.
DEM pre-processing is usually achived using the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tools.</p>
<p>By default, D8 flow pointers use the following clockwise, base-2 numeric index convention:</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 64 </td><td align="center"> 128 </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 32 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> 16 </td><td align="center">  8  </td><td align="center"> 4  </td></tr>
</tbody></table>
<p>In the case of the FD8 algorithm, some portion of the flow entering a grid cell will be sent to each downslope
neighbour. Thus, the FD8 flow-pointer value is the sum of each of the individual pointers for all downslope neighbours.
For example, if a grid cell has downslope neighbours to the northeast, east, and south the corresponding FD8
flow-pointer value will be 1 + 2 + 8 = 11. Using the naming convention above, this is the only combination of
flow-pointers that will result in the combined value of 11. Using the base-2 naming convention allows for the
storage of complex combinations of flow-points using a single numeric value, which is the reason for using this
somewhat odd convention.</p>
<p><em>Reference</em>:</p>
<p>Freeman, T. G. (1991). Calculating catchment area with divergent flow based on a regular grid. Computers and
Geosciences, 17(3), 413-422.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#fd8flowaccumulation"><strong>FD8FlowAccumulation</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#dinfpointer"><strong>DInfPointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fd8_pointer(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FD8Pointer -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/fd8_pointer.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="FillBurn"></a></p>
<a class="header" href="#fillburn" id="fillburn"><h1>FillBurn</h1></a>
<p>Burns streams into a DEM using the FillBurn (Saunders, 1999) method. This tool uses the
algorithm described in:</p>
<p>Lindsay JB. 2016. The practice of DEM stream burning revisited. Earth Surface Processes
and Landforms, 41(5): 658-668. DOI: 10.1002/esp.3888</p>
<p>And:</p>
<p>Saunders, W. 1999. Preparation of DEMs for use in environmental modeling analysis, in: ESRI User
Conference. pp. 24-30.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>--streams          </td><td> Input vector streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_burn(
    dem, 
    streams, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillBurn -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif --streams=streams.shp -o=dem_burned.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/fill_burn.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/04/2018</p>
<p><a name="FillDepressions"></a></p>
<a class="header" href="#filldepressions" id="filldepressions"><h1>FillDepressions</h1></a>
<p>This tool can be used to fill all of the depressions in a digital elevation model (DEM) and to remove the f
lat areas. This is a common pre-processing step required by many flow-path analysis tools to ensure continuous
flow from each grid cell to an outlet located along the grid edge. The <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> algorithm is based on
the computationally efficient approach of examining each cell based on its spill elevation, starting from the
edge cells, and visiting cells from lowest order using a priority queue. As such, it is based on the algorithm
first proposed by Wang and Liu (2006). It is currently the most efficient depression-removal algorithm available
in WhiteboxTools, although it is not significantly more efficient than the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> tool, which is
known to provide a solution to depression removal with less impact of the DEM.</p>
<p>If the input DEM has gaps, or missing-data holes, that contain NoData values, it is better to use the
<a href="./geomorphometric_analysis.html#fillmissingdata"><strong>FillMissingData</strong></a> tool to repair these gaps. This tool will interpolate values across the gaps and produce
a more natural-looking surface than the flat areas that are produced by depression filling. Importantly, the
<a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool algorithm implementation assumes that there are no 'donut hole' NoData gaps within the area
of valid data. Any NoData areas along the edge of the grid will simply be ignored and will remain NoData areas in
the output image.</p>
<p><em>Reference</em>:</p>
<p>Wang, L. and Lui, H. 2006. An efficient method for identifying and filling surface depressions in digital elevation
models for hydrologic analysis and modelling. International Journal of Geographical Information Science, 20(2): 193-213.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./geomorphometric_analysis.html#fillmissingdata"><strong>FillMissingData</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--fix_flats        </td><td> Optional flag indicating whether flat areas should have a small gradient applied</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_depressions(
    dem, 
    output, 
    fix_flats=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillDepressions -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=output.tif ^
--fix_flats 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/fill_depressions.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="FillSingleCellPits"></a></p>
<a class="header" href="#fillsinglecellpits" id="fillsinglecellpits"><h1>FillSingleCellPits</h1></a>
<p>This tool can be used to remove pits from a digital elevation model (DEM). Pits are single grid cells with no
downslope neighbours. They are important because they impede overland flow-paths. This tool will remove any
pits in the input DEM that can be resolved by raising the elevation of the pit such that flow will continue
past the pit cell to one of the downslope neighbours. Notice that this tool can be a useful pre-processing
technique before running one of the more robust depression breaching (<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>) or filling
(<a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>) techniques, which are designed to remove larger depression features.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, <a href="./hydrological_analysis.html#breachsinglecellpits"><strong>BreachSingleCellPits</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fill_single_cell_pits(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FillSingleCellPits -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=NewRaster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/fill_pits.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="FindNoFlowCells"></a></p>
<a class="header" href="#findnoflowcells" id="findnoflowcells"><h1>FindNoFlowCells</h1></a>
<p>This tool can be used to find cells with undefined flow, i.e. no valid flow direction, based on the
D8 flow direction algorithm (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>). These cells are therefore either at the bottom of a topographic
depression or in the interior of a flat area. In a digital elevation model (DEM) that has been
pre-processed to remove all depressions and flat areas (<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>), this condition will only occur
along the edges of the grid, otherwise no-flow grid cells can be situation in the interior. The user must
specify the name (<code>--dem</code>) of the DEM.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_no_flow_cells(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindNoFlowCells -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=NewRaster.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/find_noflow_cells.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="FindParallelFlow"></a></p>
<a class="header" href="#findparallelflow" id="findparallelflow"><h1>FindParallelFlow</h1></a>
<p>This tool can be used to find cells in a stream network grid that possess parallel flow directions based
on an input D8 flow-pointer grid (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>). Because streams rarely flow in parallel for significant
distances, these areas are likely errors resulting from the biased assignment of flow direction based on
the D8 method.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_parallel_flow(
    d8_pntr, 
    streams, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindParallelFlow -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=pointer.tif ^
-o=out.tif
&gt;&gt;./whitebox_tools -r=FindParallelFlow -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=pointer.tif -o=out.tif ^
--streams='streams.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/find_parallel_flow.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="FlattenLakes"></a></p>
<a class="header" href="#flattenlakes" id="flattenlakes"><h1>FlattenLakes</h1></a>
<p>This tool can be used to set the elevations contained in a set of input vector lake polygons (<code>--lakes</code>) to
a consistent value within an input (<code>--dem</code>) digital elevation model (DEM). Lake flattening is
a common pre-processing step for DEMs intended for use in hydrological applications. This algorithm
determines lake elevation automatically based on the minimum perimeter elevation for each lake
polygon. The minimum perimeter elevation is assumed to be the lake outlet elevation and is assigned
to the entire interior region of lake polygons, excluding island geometries. Note, this tool will not
provide satisfactory results if the input vector polygons contain wide river features rather than true
lakes.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--lakes            </td><td> Input lakes vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flatten_lakes(
    dem, 
    lakes, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FlattenLakes -v --wd=&quot;/path/to/data/&quot; ^
--dem='DEM.tif' --lakes='lakes.shp' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/flatten_lakes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/03/2018</p>
<p><a name="FloodOrder"></a></p>
<a class="header" href="#floodorder" id="floodorder"><h1>FloodOrder</h1></a>
<p>This tool takes an input digital elevation model (DEM) and creates an output raster where every grid cell
contains the flood order of that cell within the DEM. The flood order is the sequence of grid cells that
are encountered during a search, starting from the raster grid edges and the lowest grid cell, moving inward
at increasing elevations. This is in fact similar to how the highly efficient Wang and Liu (2006) depression
filling algorithm and the Breach Depressions (Fast) operates. The output flood order raster contains the
sequential order, from lowest edge cell to the highest pixel in the DEM.</p>
<p>Like the <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool, <a href="./hydrological_analysis.html#floodorder"><strong>FloodOrder</strong></a> will read the entire DEM into memory. This may make the
algorithm ill suited to processing massive DEMs except where the user's computer has substantial memory
(RAM) resources.</p>
<p><em>Reference</em>:</p>
<p>Wang, L., and Liu, H. (2006). An efficient method for identifying and filling surface depressions in digital
elevation models for hydrologic analysis and modelling. International Journal of Geographical Information Science,
20(2), 193-213.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flood_order(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FloodOrder -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/flood_order.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="FlowAccumulationFullWorkflow"></a></p>
<a class="header" href="#flowaccumulationfullworkflow" id="flowaccumulationfullworkflow"><h1>FlowAccumulationFullWorkflow</h1></a>
<p>Resolves all of the depressions in a DEM, outputting a breached DEM, an aspect-aligned non-divergent flow pointer, and a flow accumulation raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--out_dem          </td><td> Output raster DEM file</td></tr>
<tr><td>--out_pntr         </td><td> Output raster flow pointer file</td></tr>
<tr><td>--out_accum        </td><td> Output raster flow accumulation file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'cells', 'sca' (default), and 'ca'</td></tr>
<tr><td>--log              </td><td> Optional flag to request the output be log-transformed</td></tr>
<tr><td>--clip             </td><td> Optional flag to request clipping the display max by 1%</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flow_accumulation_full_workflow(
    dem, 
    out_dem, 
    out_pntr, 
    out_accum, 
    out_type=&quot;Specific Contributing Area&quot;, 
    log=False, 
    clip=False, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FlowAccumulationFullWorkflow -v ^
--wd=&quot;/path/to/data/&quot; --dem='DEM.tif' ^
--out_dem='DEM_filled.tif' --out_pntr='pointer.tif' ^
--out_accum='accum.tif' --out_type=sca --log --clip 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/flow_accum_full_workflow.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 28, 2017</p>
<p><a name="FlowLengthDiff"></a></p>
<a class="header" href="#flowlengthdiff" id="flowlengthdiff"><h1>FlowLengthDiff</h1></a>
<p><a href="./hydrological_analysis.html#flowlengthdiff"><strong>FlowLengthDiff</strong></a> calculates the local maximum absolute difference in downslope flowpath length,
which is useful in mapping drainage divides and ridges.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#maxbranchlength"><strong>MaxBranchLength</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flow_length_diff(
    d8_pntr, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FlowLengthDiff -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr=pointer.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/flow_length_diff.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 8, 2017</p>
<p><a name="Hillslopes"></a></p>
<a class="header" href="#hillslopes" id="hillslopes"><h1>Hillslopes</h1></a>
<p>This tool will identify the hillslopes associated with a user-specified stream network. Hillslopes
include the catchment areas draining to the left and right sides of each stream link in the network as well
as the catchment areas draining to all channel heads. <a href="./hydrological_analysis.html#hillslopes"><strong>Hillslopes</strong></a> are conceptually similar to <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a>,
except that sub-basins do not distinguish between the right-bank and left-bank catchment areas of stream links.
The <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a> tool simply assigns a unique identifier to each stream link in a stream network. Each hillslope
output by this tool is assigned a unique, positive identifier  value. All grid cells in the output raster that
coincide with a stream cell are assigned an idenifiter of zero, i.e. stream cells do not belong to any hillslope.</p>
<p>The user must specify the name of a flow pointer
(flow direction) raster (<code>--d8_pntr</code>), a streams raster (<code>--streams</code>), and the output raster (<code>--output</code>).
The flow pointer and streams rasters should be generated using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This will require
a depressionless DEM, processed using either the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>NoData values in the input flow pointer raster are assigned NoData values in the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a>, <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hillslopes(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Hillslopes -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr='d8pntr.tif' --streams='streams.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/hillslopes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/07/2017</p>
<p><a name="ImpoundmentSizeIndex"></a></p>
<a class="header" href="#impoundmentsizeindex" id="impoundmentsizeindex"><h1>ImpoundmentSizeIndex</h1></a>
<p>This tool can be used to calculate the impoundment size index (ISI) from a digital elevation model (DEM).
The ISI is a land-surface parameter related to the size of the impoundment that would result from inserting
a dam of a user-specified maximum length (<code>--damlength</code>) into each DEM grid cell. In addition to an
output dam-height raster (same name as <code>--output</code> file but with an <em>_dam_height</em> suffix appended), the tool outputs
a measure of impoundment size (<code>--out_type</code>) related to impoundment average depth, total volume, or flooded area.</p>
<p>Please note that this tool performs an extremely complex and computationally intensive flow-accumulation operation.
As such, it may take a substantial amount of processing time and may encounter issues (including memory issues) when
applied to very large DEMs. It is not necessary to pre-process the input DEM (<code>--dem</code>) to remove topographic depressions
and flat areas. The internal flow-accumulation operation will not be confounded by the presence of these features.</p>
<p><em>Reference</em>:</p>
<p>Lindsay, JB (2015) Modelling the spatial pattern of potential impoundment size from DEMs.
Online resource: <a href="https://whiteboxgeospatial.wordpress.com/2015/04/29/modelling-the-spatial-pattern-of-potential-impoundment-size-from-dems/">Whitebox Blog</a></p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#stochasticdepressionanalysis"><strong>StochasticDepressionAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--out_type         </td><td> Output type; one of 'depth' (default), 'volume', and 'area'</td></tr>
<tr><td>--damlength        </td><td> Maximum length of thr dam</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.impoundment_size_index(
    dem, 
    output, 
    damlength, 
    out_type=&quot;depth&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ImpoundmentSizeIndex -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif ^
--out_type=depth --damlength=11 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/impoundment_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/05/2018</p>
<p><a name="Isobasins"></a></p>
<a class="header" href="#isobasins" id="isobasins"><h1>Isobasins</h1></a>
<p>This tool can be used to divide a landscape into a group of nearly equal-sized watersheds, known as <em>isobasins</em>.
The user must specify the name (<code>--dem</code>) of a digital elevation model (DEM), the output raster name (<code>--output</code>),
and the isobasin target area (<code>--size</code>) specified in units of grid cells. The DEM must have been hydrologically
corrected to remove all spurious depressions and flat areas. DEM pre-processing is usually achived using either
the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. Several temporary rasters are created during the execution
and stored in memory of this tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#basins"><strong>Basins</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--size             </td><td> Target basin size, in grid cells</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.isobasins(
    dem, 
    output, 
    size, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Isobasins -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --size=1000 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/isobasins.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/12/2017</p>
<p><a name="JensonSnapPourPoints"></a></p>
<a class="header" href="#jensonsnappourpoints" id="jensonsnappourpoints"><h1>JensonSnapPourPoints</h1></a>
<p>The <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a> tool can be used to move the location of vector pour points (i.e. outlets used in a <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>
operation) (<code>--pour_pts</code>) to the location coincident with the nearest stream cell (<code>--stream</code>) value within
a specified maximum distance (<code>--snap_dist</code>). The pour points file (<code>--pour_pts</code>) must be a vector file of <em>Point</em> ShapeType.</p>
<p>If the output of the <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a> tool is to be used with the <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tool, the streams raster should
be generated by extracting the streams using the <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a> algorithm. The snap distance (<code>--snap_dist</code>), measured
in map units (e.g meters), must also be specified. This distance will serve as the search radius placed around each pour
point during the search for the nearst stream cell.</p>
<p>Lindsay et al. (2008) provide a detailed discussion of the <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a> technique, and other less sophisticated
but commonly used techniques (<a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a>) for adjusting pour point locations used in watershedding operations. In
most cases, the <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a> tool should be prefered over <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> for applications of
repositioning outlet points used in watershedding operations onto the digital stream lines contained in local drainage
direction rasters. Jenson's method relocates outlet points to the <em>nearest</em> stream cell while <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> relocated
outlets to the <em>largest</em> stream (designated by the largest flow accumulation value). In the common situation where outlet
cells are position near the confluence point of smaller tributary streams, the <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> tool may re-position
outlets on the main-trunk stream, which will result in watershed delineation of incorrect sub-basins.</p>
<p><em>Reference</em>:</p>
<p>Jenson, S. K. (1991), Applications of hydrological information automati-cally extracted from digital elevation
models, Hydrological Processes, 5, 31–44, doi:10.1002/hyp.3360050104.</p>
<p>Lindsay JB, Rothwell JJ, and Davies H. 2008. Mapping outlet points used for watershed delineation onto DEM-derived
stream networks, Water Resources Research, 44, W08442, doi:10.1029/2007WR006507.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--pour_pts         </td><td> Input vector pour points (outlet) file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap_dist        </td><td> Maximum snap distance in map units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.jenson_snap_pour_points(
    pour_pts, 
    streams, 
    output, 
    snap_dist, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=JensonSnapPourPoints -v ^
--wd=&quot;/path/to/data/&quot; --pour_pts='pour_pts.shp' ^
--streams='streams.tif' -o='output.shp' --snap_dist=15.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/jenson_snap_pour_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="LongestFlowpath"></a></p>
<a class="header" href="#longestflowpath" id="longestflowpath"><h1>LongestFlowpath</h1></a>
<p>This tool delineates the longest flowpaths for a group of subbasins or watersheds.
Flowpaths are initiated along drainage divides and continue along the D8-defined
flow direction until either the subbasin outlet or DEM edge is encountered. Each input
subbasin/watershed will have an associated vector flowpath in the output image. <a href="./hydrological_analysis.html#longestflowpath"><strong>LongestFlowpath</strong></a>
is similar to the <code>r.lfp</code> plugin tool for GRASS GIS. The length of the longest flowpath
draining to an outlet is related to the time of concentration, which is a parameter
used in certain hydrological models.</p>
<p>The user must input the filename of a digital elevation model (DEM), a basins raster, and the
output vector. The DEM must be depressionless and should have been pre-processed using the
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. The <em>basins raster</em> must contain features
that are delineated by categorical (integer valued) unique indentifier values. All non-NoData,
non-zero valued grid cells in the basins raster are interpreted as belonging to features.
In practice, this tool is usual run using either a single watershed, a group of contiguous
non-overlapping watersheds, or a series of nested subbasins. These are often derived using
the <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tool, based on a series of input outlets, or the <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a> tool, based on
an input stream network. If subbasins are input to <a href="./hydrological_analysis.html#longestflowpath"><strong>LongestFlowpath</strong></a>, each traced flowpath
will include only the non-overlapping portions within nested areas. Therefore, this can be a
convienent method of delineating the longest flowpath to each bifurcation in a stream network.</p>
<p>The output vector file will contain fields in the attribute table that identify the associated
basin unique identifier (<em>BASIN</em>), the elevation of the flowpath source point on the divide
(<em>UP_ELEV</em>), the elevation of the outlet point (<em>DN_ELEV</em>), the length of the flowpath (<em>LENGTH</em>),
and finally, the average slope (<em>AVG_SLOPE</em>) along the flowpath, measured as a percent grade.</p>
<p><em>See Also</em>:</p>
<p><code>MaximumUpslopeFlowpath</code>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>--basins           </td><td> Input raster basins file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.longest_flowpath(
    dem, 
    basins, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LongestFlowpath -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif --basins=basins.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/longest_flowpath.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/10/2018</p>
<p><a name="MaxUpslopeFlowpathLength"></a></p>
<a class="header" href="#maxupslopeflowpathlength" id="maxupslopeflowpathlength"><h1>MaxUpslopeFlowpathLength</h1></a>
<p>Measures the maximum length of all upslope flowpaths draining each grid cell.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max_upslope_flowpath_length(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaxUpslopeFlowpathLength -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/max_upslope_flowpath.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 25, 2017</p>
<p><a name="NumInflowingNeighbours"></a></p>
<a class="header" href="#numinflowingneighbours" id="numinflowingneighbours"><h1>NumInflowingNeighbours</h1></a>
<p>Computes the number of inflowing neighbours to each cell in an input DEM based on the D8 algorithm.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.num_inflowing_neighbours(
    dem, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NumInflowingNeighbours -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/num_inflowing_neighbours.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 25, 2017</p>
<p><a name="RaiseWalls"></a></p>
<a class="header" href="#raisewalls" id="raisewalls"><h1>RaiseWalls</h1></a>
<p>This tool is used to increment the elevations in a digital elevation model (DEM) along
the boundaries of a vector lines or polygon layer. The user must specify the name of the
raster DEM (<code>--dem</code>), the vector file (<code>--input</code>), the output file name (<code>--output</code>), the
increment height (<code>--height</code>), and an optional breach lines vector layer (<code>--breach</code>).
The breach lines layer can be used to breach a whole in the raised walls at intersections
with the wall layer.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, walls, --input </td><td> Input vector lines or polygons file</td></tr>
<tr><td>--breach           </td><td> Optional input vector breach lines</td></tr>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--height           </td><td> Wall height</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raise_walls(
    i, 
    dem, 
    output, 
    breach=None, 
    height=100.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RaiseWalls -v --wd=&quot;/path/to/data/&quot; ^
-i=watershed.shp --dem=dem.tif -o=output.tif ^
--height=25.0
&gt;&gt;./whitebox_tools -r=RaiseWalls -v ^
--wd=&quot;/path/to/data/&quot; -i=watershed.shp --breach=outlet.shp ^
--dem=dem.tif -o=output.tif --height=25.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/raise_walls.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/04/2018</p>
<p><a name="Rho8Pointer"></a></p>
<a class="header" href="#rho8pointer" id="rho8pointer"><h1>Rho8Pointer</h1></a>
<p>Calculates a stochastic Rho8 flow pointer raster from an input DEM.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.rho8_pointer(
    dem, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Rho8Pointer -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/rho8_pointer.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 16, 2017</p>
<p><a name="Sink"></a></p>
<a class="header" href="#sink" id="sink"><h1>Sink</h1></a>
<p>This tool identifies each sink (i.e. topographic depression) in a raster digital elevation model (DEM). A
sink, or depression, is a bowl-like landscape feature, which is characterized by interior drainage. Each
identified sink in the input DEM is assigned a unique, non-zero, positive value in the ouput raster. The
<a href="./hydrological_analysis.html#sink"><strong>Sink</strong></a> tool essentially runs the <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool followed by the <a href="./gis_analysis.html#clump"><strong>Clump</strong></a> tool on all modified grid
cells.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a>, <a href="./gis_analysis.html#clump"><strong>Clump</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sink(
    dem, 
    output, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Sink -v --wd=&quot;/path/to/data/&quot; ^
--dem=DEM.tif -o=output.tif --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/sink.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="SnapPourPoints"></a></p>
<a class="header" href="#snappourpoints" id="snappourpoints"><h1>SnapPourPoints</h1></a>
<p>The <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> tool can be used to move the location of vector pour points (i.e. outlets used in a <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>
operation) (<code>--pour_pts</code>) to the location coincident with the highest flow accumulation (<code>--flow_accum</code>) value within
a specified maximum distance (<code>--snap_dist</code>). The pour points file (<code>--pour_pts</code>) must be a vector file of <em>Point</em> ShapeType.</p>
<p>If the output of the <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> tool is to be used with the <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tool, the flow accumulation raster should
be generated using the <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a> algorithm. The snap distance (<code>--snap_dist</code>), measured in map units (e.g.
meters), must also be specified. This distance will serve as the search radius placed around each pour point during the
search for the maximum flow accumulation. In general, each outlet will be relocated the distance specified by the snap
distance.</p>
<p>Lindsay et al. (2008) provide a detailed discussion of the <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> technique, and other more sophisticated
techniques for adjusting pour point locations used in watershedding operations including Jenson's snap pour points
(<a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a>) method. In most cases, the <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a> tool should be prefered for applications of
repositioning outlet points used in watershedding operations onto the digital stream lines contained in local drainage
direction rasters. Jenson's method relocates outlet points to the <em>nearest</em> stream cell while <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> relocated
outlets to the <em>largest</em> stream (designated by the largest flow accumulation value). In the common situation where outlet
cells are position near the confluence point of smaller tributary streams, the <a href="./hydrological_analysis.html#snappourpoints"><strong>SnapPourPoints</strong></a> tool may re-position
outlets on the main-trunk stream, which will result in watershed delineation of incorrect sub-basins.</p>
<p><em>Reference</em>:</p>
<p>Lindsay JB, Rothwell JJ, and Davies H. 2008. Mapping outlet points used for watershed delineation onto DEM-derived stream
networks, Water Resources Research, 44, W08442, doi:10.1029/2007WR006507.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a>, <a href="./hydrological_analysis.html#d8flowaccumulation"><strong>D8FlowAccumulation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--pour_pts         </td><td> Input vector pour points (outlet) file</td></tr>
<tr><td>--flow_accum       </td><td> Input raster D8 flow accumulation file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--snap_dist        </td><td> Maximum snap distance in map units</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.snap_pour_points(
    pour_pts, 
    flow_accum, 
    output, 
    snap_dist, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SnapPourPoints -v --wd=&quot;/path/to/data/&quot; ^
--pour_pts='pour_pts.shp' --flow_accum='d8accum.tif' ^
-o='output.shp' --snap_dist=15.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/snap_pour_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/072017</p>
<p><a name="StochasticDepressionAnalysis"></a></p>
<a class="header" href="#stochasticdepressionanalysis" id="stochasticdepressionanalysis"><h1>StochasticDepressionAnalysis</h1></a>
<p>This tool performs a stochastic analysis of depressions within a DEM, calculating the
probability of each cell belonging to a depression. This land-surface prameter
(p<sub>dep</sub>) has been widely applied in wetland and bottom-land mapping applications.</p>
<p>This tool differs from the original Whitebox GAT tool in a few significant ways:</p>
<ol>
<li>
<p>The Whitebox GAT tool took an error histogram as an input. In practice people found
it difficult to create this input. Usually they just generated a normal distribution
in a spreadsheet using information about the DEM root-mean-square-error (RMSE). As
such, this tool takes a RMSE input and generates the histogram internally. This is
more convienent for most applications but loses the flexibility of specifying the
error distribution more completely.</p>
</li>
<li>
<p>The Whitebox GAT tool generated the error fields using the turning bands method.
This tool generates a random Gaussian error field with no spatial autocorrelation
and then applies local spatial averaging using a Gaussian filter (the size of
which depends of the error autocorrelation length input) to increase the level of
autocorrelation. We use the Fast Almost Gaussian Filter of Peter Kovesi (2010),
which uses five repeat passes of a mean filter, based on an integral image. This
filter method is highly efficient. This results in a significant performance
increase compared with the original tool.</p>
</li>
<li>
<p>Parts of the tool's workflow utilize parallel processing. However, the depression
filling operation, which is the most time-consuming part of the workflow, is
not parallelized.</p>
</li>
</ol>
<p>In addition to the input DEM (<code>--dem</code>) and output p<sub>dep</sub> file name (<code>--output</code>), the user
must specify the nature of the error model, including the root-mean-square error (<code>--rmse</code>) and
the error field correlation length (<code>--range</code>). These parameters determine the statistical frequency
distribution and spatial characteristics of the modeled error fields added to the DEM in each
iteration of the simulation. The user must also specify the number of iterations (<code>--iterations</code>).
A larger number of iterations will produce a smoother p<sub>dep</sub> raster.</p>
<p>This tool creates several temporary rasters in memory and, as a result, is very memory hungry.
This will necessarily limit the size of DEMs that can be processed on more memory-constrained
systems. As a rough guide for usage, <strong>the computer system will need 6-10 times more memory than
the file size of the DEM</strong>. If your computer possesses insufficient memory, you may consider
splitting the input DEM apart into smaller tiles.</p>
<p><em>Reference</em>:</p>
<p>Lindsay, J. B., &amp; Creed, I. F. (2005). Sensitivity of digital landscapes to artifact depressions in
remotely-sensed DEMs. Photogrammetric Engineering &amp; Remote Sensing, 71(9), 1029-1036.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#impoundmentsizeindex"><strong>ImpoundmentSizeIndex</strong></a>, <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--rmse             </td><td> The DEM's root-mean-square-error (RMSE), in z units. This determines error magnitude</td></tr>
<tr><td>--range            </td><td> The error field's correlation length, in xy-units</td></tr>
<tr><td>--iterations       </td><td> The number of iterations</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stochastic_depression_analysis(
    dem, 
    output, 
    rmse, 
    range, 
    iterations=100, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StochasticDepressionAnalysis -v ^
--wd=&quot;/path/to/data/&quot; --dem=DEM.tif -o=out.tif --rmse=10.0 ^
--range=850.0 --iterations=2500 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/stochastic_depression_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/05/2018</p>
<p><a name="StrahlerOrderBasins"></a></p>
<a class="header" href="#strahlerorderbasins" id="strahlerorderbasins"><h1>StrahlerOrderBasins</h1></a>
<p>This tool will identify the catchment areas of each Horton-Strahler stream order link in a user-specified
stream network (<code>--streams</code>), i.e. the network's <em>Strahler basins</em>. The tool effectively performs a Horton-Strahler
stream ordering operation (<a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>) followed by by a <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> operation. The user must specify the name of a
flow pointer (flow direction) raster (<code>--d8_pntr</code>), a streams raster (<code>--streams</code>), and the output raster
(<code>--output</code>). The flow pointer and streams rasters should be generated using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This
will require a depressionless DEM, processed using either the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>NoData values in the input flow pointer raster are assigned NoData values in the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>, <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.strahler_order_basins(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StrahlerOrderBasins -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr='d8pntr.tif' ^
--streams='streams.tif' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/strahler_basins.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="Subbasins"></a></p>
<a class="header" href="#subbasins" id="subbasins"><h1>Subbasins</h1></a>
<p>This tool will identify the catchment areas to each link in a user-specified stream network, i.e. the
network's sub-basins. <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a> effectively performs a stream link ID operation (<a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a>) followed by
a <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> operation. The user must specify the name of a flow pointer (flow direction) raster (<code>--d8_pntr</code>),
a streams raster (<code>--streams</code>), and the output raster (<code>--output</code>). The flow pointer and streams rasters should
be generated using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This will require a depressionless DEM, processed using either
the <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool.</p>
<p><a href="./hydrological_analysis.html#hillslopes"><strong>Hillslopes</strong></a> are conceptually similar to sub-basins, except that sub-basins do not distinguish between the
right-bank and left-bank catchment areas of stream links. The Sub-basins tool simply assigns a unique identifier
to each stream link in a stream network.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>NoData values in the input flow pointer raster are assigned NoData values in the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a>, <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a>, <a href="./hydrological_analysis.html#hillslopes"><strong>Hillslopes</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.subbasins(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Subbasins -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr='d8pntr.tif' --streams='streams.tif' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/subbasins.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="TraceDownslopeFlowpaths"></a></p>
<a class="header" href="#tracedownslopeflowpaths" id="tracedownslopeflowpaths"><h1>TraceDownslopeFlowpaths</h1></a>
<p>Traces downslope flowpaths from one or more target sites (i.e. seed points).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--seed_pts         </td><td> Input vector seed points file</td></tr>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.trace_downslope_flowpaths(
    seed_pts, 
    d8_pntr, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TraceDownslopeFlowpaths -v ^
--wd=&quot;/path/to/data/&quot; --seed_pts=seeds.shp ^
--flow_dir=flow_directions.tif --output=flow_paths.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/trace_downslope_flowpaths.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 4, 2017</p>
<p><a name="UnnestBasins"></a></p>
<a class="header" href="#unnestbasins" id="unnestbasins"><h1>UnnestBasins</h1></a>
<p>In some applications it is necessary to relate a measured variable for a group of
hydrometric stations (e.g. characteristics of flow timing and duration or water
chemistry) to some characteristics of each outlet's catchment (e.g. mean slope,
area of wetlands, etc.). When the group of outlets are nested, i.e. some stations
are located downstream of others, then performing a watershed operation will
result in inappropriate watershed delineation. In particular, the delineated
watersheds of each nested outlet will not include the catchment areas of upstream
outlets. This creates a serious problem for this type of application.</p>
<p>The Unnest Basin tool can be used to perform a watershedding operation based on a
group of specified pour points, i.e. outlets or target cells, such that each
complete watershed is delineated. The user must specify the name of a flow pointer
(flow direction) raster, a pour point raster, and the name of the output rasters.
Multiple numbered outputs will be created, one for each nesting level. Pour point,
or target, cells are denoted in the input pour-point image as any non-zero,
non-NoData value. The flow pointer raster should be generated using the D8
algorithm.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>--pour_pts         </td><td> Input vector pour points (outlet) file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.unnest_basins(
    d8_pntr, 
    pour_pts, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=UnnestBasins -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr='d8pntr.tif' --pour_pts='pour_pts.shp' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/unnest_basins.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/04/2018</p>
<p><a name="Watershed"></a></p>
<a class="header" href="#watershed" id="watershed"><h1>Watershed</h1></a>
<p>This tool will perform a watershedding operation based on a group of input vector pour points (<code>--pour_pts</code>),
i.e. outlets or points-of-interest. Watershedding is a procedure that identifies all of the cells upslope of
a cell of interest (pour point) that are connected to the pour point by a flow-path. The user must specify the
name of a D8-derived flow pointer (flow direction) raster (<code>--d8_pntr</code>), a vector pour point file (<code>--pour_pts</code>),
and the output raster (<code>--output</code>). The pour points must be of a Point ShapeType (i.e. Point, PointZ, PointM,
MultiPoint, MultiPointZ, MultiPointM). Watersheds will be assigned the input pour point FID value. The flow
pointer raster must be generated using the D8 algorithm, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>.</p>
<p>Pour point vectors can be attained by on-screen digitizing to designate these points-of-interest locations.
Because pour points are usually, although not always, situated on a stream network, it is recommended that you
use Jenson's method (<a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a>) to snap pour points on the stream network. This will ensure that
the digitized outlets are coincident with the digital stream contained within the DEM flowpaths. If this is not
done prior to inputting a pour-point set to the <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> tool, anomalously small watersheds may be ouput, as
pour points that fall off of the main flow path (even by one cell) in the D8 pointer will yield very different
catchment areas.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>There are several tools that perform similar watershedding operations in WhiteboxTools. <a href="./hydrological_analysis.html#watershed"><strong>Watershed</strong></a> is appropriate
to use when you have a set of specific locations for which you need to derive the watershed areas. Use the <a href="./hydrological_analysis.html#basins"><strong>Basins</strong></a>
tool instead when you simply want to find the watersheds draining to each outlet situated along the edge of a
DEM. The <a href="./hydrological_analysis.html#isobasins"><strong>Isobasins</strong></a> tool can be used to divide a landscape into roughly equally sized watersheds. The <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a>
and <a href="./hydrological_analysis.html#strahlerorderbasins"><strong>StrahlerOrderBasins</strong></a> are useful when you need to find the areas draining to each link within a stream network.
Finally, <a href="./hydrological_analysis.html#hillslopes"><strong>Hillslopes</strong></a> can be used to idenfity the areas draining the each of the left and right banks of a stream
network.</p>
<p><em>Reference</em>:</p>
<p>Jenson, S. K. (1991), Applications of hydrological information automati-cally extracted from digital elevation
models, Hydrological Processes, 5, 31–44, doi:10.1002/hyp.3360050104.</p>
<p>Lindsay JB, Rothwell JJ, and Davies H. 2008. Mapping outlet points used for watershed delineation onto DEM-derived
stream networks, Water Resources Research, 44, W08442, doi:10.1029/2007WR006507.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./hydrological_analysis.html#basins"><strong>Basins</strong></a>, <a href="./hydrological_analysis.html#subbasins"><strong>Subbasins</strong></a>, <a href="./hydrological_analysis.html#isobasins"><strong>Isobasins</strong></a>, <a href="./hydrological_analysis.html#strahlerorderbasins"><strong>StrahlerOrderBasins</strong></a>, <a href="./hydrological_analysis.html#hillslopes"><strong>Hillslopes</strong></a>, <a href="./hydrological_analysis.html#jensonsnappourpoints"><strong>JensonSnapPourPoints</strong></a>,
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input D8 pointer raster file</td></tr>
<tr><td>--pour_pts         </td><td> Input vector pour points (outlet) file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.watershed(
    d8_pntr, 
    pour_pts, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Watershed -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr='d8pntr.tif' --pour_pts='pour_pts.shp' ^
-o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/hydro_analysis/watershed.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<a class="header" href="#image-processing-tools" id="image-processing-tools"><h1>Image Processing Tools</h1></a>
<ul>
<li><a href="#ChangeVectorAnalysis">ChangeVectorAnalysis</a></li>
<li><a href="#Closing">Closing</a></li>
<li><a href="#CreateColourComposite">CreateColourComposite</a></li>
<li><a href="#FlipImage">FlipImage</a></li>
<li><a href="#IhsToRgb">IhsToRgb</a></li>
<li><a href="#ImageStackProfile">ImageStackProfile</a></li>
<li><a href="#IntegralImage">IntegralImage</a></li>
<li><a href="#KMeansClustering">KMeansClustering</a></li>
<li><a href="#LineThinning">LineThinning</a></li>
<li><a href="#ModifiedKMeansClustering">ModifiedKMeansClustering</a></li>
<li><a href="#Mosaic">Mosaic</a></li>
<li><a href="#MosaicWithFeathering">MosaicWithFeathering</a></li>
<li><a href="#NormalizedDifferenceIndex">NormalizedDifferenceIndex</a></li>
<li><a href="#Opening">Opening</a></li>
<li><a href="#RemoveSpurs">RemoveSpurs</a></li>
<li><a href="#Resample">Resample</a></li>
<li><a href="#RgbToIhs">RgbToIhs</a></li>
<li><a href="#SplitColourComposite">SplitColourComposite</a></li>
<li><a href="#ThickenRasterLine">ThickenRasterLine</a></li>
<li><a href="#TophatTransform">TophatTransform</a></li>
<li><a href="#WriteFunctionMemoryInsertion">WriteFunctionMemoryInsertion</a></li>
</ul>
<p><a name="ChangeVectorAnalysis"></a></p>
<a class="header" href="#changevectoranalysis" id="changevectoranalysis"><h1>ChangeVectorAnalysis</h1></a>
<p>Change Vector Analysis (CVA) is a change detection method that characterizes the
magnitude and change direction in spectral space between two times. A change vector
is the difference vector between two vectors in n-dimensional feature space defined
for two observations of the same geographical location (i.e. corresponding pixels)
during two dates. The CVA inputs include the set of raster images corresponding to
the multispectral data for each date. Note that there must be the same number of
image files (bands) for the two dates and they must be entered in the same order,
i.e. if three bands, red, green, and blue are entered for date one, these same
bands must be entered in the same order for date two.</p>
<p>CVA outputs two image files. The first image contains the change vector length,
i.e. magnitude, for each pixel in the multi-spectral dataset. The second image
contains information about the direction of the change event in spectral feature
space, which is related to the type of change event, e.g. deforestation will likely
have a different change direction than say crop growth. The vector magnitude is a
continuous numerical variable. The change vector direction is presented in the form
of a code, referring to the multi-dimensional sector in which the change vector
occurs. A text output will be produced to provide a key describing sector codes,
relating the change vector to positive or negative shifts in n-dimensional feature
space.</p>
<p>It is common to apply a simple thresholding operation on the magnitude data to
determine 'actual' change (i.e. change above some assumed level of error). The type
of change (qualitatively) is then defined according to the corresponding sector code.
Jensen (2015) provides a useful description of this approach to change detection.</p>
<p><em>Reference</em>:</p>
<p>Jensen, J. R. (2015). Introductory Digital Image Processing: A Remote Sensing Perspective.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#writefunctionmemoryinsertion"><strong>WriteFunctionMemoryInsertion</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--date1            </td><td> Input raster files for the earlier date</td></tr>
<tr><td>--date2            </td><td> Input raster files for the later date</td></tr>
<tr><td>--magnitude        </td><td> Output vector magnitude raster file</td></tr>
<tr><td>--direction        </td><td> Output vector Direction raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.change_vector_analysis(
    date1, 
    date2, 
    magnitude, 
    direction, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ChangeVectorAnalysis -v ^
--wd=&quot;/path/to/data/&quot; ^
--date1='d1_band1.tif;d1_band2.tif;d1_band3.tif' ^
--date2='d2_band1.tif;d2_band2.tif;d2_band3.tif' ^
--magnitude=mag_out.tif --direction=dir_out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/change_vector_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/04/2018</p>
<p><a name="Closing"></a></p>
<a class="header" href="#closing" id="closing"><h1>Closing</h1></a>
<p>This tool performs a closing operation on an input greyscale image (<code>--input</code>). A
<a href="https://en.wikipedia.org/wiki/Closing_(morphology)">closing</a> is a mathematical morphology operation involving
an erosion (minimum filter) of a dilation (maximum filter) set. <a href="./image_processing_tools.html#closing"><strong>Closing</strong></a> operations, together with the
<a href="./image_processing_tools.html#opening"><strong>Opening</strong></a> operation, is frequently used in the fields of computer vision and digital image processing for
image noise removal. The user must specify the size of the moving
window in both the x and y directions (<code>--filterx</code> and <code>--filtery</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#opening"><strong>Opening</strong></a>, <a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.closing(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Closing -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/closing.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="CreateColourComposite"></a></p>
<a class="header" href="#createcolourcomposite" id="createcolourcomposite"><h1>CreateColourComposite</h1></a>
<p>This tool can be used to create a colour-composite image from three bands of multi-spectral imagery.
The user must specify the names of the input images to enter into the red, green, and blue channels
of the resulting composite image. The output image uses the 32-bit aRGB colour model, and therefore,
in addition to red, green and blue bands, the user may optionally specify a fourth image that will
be used to determine pixel opacity (the 'a' channel). If no opacity image is specified, each pixel
will be opaque. This can be useful for cropping an image to an irregular-shaped boundary. The opacity
channel can also be used to create transparent gradients in the composite image.</p>
<p>A balance contrast enchancment (BCE) can optionally be performed on the bands prior to creation of
the colour composite. While this operation will add to the runtime of <a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a>, if
the individual input bands have not already had contrast enchancements, then it is advisable that
the BCE option be used to improve the quality of the resulting colour composite image.</p>
<p>NoData values in any of the input images are assigned NoData values in the output image and are not
taken into account when performing the BCE operation. Please note, not all images have NoData values
identified. When this is the case, and when the background value is 0 (often the case with
multispectral imagery), then the <a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a> tool can be told to ignore zero values using
the <code>--zeros</code> flag.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#balancecontrastenhancement"><strong>BalanceContrastEnhancement</strong></a>, <a href="./image_processing_tools.html#splitcolourcomposite"><strong>SplitColourComposite</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--red              </td><td> Input red band image file</td></tr>
<tr><td>--green            </td><td> Input green band image file</td></tr>
<tr><td>--blue             </td><td> Input blue band image file</td></tr>
<tr><td>--opacity          </td><td> Input opacity band image file (optional)</td></tr>
<tr><td>-o, --output       </td><td> Output colour composite file</td></tr>
<tr><td>--enhance          </td><td> Optional flag indicating whether a balance contrast enhancement is performed</td></tr>
<tr><td>--zeros            </td><td> Optional flag to indicate if zeros are nodata values</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.create_colour_composite(
    red, 
    green, 
    blue, 
    output, 
    opacity=None, 
    enhance=True, 
    zeros=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CreateColourComposite -v ^
--wd=&quot;/path/to/data/&quot; --red=band3.tif --green=band2.tif ^
--blue=band1.tif -o=output.tif
&gt;&gt;./whitebox_tools ^
-r=CreateColourComposite -v --wd=&quot;/path/to/data/&quot; ^
--red=band3.tif --green=band2.tif --blue=band1.tif ^
--opacity=a.tif -o=output.tif --enhance --zeros 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/create_colour_composite.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2017</p>
<p><a name="FlipImage"></a></p>
<a class="header" href="#flipimage" id="flipimage"><h1>FlipImage</h1></a>
<p>This tool can be used to flip, or reflect, an image (<code>--input</code>) either vertically, horizontally, or both. The
axis of reflection is specified using the <code>--direction</code> parameter. The input image is not reflected in place;
rather, the reflected image is stored in a separate output (<code>--output</code>) file.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--direction        </td><td> Direction of reflection; options include 'v' (vertical), 'h' (horizontal), and 'b' (both)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flip_image(
    i, 
    output, 
    direction=&quot;vertical&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FlipImage -v --wd=&quot;/path/to/data/&quot; ^
--input=in.tif -o=out.tif --direction=h 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/flip_image.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="IhsToRgb"></a></p>
<a class="header" href="#ihstorgb" id="ihstorgb"><h1>IhsToRgb</h1></a>
<p>This tool transforms three intensity, hue, and saturation (IHS; sometimes HSI or HIS) raster images into three
equivalent multispectral images corresponding with the red, green, and blue channels of an RGB composite. Intensity
refers to the brightness of a color, hue is related to the dominant wavelength of light and is perceived as color,
and saturation is the purity of the color (Koutsias et al., 2000). There are numerous algorithms for performing a
red-green-blue (RGB) to IHS transformation. This tool uses the transformation described by Haydn (1982). Note that,
based on this transformation, the input IHS values must follow the ranges:</p>
<blockquote>
<p>0 &lt; I &lt; 1</p>
<p>0 &lt; H &lt; 2PI</p>
<p>0 &lt; S &lt; 1</p>
</blockquote>
<p>The output red, green, and blue images will have values ranging from 0 to 255. The user must specify the names of the
intensity, hue, and saturation images (<code>--intensity</code>, <code>--hue</code>, <code>--saturation</code>). These images will generally be created using
the <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a> tool. The user must also specify the names of the output red, green, and blue images (<code>--red</code>, <code>--green</code>,
<code>--blue</code>). Image enhancements, such as contrast stretching, are often performed on the individual IHS components, which are
then inverse transformed back in RGB components using this tool. The output RGB components can then be used to create an
improved color composite image.</p>
<p><em>References</em>:</p>
<p>Haydn, R., Dalke, G.W. and Henkel, J. (1982) Application of the IHS color transform to the processing of multisensor
data and image enhancement. Proc. of the Inter- national Symposium on Remote Sensing of Arid and Semiarid Lands,
Cairo, 599-616.</p>
<p>Koutsias, N., Karteris, M., and Chuvico, E. (2000). The use of intensity-hue-saturation transformation of Landsat-5 Thematic
Mapper data for burned land mapping. Photogrammetric Engineering and Remote Sensing, 66(7), 829-840.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a>, <a href="./image_processing_tools_image_enhancement.html#balancecontrastenhancement"><strong>BalanceContrastEnhancement</strong></a>, <a href="./image_processing_tools_image_enhancement.html#directdecorrelationstretch"><strong>DirectDecorrelationStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--intensity        </td><td> Input intensity file</td></tr>
<tr><td>--hue              </td><td> Input hue file</td></tr>
<tr><td>--saturation       </td><td> Input saturation file</td></tr>
<tr><td>--red              </td><td> Output red band file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--green            </td><td> Output green band file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--blue             </td><td> Output blue band file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>-o, --output       </td><td> Output colour-composite file. Only used if individual bands are not specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ihs_to_rgb(
    intensity, 
    hue, 
    saturation, 
    red=None, 
    green=None, 
    blue=None, 
    output=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IhsToRgb -v --wd=&quot;/path/to/data/&quot; ^
--intensity=intensity.tif --hue=hue.tif ^
--saturation=saturation.tif --red=band3.tif --green=band2.tif ^
--blue=band1.tif
&gt;&gt;./whitebox_tools -r=IhsToRgb -v ^
--wd=&quot;/path/to/data/&quot; --intensity=intensity.tif --hue=hue.tif ^
--saturation=saturation.tif --composite=image.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/ihs_to_rgb.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/07/2017</p>
<p><a name="ImageStackProfile"></a></p>
<a class="header" href="#imagestackprofile" id="imagestackprofile"><h1>ImageStackProfile</h1></a>
<p>This tool can be used to plot an image stack profile (i.e. a signature) for a set of points (<code>--points</code>) and
a multispectral image stack (<code>--inputs</code>). The tool outputs an interactive SVG line graph embedded in an
HTML document (<code>--output</code>). If the input points vector contains multiple points, each input point will
be associated with a single line in the output plot. The order of vertices in each signature line is
determined by the order of images specified in the <code>--inputs</code> parameter. At least two input images are
required to run this operation. Note that this tool does not require multispectral images as
inputs; other types of data may also be used as the image stack. Also note that the input images should be
single-band, continuous greytone rasters. RGB colour images are not good candidates for this tool.</p>
<p>If you require the raster values to be saved in the vector points file's attribute table, or if you need
the raster values to be output as text, you may use the <a href="./gis_analysis.html#extractrastervaluesatpoints"><strong>ExtractRasterValuesAtPoints</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#extractrastervaluesatpoints"><strong>ExtractRasterValuesAtPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input multispectral image files</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.image_stack_profile(
    inputs, 
    points, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ImageStackProfile -v ^
--wd=&quot;/path/to/data/&quot; -i='image1.tif;image2.tif;image3.tif' ^
--points=pts.shp -o=output.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/image_stack_profile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/03/2018</p>
<p><a name="IntegralImage"></a></p>
<a class="header" href="#integralimage" id="integralimage"><h1>IntegralImage</h1></a>
<p>This tool transforms an input raster image into an integral image, or summed area table. Integral images are
the two-dimensional equivalent to a cumulative distribution function. Each pixel contains the sum of all
pixels contained within the enclosing rectangle above and to the left of a pixel. Images with a very large
number of grid cells will likely experience numerical overflow errors when converted to an integral image.
Integral images are used in a wide variety of computer vision and digital image processing applications,
including texture mapping. They allow for the efficient calculation of very large filters and are the
basis of several of <em>WhiteboxTools</em>'s image filters.</p>
<p><em>Reference</em>:</p>
<p>Crow, F. C. (1984, January). Summed-area tables for texture mapping. In ACM SIGGRAPH computer graphics
(Vol. 18, No. 3, pp. 207-212). ACM.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.integral_image(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IntegralImage -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/integral_image.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="KMeansClustering"></a></p>
<a class="header" href="#kmeansclustering" id="kmeansclustering"><h1>KMeansClustering</h1></a>
<p>This tool can be used to perform a k-means clustering operation on two or more input
images (<code>--inputs</code>), typically several bands of multi-spectral satellite imagery. The
tool creates two outputs, including the classified image (<code>--output</code> and a classification
HTML report (<code>--out_html</code>). The user must specify the number of class (<code>--classes</code>), which should be
known <em>a priori</em>, and the strategy for initializing class clusters (<code>--initialize</code>). The initilization
strategies include &quot;diagonal&quot; (clusters are initially located randomly along the multi-dimensional diagonal
of spectral space) and &quot;random&quot; (clusters are initially located randomly throughout spectral space).
The algorithm will continue updating cluster center locations with each iteration of the process until
either the user-specified maximum number of iterations (<code>--max_iterations</code>) is reached, or until a
stability criteria (<code>--class_change</code>) is achieved. The stability criteria is the percent of the total
number of pixels in the image that are changed among the class values between consecutive iterations.
Lastly, the user must specify the minimum allowable number of pixels in a cluster (<code>--min_class_size</code>).</p>
<p>Note, each of the input images must have the same number of rows and columns and the same spatial extent
because the analysis is performed on a pixel-by-pixel basis. <strong>NoData</strong> values in any of the input images
will result in the removal of the corresponding pixel from the analysis.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#modifiedkmeansclustering"><strong>ModifiedKMeansClustering</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_html         </td><td> Output HTML report file</td></tr>
<tr><td>--classes          </td><td> Number of classes</td></tr>
<tr><td>--max_iterations   </td><td> Maximum number of iterations</td></tr>
<tr><td>--class_change     </td><td> Minimum percent of cells changed between iterations before completion</td></tr>
<tr><td>--initialize       </td><td> How to initialize cluster centres?</td></tr>
<tr><td>--min_class_size   </td><td> Minimum class size, in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.k_means_clustering(
    inputs, 
    output, 
    classes, 
    out_html=None, 
    max_iterations=10, 
    class_change=2.0, 
    initialize=&quot;diagonal&quot;, 
    min_class_size=10, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=KMeansClustering -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif --out_html=report.html --classes=15 ^
--max_iterations=25 --class_change=1.5 --initialize='random' ^
--min_class_size=500 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/k_means_clustering.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/12/2017</p>
<p><a name="LineThinning"></a></p>
<a class="header" href="#linethinning" id="linethinning"><h1>LineThinning</h1></a>
<p>This image processing tool reduces all polygons in a Boolean raster image to their single-cell wide skeletons.
This operation is sometimes called line thinning or skeletonization. In fact, the input image need not be truly
Boolean (i.e. contain only 1's and 0's). All non-zero, positive values are considered to be foreground pixels while
all zero valued cells are considered background pixels. The <a href="./image_processing_tools.html#removespurs"><strong>RemoveSpurs</strong></a> tool is useful for cleaning up an image
before performing a line thinning operation.</p>
<p>Note: Unlike other filter-based operations in <em>WhiteboxTools</em>, this algorithm can't easily be parallelized because
the output raster must be read and written to during the same loop.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#removespurs"><strong>RemoveSpurs</strong></a>, <a href="./image_processing_tools.html#thickenrasterline"><strong>ThickenRasterLine</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.line_thinning(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LineThinning -v --wd=&quot;/path/to/data/&quot; ^
--input=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/line_thin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="ModifiedKMeansClustering"></a></p>
<a class="header" href="#modifiedkmeansclustering" id="modifiedkmeansclustering"><h1>ModifiedKMeansClustering</h1></a>
<p>This modified k-means algorithm is similar to that described by Mather and Koch (2011).
The main difference between the traditional k-means and this technique is that the user
does not need to specify the desired number of classes/clusters prior to running the
tool. Instead, the algorithm initializes with a very liberal overestimate of the number
of classes and then merges classes that have cluster centres that are separated by less
than a user-defined threshold. The main difference between this algorithm and the ISODATA
technique is that clusters can not be broken apart into two smaller clusters.</p>
<p><em>Reference</em>:</p>
<p>Mather, P. M., &amp; Koch, M. (2011). Computer processing of remotely-sensed images: an
introduction. John Wiley &amp; Sons.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#kmeansclustering"><strong>KMeansClustering</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_html         </td><td> Output HTML report file</td></tr>
<tr><td>--start_clusters   </td><td> Initial number of clusters</td></tr>
<tr><td>--merge_dist       </td><td> Cluster merger distance</td></tr>
<tr><td>--max_iterations   </td><td> Maximum number of iterations</td></tr>
<tr><td>--class_change     </td><td> Minimum percent of cells changed between iterations before completion</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.modified_k_means_clustering(
    inputs, 
    output, 
    out_html=None, 
    start_clusters=1000, 
    merge_dist=None, 
    max_iterations=10, 
    class_change=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ModifiedKMeansClustering -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
-o=output.tif --out_html=report.html --start_clusters=100 ^
--merge_dist=30.0 --max_iterations=25 --class_change=1.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/modified_k_means_clustering.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/12/2017</p>
<p><a name="Mosaic"></a></p>
<a class="header" href="#mosaic" id="mosaic"><h1>Mosaic</h1></a>
<p>This tool will create an image mosaic from one or more input image files using
one of three resampling methods including, nearest neighbour, bilinear interpolation,
and cubic convolution. The order of the input source image files is important. Grid
cells in the output image will be assigned the corresponding value determined from the
first image found in the list to possess an overlapping coordinate.</p>
<p>This is the preferred mosaicing tool to use when appending multiple images with
little to no overlapping areas, e.g. tiled data. When images have significant overlap
areas, users are advised to use the <a href="./image_processing_tools.html#mosaicwithfeathering"><strong>MosaicWithFeathering</strong></a> tool instead.</p>
<p>Resample is very similar in operation to the Mosaic tool. The Resample tool should be
used when there is an existing image into which you would like to dump information from
one or more source images. If the source images are more extensive than the destination
image, i.e. there are areas that extend beyond the destination image boundaries, these
areas will not be represented in the updated image. Grid cells in the destination image
that are not overlapping with any of the input source images will not be updated, i.e.
they will possess the same value as before the resampling operation. The Mosaic tool is
used when there is no existing destination image. In this case, a new image is created
that represents the bounding rectangle of each of the two or more input images. Grid
cells in the output image that do not overlap with any of the input images will be
assigned the NoData value.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#mosaicwithfeathering"><strong>MosaicWithFeathering</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--method           </td><td> Resampling method; options include 'nn' (nearest neighbour), 'bilinear', and 'cc' (cubic convolution)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.mosaic(
    inputs, 
    output, 
    method=&quot;cc&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Mosaic -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' -o=dest.tif ^
--method='cc' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/mosaic.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/01/2018</p>
<p><a name="MosaicWithFeathering"></a></p>
<a class="header" href="#mosaicwithfeathering" id="mosaicwithfeathering"><h1>MosaicWithFeathering</h1></a>
<p>This tool will create a mosaic from two input images. It is similar in operation to the <a href="./image_processing_tools.html#mosaic"><strong>Mosaic</strong></a> tool,
however, this tool is the preferred method of mosaicing images when there is significant overlap between
the images. For areas of overlap, the feathering method will calculate the output value as a weighted
combination of the two input values, where the weights are derived from the squared distance of the
pixel to the edge of the data in each of the input raster files. Therefore, less weight is assigned to
an image's pixel value where the pixel is very near the edge of the image. Note that the distance is
actually calculated to the edge of the grid and not necessarily the edge of the data, which can differ
if the image has been rotated during registration.  The result of this feathering method is that the
output mosaic image should have very little evidence of the original image edges within the overlapping
area.</p>
<p>Unlike the Mosaic tool, which can take multiple input images, this tool only accepts two input images.
Mosaic is therefore useful when there are many, adjacent or only slightly overlapping images, e.g. for
tiled data sets.</p>
<p>Users may want to use the <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a> tool prior to mosaicing if the two input images differ
significantly in their radiometric properties. i.e. if image contrast differences exist.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#mosaic"><strong>Mosaic</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input raster file to modify</td></tr>
<tr><td>--i2, --input2    </td><td> Input reference raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--method           </td><td> Resampling method; options include 'nn' (nearest neighbour), 'bilinear', and 'cc' (cubic convolution)</td></tr>
<tr><td>--weight           </td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.mosaic_with_feathering(
    input1, 
    input2, 
    output, 
    method=&quot;cc&quot;, 
    weight=4.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MosaicWithFeathering -v ^
--wd='/path/to/data/' --input1='image1.tif' ^
--input2='image2.tif' -o='output.tif' --method='cc' ^
--weight=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/mosaic_with_feathering.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/12/2018</p>
<p><a name="NormalizedDifferenceIndex"></a></p>
<a class="header" href="#normalizeddifferenceindex" id="normalizeddifferenceindex"><h1>NormalizedDifferenceIndex</h1></a>
<p>This tool can be used to calculate a normalized difference index (NDI) from two bands of multispectral image data.
A NDI of two band images (<code>image1</code> and <code>image2</code>) takes the general form:</p>
<blockquote>
<p>NDI = (image1 - image2) / (image1 + image2 + <em>c</em>)</p>
</blockquote>
<p>Where <em>c</em> is a correction factor sometimes used to avoid division by zero. It is, however, often set to 0.0. In fact,
the <a href="./image_processing_tools.html#normalizeddifferenceindex"><strong>NormalizedDifferenceIndex</strong></a> tool will set all pixels where <code>image1 + image2 = 0</code> to 0.0 in the output image. While
this is not strictly mathematically correct (0 / 0 = infinity), it is often the intended output in these cases.</p>
<p>NDIs generally takes the value range -1.0 to 1.0, although in practice the range of values for a particular image scene
may be more restricted than this.</p>
<p>NDIs have two important properties that make them particularly useful for remote sensing applications. First, they
emphasize certain aspects of the shape of the spectral signatures of different land covers. Secondly, they can be
used to de-emphasize the effects of variable illumination within a scene. NDIs are therefore frequently used in the
field of remote sensing to create vegetation indices and other indices for emphasizing various land-covers and as inputs
to analytical operations like image classification. For example, the normalized difference vegetation index (NDVI),
one of the most common image-derived products in remote sensing, is calculated as:</p>
<blockquote>
<p>NDVI = (NIR - RED) / (NIR + RED)</p>
</blockquote>
<p>The optimal soil adjusted vegetation index (OSAVI) is:</p>
<blockquote>
<p>OSAVI = (NIR - RED) / (NIR + RED + 0.16)</p>
</blockquote>
<p>The normalized difference water index (NDWI), or normalized difference moisture index (NDMI), is:</p>
<blockquote>
<p>NDWI = (NIR - SWIR) / (NIR + SWIR)</p>
</blockquote>
<p>The normalized burn ratio 1 (NBR1) and normalized burn ration 2 (NBR2) are:</p>
<blockquote>
<p>NBR1 = (NIR - SWIR2) / (NIR + SWIR2)</p>
<p>NBR2 = (SWIR1 - SWIR2) / (SWIR1 + SWIR2)</p>
</blockquote>
<p>In addition to NDIs, <em>Simple Ratios</em> of image bands, are also commonly used as inputs to other remote sensing
applications like image classification. Simple ratios can be calculated using the <a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a> tool. Division by zero,
in this case, will result in an output NoData value.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input image 1 (e.g. near-infrared band)</td></tr>
<tr><td>--input2           </td><td> Input image 2 (e.g. red band)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
<tr><td>--correction       </td><td> Optional adjustment value (e.g. 1, or 0.16 for the optimal soil adjusted vegetation index, OSAVI)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.normalized_difference_index(
    input1, 
    input2, 
    output, 
    clip=0.0, 
    correction=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NormalizedDifferenceIndex -v ^
--wd=&quot;/path/to/data/&quot; --input1=band4.tif --input2=band3.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=NormalizedDifferenceIndex ^
-v --wd=&quot;/path/to/data/&quot; --input1=band4.tif --input2=band3.tif ^
-o=output.tif --clip=1.0 --adjustment=0.16 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/normalized_difference_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="Opening"></a></p>
<a class="header" href="#opening" id="opening"><h1>Opening</h1></a>
<p>This tool performs an opening operation on an input greyscale image (<code>--input</code>). An
<a href="https://en.wikipedia.org/wiki/Opening_(morphology)">opening</a> is a mathematical morphology operation involving
a dilation (maximum filter) on an erosion (minimum filter) set. <a href="./image_processing_tools.html#opening"><strong>Opening</strong></a> operations, together with the
<a href="./image_processing_tools.html#closing"><strong>Closing</strong></a> operation, is frequently used in the fields of computer vision and digital image processing for
image noise removal. The user must specify the size of the moving window in both the x and y directions
(<code>--filterx</code> and <code>--filtery</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#closing"><strong>Closing</strong></a>, <a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.opening(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Opening -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/opening.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="RemoveSpurs"></a></p>
<a class="header" href="#removespurs" id="removespurs"><h1>RemoveSpurs</h1></a>
<p>This image processing tool removes small irregularities (i.e. spurs) on the boundaries of objects in a
Boolean input raster image (<code>--input</code>). This operation is sometimes called <em>pruning</em>. Remove Spurs is a useful tool
for cleaning an image before performing a line thinning operation. In fact, the input image need not be truly
Boolean (i.e. contain only 1's and 0's). All non-zero, positive values are considered to be foreground pixels
while all zero valued cells are considered background pixels.</p>
<p>Note: Unlike other filter-based operations in <em>WhiteboxTools</em>, this algorithm can't easily be parallelized because
the output raster must be read and written to during the same loop.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#linethinning"><strong>LineThinning</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--iterations       </td><td> Maximum number of iterations</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_spurs(
    i, 
    output, 
    iterations=10, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemoveSpurs -v --wd=&quot;/path/to/data/&quot; ^
--input=DEM.tif -o=output.tif --iterations=10 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/remove_spurs.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="Resample"></a></p>
<a class="header" href="#resample" id="resample"><h1>Resample</h1></a>
<p>Resample is very similar in operation to the Mosaic tool. The Resample tool should
be used when there is an existing image into which you would like to dump information
from one or more source images. If the source images are more extensive than the
destination image, i.e. there are areas that extend beyond the destination image
boundaries, these areas will not be represented in the updated image. Grid cells in the
destination image that are not overlapping with any of the input source images will not
be updated, i.e. they will possess the same value as before the resampling operation. The
Mosaic tool is used when there is no existing destination image. In this case, a new
image is created that represents the bounding rectangle of each of the two or more input
images. Grid cells in the output image that do not overlap with any of the input images
will be assigned the NoData value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--destination      </td><td> Destination raster file</td></tr>
<tr><td>--method           </td><td> Resampling method; options include 'nn' (nearest neighbour), 'bilinear', and 'cc' (cubic convolution)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.resample(
    inputs, 
    destination, 
    method=&quot;cc&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Resample -v --wd='/path/to/data/' ^
-i='image1.tif;image2.tif;image3.tif' --destination=dest.tif ^
--method='cc 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/resample.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/01/2018</p>
<p><a name="RgbToIhs"></a></p>
<a class="header" href="#rgbtoihs" id="rgbtoihs"><h1>RgbToIhs</h1></a>
<p>This tool transforms three raster images of multispectral data (red, green, and blue channels) into their equivalent
intensity, hue, and saturation (IHS; sometimes HSI or HIS) images. Intensity refers to the brightness of a color, hue
is related to the dominant wavelength of light and is perceived as color, and saturation is the purity of the color
(Koutsias et al., 2000). There are numerous algorithms for performing a red-green-blue (RGB) to IHS transformation.
This tool uses the transformation described by Haydn (1982). Note that, based on this transformation, the output
IHS values follow the ranges:</p>
<blockquote>
<p>0 &lt; I &lt; 1</p>
<p>0 &lt; H &lt; 2PI</p>
<p>0 &lt; S &lt; 1</p>
</blockquote>
<p>The user must specify the names of the red, green, and blue images (<code>--red</code>, <code>--green</code>, <code>--blue</code>). Importantly, these
images need not necessarily correspond with the specific regions of the electromagnetic spectrum that are red, green,
and blue. Rather, the input images are three multispectral images that could be used to create a RGB color composite.
The user must also specify the names of the output intensity, hue, and saturation images (<code>--intensity</code>, <code>--hue</code>,
<code>--saturation</code>). Image enhancements, such as contrast stretching, are often performed on the IHS components, which are
then inverse transformed back in RGB components to then create an improved color composite image.</p>
<p><em>References</em>:</p>
<p>Haydn, R., Dalke, G.W. and Henkel, J. (1982) Application of the IHS color transform to the processing of multisensor
data and image enhancement. Proc. of the Inter- national Symposium on Remote Sensing of Arid and Semiarid Lands,
Cairo, 599-616.</p>
<p>Koutsias, N., Karteris, M., and Chuvico, E. (2000). The use of intensity-hue-saturation transformation of Landsat-5 Thematic
Mapper data for burned land mapping. Photogrammetric Engineering and Remote Sensing, 66(7), 829-840.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#ihstorgb"><strong>IhsToRgb</strong></a>, <a href="./image_processing_tools_image_enhancement.html#balancecontrastenhancement"><strong>BalanceContrastEnhancement</strong></a>, <a href="./image_processing_tools_image_enhancement.html#directdecorrelationstretch"><strong>DirectDecorrelationStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--red              </td><td> Input red band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--green            </td><td> Input green band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--blue             </td><td> Input blue band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--composite        </td><td> Input colour-composite image file. Only used if individual bands are not specified</td></tr>
<tr><td>--intensity        </td><td> Output intensity raster file</td></tr>
<tr><td>--hue              </td><td> Output hue raster file</td></tr>
<tr><td>--saturation       </td><td> Output saturation raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.rgb_to_ihs(
    intensity, 
    hue, 
    saturation, 
    red=None, 
    green=None, 
    blue=None, 
    composite=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RgbToIhs -v --wd=&quot;/path/to/data/&quot; ^
--red=band3.tif --green=band2.tif --blue=band1.tif ^
--intensity=intensity.tif --hue=hue.tif ^
--saturation=saturation.tif
&gt;&gt;./whitebox_tools -r=RgbToIhs -v ^
--wd=&quot;/path/to/data/&quot; --composite=image.tif ^
--intensity=intensity.tif --hue=hue.tif ^
--saturation=saturation.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/rgb_to_ihs.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/07/2017</p>
<p><a name="SplitColourComposite"></a></p>
<a class="header" href="#splitcolourcomposite" id="splitcolourcomposite"><h1>SplitColourComposite</h1></a>
<p>This tool can be used to split a red-green-blue (RGB) colour-composite image into three separate bands of
multi-spectral imagery. The user must specify the input image (<code>--input</code>) and output red, green, blue images
(<code>--red</code>, <code>--green</code>, <code>--blue</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input colour composite image file</td></tr>
<tr><td>--red              </td><td> Output red band file</td></tr>
<tr><td>--green            </td><td> Output green band file</td></tr>
<tr><td>--blue             </td><td> Output blue band file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.split_colour_composite(
    i, 
    red=None, 
    green=None, 
    blue=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SplitColourComposite -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif --red=red.tif ^
--green=green.tif --blue=blue.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/split_colour_composite.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/07/2017</p>
<p><a name="ThickenRasterLine"></a></p>
<a class="header" href="#thickenrasterline" id="thickenrasterline"><h1>ThickenRasterLine</h1></a>
<p>This image processing tool can be used to thicken single-cell wide lines within a raster file along diagonal
sections of the lines. Because of the limitation of the raster data format, single-cell wide raster lines can
be traversed along diaganol sections without passing through a line grid cell. This causes problems for various
raster analysis functions for which lines are intended to be barriers. This tool will thicken raster lines,
such that it is impossible to cross a line without passing through a line grid cell. While this can also be
achieved using a maximum filter, unlike the filter approach, this tool will result in the smallest possible
thickening to achieve the desired result.</p>
<p>All non-zero, positive values are considered to be foreground pixels while all zero valued cells or NoData cells
are considered background pixels.</p>
<p>Note: Unlike other filter-based operations in <em>WhiteboxTools</em>, this algorithm can't easily be parallelized because
the output raster must be read and written to during the same loop.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#linethinning"><strong>LineThinning</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.thicken_raster_line(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ThickenRasterLine -v ^
--wd=&quot;/path/to/data/&quot; --input=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/thicken_line.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/07/2017</p>
<p><a name="TophatTransform"></a></p>
<a class="header" href="#tophattransform" id="tophattransform"><h1>TophatTransform</h1></a>
<p>This tool performs either a white or black <a href="https://en.wikipedia.org/wiki/Top-hat_transform">top-hat transform</a>
on an input image. A top-hat transform is a common digital image processing operation used for various tasks, such
as feature extraction, background equalization, and image enhancement. The size of the rectangular <em>structuring element</em>
used in the filtering can be specified using the <code>--filterx</code> and <code>--filtery</code> flags.</p>
<p>There are two distinct types of top-hat transform including <em>white</em> and <em>black</em> top-hat transforms. The white top-hat
transform is defined as the difference between the input image and its <a href="https://en.wikipedia.org/wiki/Opening_(morphology)">opening</a>
by some structuring element. An opening operation is the <a href="https://en.wikipedia.org/wiki/Dilation_(morphology)">dilation</a>
(maximum filter) of an <a href="https://en.wikipedia.org/wiki/Erosion_(morphology)">erosion</a> (minimum filter) image.
The black top-hat transform, by comparison, is defined as the difference between the
<a href="https://en.wikipedia.org/wiki/Closing_(morphology)">closing</a> and the input image. The user specifies which of the two
flavours of top-hat transform the tool should perform by specifying either 'white' or 'black' with the <code>--variant</code> flag.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#closing"><strong>Closing</strong></a>, <a href="./image_processing_tools.html#opening"><strong>Opening</strong></a>, <a href="./image_processing_tools_filters.html#maximumfilter"><strong>MaximumFilter</strong></a>, <a href="./image_processing_tools_filters.html#minimumfilter"><strong>MinimumFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 'white' and 'black'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tophat_transform(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    variant=&quot;white&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TophatTransform -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/tophat.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="WriteFunctionMemoryInsertion"></a></p>
<a class="header" href="#writefunctionmemoryinsertion" id="writefunctionmemoryinsertion"><h1>WriteFunctionMemoryInsertion</h1></a>
<p>Jensen (2015) describes write function memory (WFM) insertion as a simple yet effective method of visualizing
land-cover change between two or three dates. WFM insertion may be used to qualitatively inspect change in any
type of registered, multi-date imagery. The technique operates by creating a red-green-blue (RGB) colour composite
image based on co-registered imagery from two or three dates. If two dates are input, the first date image will be
put into the red channel, while the second date image will be put into both the green and blue channels. The result
is an image where the areas of change are displayed as red (date 1 is brighter than date 2) and cyan (date 1 is
darker than date 2), and areas of little change are represented in grey-tones. The larger the change in pixel
brightness between dates, the more intense the resulting colour will be.</p>
<p>If images from three dates are input, the resulting composite can contain many distinct colours. Again, more
intense the colours are indicative of areas of greater land-cover change among the dates, while areas of little
change are represented in grey-tones. Interpreting the direction of change is more difficult when three dates are
used. Note that for multi-spectral imagery, only one band from each date can be used for creating a WFM insertion
image.</p>
<p><em>Reference</em>:</p>
<p>Jensen, J. R. (2015). Introductory Digital Image Processing: A Remote Sensing Perspective.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a>, <a href="./image_processing_tools.html#changevectoranalysis"><strong>ChangeVectorAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input raster file associated with the first date</td></tr>
<tr><td>--i2, --input2    </td><td> Input raster file associated with the second date</td></tr>
<tr><td>--i3, --input3    </td><td> Optional input raster file associated with the third date</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.write_function_memory_insertion(
    input1, 
    input2, 
    output, 
    input3=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=WriteFunctionMemoryInsertion -v ^
--wd=&quot;/path/to/data/&quot; -i1=input1.tif -i2=input2.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/write_func_memory_insertion.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/07/2017</p>
<a class="header" href="#image-processing-tools--filters" id="image-processing-tools--filters"><h1>Image Processing Tools → Filters</h1></a>
<ul>
<li><a href="#AdaptiveFilter">AdaptiveFilter</a></li>
<li><a href="#BilateralFilter">BilateralFilter</a></li>
<li><a href="#ConservativeSmoothingFilter">ConservativeSmoothingFilter</a></li>
<li><a href="#CornerDetection">CornerDetection</a></li>
<li><a href="#DiffOfGaussianFilter">DiffOfGaussianFilter</a></li>
<li><a href="#DiversityFilter">DiversityFilter</a></li>
<li><a href="#EdgePreservingMeanFilter">EdgePreservingMeanFilter</a></li>
<li><a href="#EmbossFilter">EmbossFilter</a></li>
<li><a href="#FastAlmostGaussianFilter">FastAlmostGaussianFilter</a></li>
<li><a href="#GaussianFilter">GaussianFilter</a></li>
<li><a href="#HighPassFilter">HighPassFilter</a></li>
<li><a href="#HighPassMedianFilter">HighPassMedianFilter</a></li>
<li><a href="#KNearestMeanFilter">KNearestMeanFilter</a></li>
<li><a href="#LaplacianFilter">LaplacianFilter</a></li>
<li><a href="#LaplacianOfGaussianFilter">LaplacianOfGaussianFilter</a></li>
<li><a href="#LeeFilter">LeeFilter</a></li>
<li><a href="#LineDetectionFilter">LineDetectionFilter</a></li>
<li><a href="#MajorityFilter">MajorityFilter</a></li>
<li><a href="#MaximumFilter">MaximumFilter</a></li>
<li><a href="#MeanFilter">MeanFilter</a></li>
<li><a href="#MedianFilter">MedianFilter</a></li>
<li><a href="#MinimumFilter">MinimumFilter</a></li>
<li><a href="#OlympicFilter">OlympicFilter</a></li>
<li><a href="#PercentileFilter">PercentileFilter</a></li>
<li><a href="#PrewittFilter">PrewittFilter</a></li>
<li><a href="#RangeFilter">RangeFilter</a></li>
<li><a href="#RobertsCrossFilter">RobertsCrossFilter</a></li>
<li><a href="#ScharrFilter">ScharrFilter</a></li>
<li><a href="#SobelFilter">SobelFilter</a></li>
<li><a href="#StandardDeviationFilter">StandardDeviationFilter</a></li>
<li><a href="#TotalFilter">TotalFilter</a></li>
<li><a href="#UnsharpMasking">UnsharpMasking</a></li>
<li><a href="#UserDefinedWeightsFilter">UserDefinedWeightsFilter</a></li>
</ul>
<p><a name="AdaptiveFilter"></a></p>
<a class="header" href="#adaptivefilter" id="adaptivefilter"><h1>AdaptiveFilter</h1></a>
<p>This tool performs a type of adaptive filter on a raster image. An adaptive filter can be used to reduce
the level of random noise (shot noise) in an image. The algorithm operates by calculating the average
value in a moving window centred on each grid cell. If the absolute difference between the window mean
value and the centre grid cell value is beyond a user-defined threshold (<code>--threshold</code>), the grid cell in the
output image is assigned the mean value, otherwise it is equivalent to the original value. Therefore, the
algorithm only modifies the image where grid cell values are substantially different than their neighbouring
values.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--threshold        </td><td> Difference from mean threshold, in standard deviations</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.adaptive_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    threshold=2.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AdaptiveFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --filter=25 --threshold = 2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/adaptive_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="BilateralFilter"></a></p>
<a class="header" href="#bilateralfilter" id="bilateralfilter"><h1>BilateralFilter</h1></a>
<p>This tool can be used to perform an edge-preserving smoothing filter, or bilateral filter, on an image. A bilateral
filter can be used to emphasize the longer-range variability in an image, effectively acting to smooth the image,
while reducing the edge blurring effect common with other types of smoothing filters. As such, this filter is very
useful for reducing the noise in an image. Bilateral filtering is a non-linear filtering technique introduced by
Tomasi and Manduchi (1998). The algorithm operates by convolving a kernel of weights with each grid cell and its
neighbours in an image. The bilateral filter is related to Gaussian smoothing, in that the weights of the convolution
kernel are partly determined by the 2-dimensional Gaussian (i.e. normal) curve, which gives stronger weighting to
cells nearer the kernel centre. Unlike the <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, however, the bilateral kernel weightings are also
affected by their similarity to the intensity value of the central pixel. Pixels that are very different in intensity
from the central pixel are weighted less, also based on a Gaussian weight distribution. Therefore, this non-linear
convolution filter is determined by the spatial and intensity domains of a localized pixel neighborhood.</p>
<p>The heavier weighting given to nearer and similar-valued pixels makes the bilateral filter an attractive alternative
for image smoothing and noise reduction compared to the much-used Mean filter. The size of the filter is determined
by setting the standard deviation distance parameter (<code>--sigma_dist</code>); the larger the standard deviation the larger
the resulting filter kernel. The standard deviation can be any number in the range 0.5-20 and is specified in the
unit of pixels. The standard deviation intensity parameter (<code>--sigma_int</code>), specified in the same units as the z-values,
determines the intensity domain contribution to kernel weightings.</p>
<p><em>References</em>:</p>
<p>Tomasi, C., &amp; Manduchi, R. (1998, January). Bilateral filtering for gray and color images. In null (p. 839). IEEE.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma_dist       </td><td> Standard deviation in distance in pixels</td></tr>
<tr><td>--sigma_int        </td><td> Standard deviation in intensity in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.bilateral_filter(
    i, 
    output, 
    sigma_dist=0.75, 
    sigma_int=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BilateralFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif ^
--sigma_dist=2.5 --sigma_int=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/bilateral_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="ConservativeSmoothingFilter"></a></p>
<a class="header" href="#conservativesmoothingfilter" id="conservativesmoothingfilter"><h1>ConservativeSmoothingFilter</h1></a>
<p>This tool performs a conservative smoothing filter on a raster image. A conservative smoothing filter can be used
to remove short-range variability in an image, effectively acting to smooth the image. It is particularly useful
for eliminating local spikes and reducing the noise in an image. The algorithm operates by calculating the
minimum and maximum neighbouring values surrounding a grid cell. If the cell at the centre of the kernel is
greater than the calculated maximum value, it is replaced with the maximum value in the output image. Similarly,
if the cell value at the kernel centre is less than the neighbouring minimum value, the corresponding grid cell
in the output image is replaced with the minimum value. This filter tends to alter an image very little compared
with other smoothing filters such as the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>,
<a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, or <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a>.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.conservative_smoothing_filter(
    i, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConservativeSmoothingFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/conservative_smoothing_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="CornerDetection"></a></p>
<a class="header" href="#cornerdetection" id="cornerdetection"><h1>CornerDetection</h1></a>
<p>This tool identifies corner patterns in boolean images using hit-and-miss pattern matching. Foreground pixels
in the input image (<code>--input</code>) are designated by any positive, non-zero values. Zero-valued and NoData-valued
grid cells are interpreted by the algorithm as background values.</p>
<p><em>Reference</em>:</p>
<p>Fisher, R, Brown, N, Cammas, N, Fitzgibbon, A, Horne, S, Koryllos, K, Murdoch, A, Robertson, J, Sharman, T, Strachan, C,</p>
<ol start="2004">
<li>Hypertext Image Processing Resource. online: http://homepages.inf.ed.ac.uk/rbf/HIPR2/hitmiss.htm</li>
</ol>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input boolean image</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.corner_detection(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CornerDetection -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/corner_detection.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Simon Gudim</p>
<p><em>Created</em>: 04/05/2017</p>
<p><a name="DiffOfGaussianFilter"></a></p>
<a class="header" href="#diffofgaussianfilter" id="diffofgaussianfilter"><h1>DiffOfGaussianFilter</h1></a>
<p>This tool can be used to perform a difference-of-Gaussians (DoG) filter on a raster image. In digital
image processing, DoG is a feature enhancement algorithm that involves the subtraction of one blurred
version of an image from another, less blurred version of the original. The blurred images are obtained
by applying filters with Gaussian-weighted kernels of differing standard deviations to the input image
(<code>--input</code>). Blurring an image using a Gaussian-weighted kernel suppresses high-frequency spatial
information and emphasizes lower-frequency variation. Subtracting one blurred image from the other
preserves spatial information that lies between the range of frequencies that are preserved in the
two blurred images. Thus, the difference-of-Gaussians is a band-pass filter that discards all but a
specified range of spatial frequencies that are present in the original image.</p>
<p>The algorithm operates by differencing the results of convolving two kernels of weights with each grid
cell and its neighbours in an image. The weights of the convolution kernels are determined by the 2-dimensional
Gaussian (i.e. normal) curve, which gives stronger weighting to cells nearer the kernel centre. The size of
the two convolution kernels are determined by setting the two standard deviation parameters (<code>--sigma1</code> and
<code>--sigma2</code>); the larger the standard deviation the larger the resulting filter kernel. The second standard
deviation should be a larger value than the first, however if this is not the case, the tool will automatically
swap the two parameters. Both standard deviations can range from 0.5-20.</p>
<p>The difference-of-Gaussians filter can be used to emphasize edges present in an image. Other edge-sharpening
filters also operate by enhancing high-frequency detail, but because random noise also has a high spatial
frequency, many of these sharpening filters tend to enhance noise, which can be an undesirable artifact.
The difference-of-Gaussians filter can remove high-frequency noise while emphasizing edges. This filter can,
however, reduce overall image contrast.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#laplacianfilter"><strong>LaplacianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma1           </td><td> Standard deviation distance in pixels</td></tr>
<tr><td>--sigma2           </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.diff_of_gaussian_filter(
    i, 
    output, 
    sigma1=2.0, 
    sigma2=4.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiffOfGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma1=2.0 ^
--sigma2=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/dog_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="DiversityFilter"></a></p>
<a class="header" href="#diversityfilter" id="diversityfilter"><h1>DiversityFilter</h1></a>
<p>This tool assigns each cell in the output grid the number of different values in a moving window centred on
each grid cell in the input raster. The input image should contain integer values but floating point data
are allowable and will be handled by multiplying pixel values by 1000 and rounding. Neighbourhood size, or
filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code> flags. These
dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9... If the kernel filter size is the same
in the x and y dimensions, the silent <code>--filter</code> flag may be used instead (command-line interface only).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#majorityfilter"><strong>MajorityFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.diversity_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiversityFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/diversity_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="EdgePreservingMeanFilter"></a></p>
<a class="header" href="#edgepreservingmeanfilter" id="edgepreservingmeanfilter"><h1>EdgePreservingMeanFilter</h1></a>
<p>This tool performs a type of edge-preserving mean filter operation on an input image (<code>--input</code>). The filter, a
type of low-pass filter, can be used to emphasize the longer-range variability in an image, effectively acting to
smooth the image and to reduce noise in the image. The algorithm calculates the average value in a moving window
centred on each grid cell, including in the averaging only the set of neighbouring values for which the absolute
value difference with the centre value is less than a specified threshold value (<code>--threshold</code>). It is, therefore,
similar to the <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, except all neighbours within the threshold difference are equally weighted and
neighbour distance is not accounted for. Filter kernels are always square, and filter size, is specified using
the <code>--filter</code> parameter. This dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9...</p>
<p>This tool works with both greyscale and red-green-blue (RGB) input images. RGB images are decomposed into
intensity-hue-saturation (IHS) and the filter is applied to the intensity channel. If an RGB image is input, the
threshold value must be in the range 0.0-1.0 (more likely less than 0.15), where a value of 1.0 would result in an ordinary mean filter
(<a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>). NoData values in the input image are ignored during filtering.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--threshold        </td><td> Maximum difference in values</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.edge_preserving_mean_filter(
    i, 
    output, 
    threshold, 
    filter=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgePreservingMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; --input=image.tif -o=output.tif ^
--filter=5 --threshold=20 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/edge_preserving_mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/03/2018</p>
<p><a name="EmbossFilter"></a></p>
<a class="header" href="#embossfilter" id="embossfilter"><h1>EmbossFilter</h1></a>
<p>This tool can be used to perform one of eight 3x3 emboss filters on a raster image. Like the <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a> and
<a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, the <a href="./image_processing_tools_filters.html#embossfilter"><strong>EmbossFilter</strong></a> is often applied in edge-detection applications. While these other two
common edge-detection filters approximate the slope magnitude of the local neighbourhood surrounding each
grid cell, the <a href="./image_processing_tools_filters.html#embossfilter"><strong>EmbossFilter</strong></a> can be used to estimate the directional slope. The kernel weights for each of
the eight available filters are as follows:</p>
<p>North (<code>n</code>)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  -1 </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Northeast (<code>ne</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>East (<code>e</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Southeast (<code>se</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>South (<code>s</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  -1 </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Southwest (<code>sw</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>West (<code>w</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Northwest (<code>nw</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>The user must specify the <code>--direction</code>, options include 'n', 's', 'e', 'w', 'ne', 'se', 'nw', 'sw'. The user may also optionally
clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a>, <a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--direction        </td><td> Direction of reflection; options include 'n', 's', 'e', 'w', 'ne', 'se', 'nw', 'sw'</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.emboss_filter(
    i, 
    output, 
    direction=&quot;n&quot;, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EmbossFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --direction='s' --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/emboss_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="FastAlmostGaussianFilter"></a></p>
<a class="header" href="#fastalmostgaussianfilter" id="fastalmostgaussianfilter"><h1>FastAlmostGaussianFilter</h1></a>
<p>The tool is somewhat modified from Dr. Kovesi's original Matlab code in that it
works with both greyscale and RGB images (decomposes to HSI and uses the intensity
data) and it handles the case of rasters that contain NoData values. This adds
complexity to the original 20 additions and 5 multiplications assertion of the
original paper.</p>
<p>Also note, for small values of sigma (&lt; 1.8), you should probably just use the
regular GaussianFilter tool.</p>
<p><em>Reference</em>:</p>
<p>P. Kovesi 2010 Fast Almost-Gaussian Filtering, Digital Image Computing:
Techniques and Applications (DICTA), 2010 International Conference on.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.fast_almost_gaussian_filter(
    i, 
    output, 
    sigma=1.8, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FastAlmostGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/fast_almost_gaussian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/05/2018</p>
<p><a name="GaussianFilter"></a></p>
<a class="header" href="#gaussianfilter" id="gaussianfilter"><h1>GaussianFilter</h1></a>
<p>This tool can be used to perform a Gaussian filter on a raster image. A Gaussian filter
can be used to emphasize the longer-range variability in an image, effectively acting to
smooth the image. This can be useful for reducing the noise in an image. The algorithm
operates by convolving a kernel of weights with each grid cell and its neighbours in an
image. The weights of the convolution kernel are determined by the 2-dimensional Gaussian
(i.e. normal) curve, which gives stronger weighting to cells nearer the kernel centre. It
is this characteristic that makes the Gaussian filter an attractive alternative for image
smoothing and noise reduction than the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>. The size of the filter is determined
by setting the standard deviation parameter (<code>--sigma</code>), which is in units of grid cells;
the larger the standard deviation the larger the resulting filter kernel. The standard
deviation can be any number in the range 0.5-20.</p>
<p><a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a> works with both greyscale and red-green-blue (RGB) images. RGB images are
decomposed into intensity-hue-saturation (IHS) and the filter is applied to the intensity
channel. NoData values in the input image are ignored during processing.</p>
<p>Like many low-pass filters, Gaussian filtering can signficantly blur well-defined edges in
the input image. The <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> and <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a> offer more robust
feature preservation during image smoothing. <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a> is relatively slow compared to
the <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a> tool, which offers a fast-running approximatation to a
Gaussian filter for larger kernel sizes.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.gaussian_filter(
    i, 
    output, 
    sigma=0.75, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=GaussianFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/gaussian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="HighPassFilter"></a></p>
<a class="header" href="#highpassfilter" id="highpassfilter"><h1>HighPassFilter</h1></a>
<p>This tool performs a high-pass filter on a raster image. High-pass filters can be used to emphasize
the short-range variability in an image. The algorithm operates essentially by subtracting the value at
the grid cell at the centre of the window from the average value in the surrounding neighbourhood (i.e. window.)</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#highpassmedianfilter"><strong>HighPassMedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.high_pass_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HighPassFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/highpass_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="HighPassMedianFilter"></a></p>
<a class="header" href="#highpassmedianfilter" id="highpassmedianfilter"><h1>HighPassMedianFilter</h1></a>
<p>This tool performs a high-pass median filter on a raster image. High-pass filters can be used to emphasize
the short-range variability in an image. The algorithm operates essentially by subtracting the value at
the grid cell at the centre of the window from the median value in the surrounding neighbourhood (i.e. window.)</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#highpassfilter"><strong>HighPassFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.high_pass_median_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HighPassMedianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/highpass_median_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/09/2018</p>
<p><a name="KNearestMeanFilter"></a></p>
<a class="header" href="#knearestmeanfilter" id="knearestmeanfilter"><h1>KNearestMeanFilter</h1></a>
<p>This tool performs a k-nearest mean filter on a raster image. A mean filter can be used to emphasize the
longer-range variability in an image, effectively acting to smooth or blur the image. This can be useful
for reducing the noise in an image. The algorithm operates by calculating the average of a specified
number (<em>k</em>) values in a moving window centred on each grid cell. The <em>k</em> values used in the average are
those cells in the window with the nearest intensity values to that of the centre cell. As such, this is
a type of edge-preserving smoothing filter. The <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a> and <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> are
examples of more sophisticated edge-preserving smoothing filters.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>NoData values in the input image are ignored during filtering.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>-k                  </td><td> k-value in pixels; this is the number of nearest-valued neighbours to use</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.k_nearest_mean_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    k=5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=KNearestMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=9 ^
-k=5
&gt;&gt;./whitebox_tools -r=KNearestMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filtery=7 ^
--filtery=9 -k=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/k_nearest_mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="LaplacianFilter"></a></p>
<a class="header" href="#laplacianfilter" id="laplacianfilter"><h1>LaplacianFilter</h1></a>
<p>This tool can be used to perform a Laplacian filter on a raster image. A Laplacian filter can be used
to emphasize the edges in an image. As such, this filter type is commonly used in edge-detection
applications. The algorithm operates by convolving a kernel of weights with each grid cell and its
neighbours in an image. Four 3x3 sized filters and one 5x5 filter are available for selection. The
weights of the kernels are as follows:</p>
<p>3x3(1)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  4  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>3x3(2)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  5  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>3x3(3)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  8  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>3x3(4)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center"> -2  </td><td align="center">  1 </td></tr>
<tr><td align="center"> -2 </td><td align="center">  4  </td><td align="center"> -2 </td></tr>
<tr><td align="center">  1 </td><td align="center"> -2  </td><td align="center">  1 </td></tr>
</tbody></table>
<p>5x5(1)</p>
<table><thead><tr><th align="center"> .  </th><th align="center">  . </th><th>  . </th><th> .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> 17 </td><td align="center"> -2 </td><td align="center"> -1 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
</tbody></table>
<p>5x5(2)</p>
<table><thead><tr><th> .  </th><th>  . </th><th>  . </th><th> .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> 16 </td><td align="center"> -2 </td><td align="center"> -1 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
</tbody></table>
<p>The user must specify the <code>--variant</code>, including '3x3(1)', '3x3(2)', '3x3(3)', '3x3(4)', '5x5(1)', and '5x5(2)'.
The user may also optionally clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 3x3(1), 3x3(2), 3x3(3), 3x3(4), 5x5(1), and 5x5(2) (default is 3x3(1))</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.laplacian_filter(
    i, 
    output, 
    variant=&quot;3x3(1)&quot;, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LaplacianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif ^
--variant='3x3(1)' --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/laplacian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="LaplacianOfGaussianFilter"></a></p>
<a class="header" href="#laplacianofgaussianfilter" id="laplacianofgaussianfilter"><h1>LaplacianOfGaussianFilter</h1></a>
<p>Performs a Laplacian-of-Gaussian (LoG) filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.laplacian_of_gaussian_filter(
    i, 
    output, 
    sigma=0.75, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LaplacianOfGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/log_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="LeeFilter"></a></p>
<a class="header" href="#leefilter" id="leefilter"><h1>LeeFilter</h1></a>
<p>Performs a Lee (Sigma) smoothing filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sigma            </td><td> Sigma value should be related to the standarad deviation of the distribution of image speckle noise</td></tr>
<tr><td>-m                  </td><td> M-threshold value the minimum allowable number of pixels within the intensity range</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lee_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sigma=10.0, 
    m=5.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LeeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=9 --sigma=10.0 ^
-m=5
&gt;&gt;./whitebox_tools -r=LeeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filtery=7 --filtery=9 ^
--sigma=10.0 -m=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/lee_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="LineDetectionFilter"></a></p>
<a class="header" href="#linedetectionfilter" id="linedetectionfilter"><h1>LineDetectionFilter</h1></a>
<p>This tool can be used to perform one of four 3x3 line-detection filters on a raster image. These
filters can be used to find one-cell-thick vertical, horizontal, or angled (135-degrees or
45-degrees) lines in an image. Notice that line-finding is a similar application to edge-detection.
Common edge-detection filters include the Sobel and Prewitt filters. The kernel weights for each of
the four line-detection filters are as follows:</p>
<p>'v' (Vertical)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'h' (Horizontal)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center">  2 </td><td align="center">  2  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'45' (Northeast-Southwest)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 2  </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'135' (Northwest-Southeast)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  2 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center">  2 </td></tr>
</tbody></table>
<p>The user must specify the <code>--variant</code>, including 'v', 'h', '45', and '135', for vertical, horizontal,
northeast-southwest, and northwest-southeast directions respectively. The user may also optionally clip
the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 'v' (vertical), 'h' (horizontal), '45', and '135' (default is 'v')</td></tr>
<tr><td>--absvals          </td><td> Optional flag indicating whether outputs should be absolute values</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.line_detection_filter(
    i, 
    output, 
    variant=&quot;vertical&quot;, 
    absvals=False, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LineDetectionFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --variant=h ^
--clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/line_detection_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MajorityFilter"></a></p>
<a class="header" href="#majorityfilter" id="majorityfilter"><h1>MajorityFilter</h1></a>
<p>This tool performs a majority (or modal) filter on a raster image. A mode filter assigns each
cell in the output grid the most commonly occurring value, i.e. mode, in a moving window centred
on each grid cell. Mode filters should only be applied to input images of a categorical data
scale. The input image should contain integer values but floating point data will be handled using a multiplier.
Because it requires binning the values in the window, a relatively computationally intensive
task, <a href="./image_processing_tools_filters.html#majorityfilter"><strong>MajorityFilter</strong></a> is considerably less efficient than other smoothing filters. This may pose a problem
for large images or large neighbourhoods. Like all WhiteboxTools' filters, however, this tool is
parallelized, benefitting from multi-core processors.</p>
<p>Neighbourhood size, or filter size, is determined by the user-defined x and y dimensions. These dimensions
should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>NoData values in the input image are ignored during filtering. When the neighbourhood around a grid cell extends
beyond the edge of the grid, NoData values are assigned to these sites.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.majority_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MajorityFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/majority_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="MaximumFilter"></a></p>
<a class="header" href="#maximumfilter" id="maximumfilter"><h1>MaximumFilter</h1></a>
<p>This tool assigns each cell in the output grid (<code>--output</code>) the maximum value in a moving window centred on each grid
cell in the input raster (<code>--input</code>). A maximum filter is the equivalent of the mathematical morphological
<a href="https://en.wikipedia.org/wiki/Mathematical_morphology#Dilation">dilation</a> operator.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code> flags.
These dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9... If the kernel filter size is the same in
the x and y dimensions, the silent <code>--filter</code> flag may be used instead (command-line interface only).</p>
<p>This tool takes advantage of the redundancy between overlapping, neighbouring filters to enhance computationally
efficiency. Like most of WhiteboxTools' filters, it is also parallelized for further efficiency.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#minimumfilter"><strong>MinimumFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.maximum_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaximumFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/max_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="MeanFilter"></a></p>
<a class="header" href="#meanfilter" id="meanfilter"><h1>MeanFilter</h1></a>
<p>This tool performs a mean filter operation on a raster image. A mean filter, a type of low-pass filter, can be
used to emphasize the longer-range variability in an image, effectively acting to smooth the image. This can be
useful for reducing the noise in an image. This tool utilizes an integral image approach (Crow, 1984) to ensure highly
efficient filtering that is invariant to filter size. The algorithm operates by calculating the average value
in a moving window centred on each grid cell.  Neighbourhood size, or filter size, is specified in the x and y
dimensions using the <code>--filterx</code> and <code>--filtery</code> flags. These dimensions should be odd, positive integer values,
e.g. 3, 5, 7, 9... If the kernel filter size is the same in the x and y dimensions, the silent <code>--filter</code> flag
may be used instead (command-line interface only).</p>
<p>Although commonly applied in digital image processing, mean filters are
generally considered to be quite harsh, with respect to their impact on the image, compared to other smoothing
filters such as the edge-preserving smoothing filters including the <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a>,
<a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> and even <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>.</p>
<p>This tool works with both greyscale and red-green-blue (RGB) images. RGB images are
decomposed into intensity-hue-saturation (IHS) and the filter is applied to the intensity
channel. NoData values in the input image are ignored during filtering. NoData values are assigned to all sites beyond
the raster.</p>
<p><em>Reference</em>:</p>
<p>Crow, F. C. (1984, January). Summed-area tables for texture mapping. In ACM SIGGRAPH computer graphics (Vol. 18, No.
3, pp. 207-212). ACM.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.mean_filter(
    i, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MeanFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filterx=25 --filtery=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="MedianFilter"></a></p>
<a class="header" href="#medianfilter" id="medianfilter"><h1>MedianFilter</h1></a>
<p>This tool performs a median filter on a raster image. Median filters, a type of low-pass filter, can be used to emphasize
the longer-range variability in an image, effectively acting to smooth the image. This can be useful for reducing the
noise in an image. The algorithm operates by calculating the median value (middle value in a sorted list) in a moving
window centred on each grid cell. Specifically, this tool uses the efficient running-median filtering algorithm of Huang
et al. (1979). The median value is not influenced by anomolously high or low values in the distribution to the extent
that the average is. As such, the median filter is far less sensitive to shot noise in an image than the mean filter.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>Reference</em>:</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.median_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MedianFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/median_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/07/2017</p>
<p><a name="MinimumFilter"></a></p>
<a class="header" href="#minimumfilter" id="minimumfilter"><h1>MinimumFilter</h1></a>
<p>This tool assigns each cell in the output grid (<code>--output</code>) the minimum value in a moving window centred on each grid
cell in the input raster (<code>--input</code>). A maximum filter is the equivalent of the mathematical morphological
<a href="https://en.wikipedia.org/wiki/Mathematical_morphology#Erosion">erosion</a> operator.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code> flags.
These dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9... If the kernel filter size is the same in
the x and y dimensions, the silent <code>--filter</code> flag may be used instead (command-line interface only).</p>
<p>This tool takes advantage of the redundancy between overlapping, neighbouring filters to enhance computationally
efficiency. Like most of WhiteboxTools' filters, it is also parallelized for further efficiency.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#maximumfilter"><strong>MaximumFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.minimum_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/min_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="OlympicFilter"></a></p>
<a class="header" href="#olympicfilter" id="olympicfilter"><h1>OlympicFilter</h1></a>
<p>This filter is a modification of the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, whereby the highest and lowest values in the kernel are
dropped, and the remaining values are averaged to replace the central pixel. The result is a low-pass smoothing
filter that is more robust than the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, which is more strongly impacted by the presence of outlier
values. It is named after a system of scoring Olympic events.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.olympic_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=OlympicFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/olympic_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="PercentileFilter"></a></p>
<a class="header" href="#percentilefilter" id="percentilefilter"><h1>PercentileFilter</h1></a>
<p>This tool calculates the percentile of the center cell in a moving filter window applied to an input image (`--input).
This indicates the value below which a given percentage of the neighbouring values in within the filter fall. For example,
the 35th percentile is the value below which 35% of the neighbouring values in the filter window may be found. As such,
the percentile of a pixel value is indicative of the relative location of the site within the statistical distribution
of values contained within a filter window. When applied to input digital elevation models, percentile is a measure of
local topographic position, or elevation residual.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code> flags.
These dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9... If the kernel filter size is the same in
the x and y dimensions, the silent <code>--filter</code> flag may be used instead (command-line interface only).</p>
<p>This tool takes advantage of the redundancy between overlapping, neighbouring filters to enhance computationally
efficiency, using a method similar to Huang et al. (1979). This efficient method of calculating percentiles requires
rounding of floating-point inputs, and therefore the user must specify the number of significant digits (<code>--sig_digits</code>)
to be used during the processing. Like most of WhiteboxTools' filters, this tool is also parallelized for further efficiency.</p>
<p><em>Reference</em>:</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percentile_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentileFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/percentile_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/06/2017</p>
<p><a name="PrewittFilter"></a></p>
<a class="header" href="#prewittfilter" id="prewittfilter"><h1>PrewittFilter</h1></a>
<p>This tool performs a 3 × 3 Prewitt edge-detection filter on a raster image. The Prewitt filter
is similar to the <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a>, in that it identifies areas of high slope in the input image through
the calculation of slopes in the x and y directions. The Prewitt edge-detection filter, however, gives less
weight to nearer cell values within the moving window, or kernel. For example, a Prewitt filter uses
the following schemes to calculate x and y slopes:</p>
<p>X-direction slope</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>Y-direction slope</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center">  1  </td><td align="center">  1 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0  </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>Each grid cell in the output image is assigned the square-root of the squared sum of the x and y slopes.</p>
<p>The user may optionally clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.prewitt_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PrewittFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/prewitt_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="RangeFilter"></a></p>
<a class="header" href="#rangefilter" id="rangefilter"><h1>RangeFilter</h1></a>
<p>Assigns each cell in the output grid the range of values in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.range_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RangeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/range_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="RobertsCrossFilter"></a></p>
<a class="header" href="#robertscrossfilter" id="robertscrossfilter"><h1>RobertsCrossFilter</h1></a>
<p>Performs a Robert's cross edge-detection filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.roberts_cross_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RobertsCrossFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/roberts_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="ScharrFilter"></a></p>
<a class="header" href="#scharrfilter" id="scharrfilter"><h1>ScharrFilter</h1></a>
<p>Performs a Scharr edge-detection filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.scharr_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ScharrFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/scharr_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="SobelFilter"></a></p>
<a class="header" href="#sobelfilter" id="sobelfilter"><h1>SobelFilter</h1></a>
<p>This tool performs a 3 × 3 or 5 × 5 Sobel edge-detection filter on a raster image. The Sobel filter
is similar to the <a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, in that it identifies areas of high slope in the input image through
the calculation of slopes in the x and y directions. The Sobel edge-detection filter, however, gives more
weight to nearer cell values within the moving window, or kernel. For example, a 3 × 3 Sobel filter uses
the following schemes to calculate x and y slopes:</p>
<p>X-direction slope</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -2 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>Y-direction slope</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center">  2  </td><td align="center">  1 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0  </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>Each grid cell in the output image is assigned the square-root of the squared sum of the x and y slopes.</p>
<p>The user must specify the <code>--variant</code>, including '3x3' and '5x5' variants. The user may also optionally
clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 3x3 and 5x5 (default is 3x3)</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent (default is 0.0)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sobel_filter(
    i, 
    output, 
    variant=&quot;3x3&quot;, 
    clip=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SobelFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --variant=5x5 --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/sobel_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="StandardDeviationFilter"></a></p>
<a class="header" href="#standarddeviationfilter" id="standarddeviationfilter"><h1>StandardDeviationFilter</h1></a>
<p>Assigns each cell in the output grid the standard deviation of values in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.standard_deviation_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/stdev_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="TotalFilter"></a></p>
<a class="header" href="#totalfilter" id="totalfilter"><h1>TotalFilter</h1></a>
<p>This tool performs a total filter on an input image. A total filter assigns to each cell in the output grid
the total (sum) of all values in a moving window centred on each grid cell.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#rangefilter"><strong>RangeFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.total_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TotalFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/total_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="UnsharpMasking"></a></p>
<a class="header" href="#unsharpmasking" id="unsharpmasking"><h1>UnsharpMasking</h1></a>
<p>An image sharpening technique that enhances edges.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
<tr><td>--amount           </td><td> A percentage and controls the magnitude of each overshoot</td></tr>
<tr><td>--threshold        </td><td> Controls the minimal brightness change that will be sharpened</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.unsharp_masking(
    i, 
    output, 
    sigma=0.75, 
    amount=100.0, 
    threshold=0.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=UnsharpMasking -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --sigma=2.0 --amount=50.0 ^
--threshold=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/unsharp_masking.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/05/2018</p>
<p><a name="UserDefinedWeightsFilter"></a></p>
<a class="header" href="#userdefinedweightsfilter" id="userdefinedweightsfilter"><h1>UserDefinedWeightsFilter</h1></a>
<p>NoData values in the input image are ignored during the convolution operation.
This can lead to unexpected behavior at the edges of images (since the default behavior
is to return NoData when addressing cells beyond the grid edge) and where the grid
contains interior areas of NoData values. Normalization of kernel weights can be useful
for handling the edge effects associated with interior areas of NoData values. When the
normalization option is selected, the sum of the cell value-weight product is divided
by the sum of the weights on a cell-by-cell basis. Therefore, if the kernel at a
particular grid cell contains neighboring cells of NoData values, normalization
effectively re-adjusts the weighting to account for the missing data values. Normalization
also ensures that the output image will possess values within the range of the input
image and allows the user to specify integer value weights in the kernel. However, note
that this implies that the sum of weights should equal one. In some cases, alternative
sums (e.g. zero) are more appropriate, and as such normalization should not be applied
in these cases.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--weights          </td><td> Input weights file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--center           </td><td> Kernel center cell; options include 'center', 'upper-left', 'upper-right', 'lower-left', 'lower-right'</td></tr>
<tr><td>--normalize        </td><td> Normalize kernel weights? This can reduce edge effects and lessen the impact of data gaps (nodata) but is not suited when the kernel weights sum to zero</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.user_defined_weights_filter(
    i, 
    weights, 
    output, 
    center=&quot;center&quot;, 
    normalize=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=UserDefinedWeightsFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif --weights=weights.txt ^
-o=output.tif --center=center --normalize 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/user_defined_weights_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/04/2018</p>
<a class="header" href="#image-processing-tools--image-enhancement" id="image-processing-tools--image-enhancement"><h1>Image Processing Tools → Image Enhancement</h1></a>
<ul>
<li><a href="#BalanceContrastEnhancement">BalanceContrastEnhancement</a></li>
<li><a href="#CorrectVignetting">CorrectVignetting</a></li>
<li><a href="#DirectDecorrelationStretch">DirectDecorrelationStretch</a></li>
<li><a href="#GammaCorrection">GammaCorrection</a></li>
<li><a href="#GaussianContrastStretch">GaussianContrastStretch</a></li>
<li><a href="#HistogramEqualization">HistogramEqualization</a></li>
<li><a href="#HistogramMatching">HistogramMatching</a></li>
<li><a href="#HistogramMatchingTwoImages">HistogramMatchingTwoImages</a></li>
<li><a href="#MinMaxContrastStretch">MinMaxContrastStretch</a></li>
<li><a href="#PanchromaticSharpening">PanchromaticSharpening</a></li>
<li><a href="#PercentageContrastStretch">PercentageContrastStretch</a></li>
<li><a href="#SigmoidalContrastStretch">SigmoidalContrastStretch</a></li>
<li><a href="#StandardDeviationContrastStretch">StandardDeviationContrastStretch</a></li>
</ul>
<p><a name="BalanceContrastEnhancement"></a></p>
<a class="header" href="#balancecontrastenhancement" id="balancecontrastenhancement"><h1>BalanceContrastEnhancement</h1></a>
<p>This tool can be used to reduce colour bias in a colour composite image based on the
technique described by Liu (1991). Colour bias is a common phenomena with colour images
derived from multispectral imagery, whereby a higher average brightness value in one
band results in over-representation of that band in the colour composite. The tool
essentially applies a parabolic stretch to each of the three bands in a user specified
RGB colour composite, forcing the histograms of each band to have the same minimum,
maximum, and average values while maintaining their overall histogram shape. For greater
detail on the operation of the tool, please see Liu (1991). Aside from the names of the
input and output colour composite images, the user must also set the value of E, the
desired output band mean, where 20 &lt; E &lt; 235.</p>
<p><em>Reference</em>:</p>
<p>Liu, J.G. (1991) Balance contrast enhancement technique and its application in image
colour composition. <em>International Journal of Remote Sensing</em>, 12:10.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#directdecorrelationstretch"><strong>DirectDecorrelationStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input colour composite image file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--band_mean        </td><td> Band mean value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.balance_contrast_enhancement(
    i, 
    output, 
    band_mean=100.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BalanceContrastEnhancement -v ^
--wd=&quot;/path/to/data/&quot; --input=image.tif -o=output.tif ^
--band_mean=120 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/balance_contrast_enhancement.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/07/2017</p>
<p><a name="CorrectVignetting"></a></p>
<a class="header" href="#correctvignetting" id="correctvignetting"><h1>CorrectVignetting</h1></a>
<p>This tool can be used to reduce vignetting within an image. Vignetting refers to the
reducuction of image brightness away from the image centre (i.e. the principal point).
Vignetting is a radiometric distortion resulting from lens characteristics. The
algorithm calculates the brightness value in the output image (BVout) as:</p>
<p>BVout = BVin / [cos^n(arctan(d / f))]</p>
<p>Where d is the photo-distance from the principal point in millimetres, f is the focal
length of the camera, in millimeters, and n is a user-specified parameter. Pixel
distances are converted to photo-distances (in millimetres) using the specified
image width, i.e. distance between left and right edges (mm). For many cameras, 4.0
is an appropriate value of the n parameter. A second pass of the image is used to
rescale the output image so that it possesses the same minimum and maximum values as
the input image.</p>
<p>If an RGB image is input, the analysis will be performed on the intensity component
of the HSI transform.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--pp               </td><td> Input principal point file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--focal_length     </td><td> Camera focal length, in millimeters</td></tr>
<tr><td>--image_width      </td><td> Distance between photograph edges, in millimeters</td></tr>
<tr><td>-n                  </td><td> The 'n' parameter</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.correct_vignetting(
    i, 
    pp, 
    output, 
    focal_length=304.8, 
    image_width=228.6, 
    n=4.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CorrectVignetting -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif --pp=princ_pt.shp ^
-o=output.tif --focal_length=304.8 --image_width=228.6 ^
-n=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/correct_vignetting.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/04/2018</p>
<p><a name="DirectDecorrelationStretch"></a></p>
<a class="header" href="#directdecorrelationstretch" id="directdecorrelationstretch"><h1>DirectDecorrelationStretch</h1></a>
<p>The Direct Decorrelation Stretch (DDS) is a simple type of saturation stretch. The stretch is
applied to a colour composite image and is used to improve the saturation, or colourfulness,
of the image. The DDS operates by reducing the achromatic (grey) component of a pixel's colour
by a scale factor (<em>k</em>), such that the red (r), green (g), and blue (b) components of the output
colour are defined as:</p>
<p>r<sub><em>k</em></sub> = r - <em>k</em> min(r, g, b)</p>
<p>g<sub><em>k</em></sub> = g - <em>k</em> min(r, g, b)</p>
<p>b<sub><em>k</em></sub> = b - <em>k</em> min(r, g, b)</p>
<p>The achromatic factor (<em>k</em>) can range between 0 (no effect) and 1 (full saturation stretch),
although typical values range from 0.3 to 0.7. A linear stretch is used afterwards to adjust
overall image brightness. Liu and Moore (1996) recommend applying a colour balance stretch,
such as <a href="./image_processing_tools_image_enhancement.html#balancecontrastenhancement"><strong>BalanceContrastEnhancement</strong></a> before using the DDS.</p>
<p><em>Reference</em>:</p>
<p>Liu, J.G., and Moore, J. (1996) Direct decorrelation stretch technique for RGB colour composition.
International Journal of Remote Sensing, 17:5, 1005-1018.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a>, <a href="./image_processing_tools_image_enhancement.html#balancecontrastenhancement"><strong>BalanceContrastEnhancement</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input colour composite image file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>-k                  </td><td> Achromatic factor (k) ranges between 0 (no effect) and 1 (full saturation stretch), although typical values range from 0.3 to 0.7</td></tr>
<tr><td>--clip             </td><td> Optional percent to clip the upper tail by during the stretch</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.direct_decorrelation_stretch(
    i, 
    output, 
    k=0.5, 
    clip=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DirectDecorrelationStretch -v ^
--wd=&quot;/path/to/data/&quot; --input=image.tif -o=output.tif -k=0.4 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/direct_decorrelation_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/07/2017</p>
<p><a name="GammaCorrection"></a></p>
<a class="header" href="#gammacorrection" id="gammacorrection"><h1>GammaCorrection</h1></a>
<p>This tool performs a gamma colour correction transform on an input image (<code>--input</code>), such that each
input pixel value (z<sub>in</sub><sup>) is mapped to the corresponding output value (z<sub>out</sub>) as:</p>
<blockquote>
<p>z<sub>out</sub> = z<sub>in</sub><sup><code>gamma</code></sup></p>
</blockquote>
<p>The user must specify the value of the <code>gamma</code> parameter. The input image may be of either a greyscale or RGB colour
composite data type.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--gamma            </td><td> Gamma value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.gamma_correction(
    i, 
    output, 
    gamma=0.5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=GammaCorrection -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --gamma=0.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/gamma_correction.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="GaussianContrastStretch"></a></p>
<a class="header" href="#gaussiancontraststretch" id="gaussiancontraststretch"><h1>GaussianContrastStretch</h1></a>
<p>This tool performs a Gaussian stretch on a raster image. The observed histogram of the input image is fitted
to a Gaussian histogram, i.e. normal distribution. A histogram matching technique is used to map the values from
the input image onto the output Gaussian distribution. The user must the number of tones (<code>--num_tones</code>) used in the
output image.</p>
<p>This tool is related to the more general <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a> tool, which can be used to fit any frequency distribution
to an input image, and other contrast enchancement tools such as <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#minmaxcontraststretch"><strong>MinMaxContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#percentagecontraststretch"><strong>PercentageContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#sigmoidalcontraststretch"><strong>SigmoidalContrastStretch</strong></a>, and <a href="./image_processing_tools_image_enhancement.html#standarddeviationcontraststretch"><strong>StandardDeviationContrastStretch</strong></a>.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#minmaxcontraststretch"><strong>MinMaxContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#percentagecontraststretch"><strong>PercentageContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#sigmoidalcontraststretch"><strong>SigmoidalContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#standarddeviationcontraststretch"><strong>StandardDeviationContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.gaussian_contrast_stretch(
    i, 
    output, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=GaussianContrastStretch -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/gaussian_contrast_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/05/2018</p>
<p><a name="HistogramEqualization"></a></p>
<a class="header" href="#histogramequalization" id="histogramequalization"><h1>HistogramEqualization</h1></a>
<p>This tool alters the cumulative distribution function (CDF) of a raster image to match,
as closely as possible, the CDF of a uniform distribution. Histogram equalization works
by first calculating the histogram of the input image. This input histogram is then
converted into a CDF. Each grid cell value in the input image is then mapped to the
corresponding value in the uniform distribution's CDF that has an equivalent (or as close
as possible) cumulative probability value. Histogram equalization provides a very effective
means of performing image contrast adjustment in an efficient manner with little need for
human input.</p>
<p>The user must specify the name of the input image to perform histogram equalization on.
The user must also specify the number of tones, corresponding to the number
of histogram bins used in the analysis.</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a> is related to the <a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a> tool (used when an image's
CDF is to be matched to a reference CDF derived from a reference image). Similarly, <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a>,
and <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a> are similarly related tools frequently used for image contrast
adjustment, where the reference CDFs are uniform and Gaussian (normal) respectively.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>The algorithm can introduces gaps in the histograms (steps in the CDF). This is to be expected because
the histogram is being distorted. This is more prevalent for integer-level images.</li>
<li>Histogram equalization is not appropriate for images containing categorical (class) data.</li>
</ul>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a>, <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.histogram_equalization(
    i, 
    output, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HistogramEqualization -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/histogram_equalization.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/08/2017</p>
<p><a name="HistogramMatching"></a></p>
<a class="header" href="#histogrammatching" id="histogrammatching"><h1>HistogramMatching</h1></a>
<p>This tool alters the cumulative distribution function (CDF) of a raster image to match,
as closely as possible, the CDF of a reference histogram. Histogram matching works by
first calculating the histogram of the input image. This input histogram and reference
histograms are each then converted into CDFs. Each grid cell value in the input image
is then mapped to the corresponding value in the reference CDF that has an equivalent
(or as close as possible) cumulative probability value. Histogram matching provides
the most flexible means of performing image contrast adjustment.</p>
<p>The reference histogram must be specified to the tool in the form of a text file (.txt),
provided using the <code>--histo_file</code> flag. This file must contain two columns (delimited by
a tab, space, comma, colon, or semicolon) where the first column contains the x value
(i.e. the values that will be assigned to the grid cells in the output image) and the second
column contains the frequency or probability. Note that 1) the file must not contain a
header row, 2) each x value/frequency pair must be on a separate row, and 3) the
frequency/probability must not be cumulative (i.e. the file must contain the histogram and
not the CDF). The CDF will be computed for the reference histogram automatically by the tool.
It is possible to create this type of histogram using the wide range of distribution tools
available in most spreadsheet programs (e.g. Excel or LibreOffice's Calc program). You must
save the file as a text-only (ASCII) file.</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a> is related to the <a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a> tool, which can be used
when a reference CDF can be derived from a reference image. <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a> and
<a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a> are similarly related tools frequently used for image contrast
adjustment, where the reference CDFs are uniform and Gaussian (normal) respectively.</p>
<p><strong>Notes:</strong></p>
<ul>
<li>The algorithm can introduces gaps in the histograms (steps in the CDF). This is to be expected
because the histogram is being distorted. This is more prevalent for integer-level images.</li>
<li>Histogram matching is not appropriate for images containing categorical (class) data.</li>
<li>This tool is not intended for images containing RGB data. If this is the case, the colour
channels should be split using the <a href="./image_processing_tools.html#splitcolourcomposite"><strong>SplitColourComposite</strong></a> tool.</li>
</ul>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools.html#splitcolourcomposite"><strong>SplitColourComposite</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--histo_file       </td><td> Input reference probability distribution function (pdf) text file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.histogram_matching(
    i, 
    histo_file, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HistogramMatching -v ^
--wd=&quot;/path/to/data/&quot; -i=input1.tif --histo_file=histo.txt ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/histogram_matching.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/09/2017</p>
<p><a name="HistogramMatchingTwoImages"></a></p>
<a class="header" href="#histogrammatchingtwoimages" id="histogrammatchingtwoimages"><h1>HistogramMatchingTwoImages</h1></a>
<p>This tool alters the cumulative distribution function (CDF) of a raster image to match, as closely
as possible, the CDF of a reference image. Histogram matching works by first calculating the
histograms of the input image (i.e. the image to be adjusted) and the reference image. These
histograms are then converted into CDFs. Each grid cell value in the input image is then mapped
to the corresponding value in the reference CDF that has the an equivalent (or as close as
possible) cumulative probability value. A common application of this is to match the images from
two sensors with slightly different responses, or images from the same sensor, but the sensor's
response is known to change over time.The size of the two images (rows and columns) do not need
to be the same, nor do they need to be geographically overlapping.</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogrammatchingtwoimages"><strong>HistogramMatchingTwoImages</strong></a> is related to the <a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a> tool, which can be used
when a reference CDF is used directly rather than deriving it from a reference image.
<a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a> and <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a> are similarly related tools, where the
reference CDFs are uniform and Gaussian (normal) respectively.</p>
<p>The algorithm may introduces gaps in the histograms (steps in the CDF). This is to be expected
because the histograms are being distorted. This is more prevalent for integer-level images.
Histogram matching is not appropriate for images containing categorical (class) data. It is also
not intended for images containing RGB data, in which case, the colour channels should be split
using the <a href="./image_processing_tools.html#splitcolourcomposite"><strong>SplitColourComposite</strong></a> tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#histogrammatching"><strong>HistogramMatching</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools.html#splitcolourcomposite"><strong>SplitColourComposite</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input raster file to modify</td></tr>
<tr><td>--i2, --input2    </td><td> Input reference raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.histogram_matching_two_images(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HistogramMatchingTwoImages -v ^
--wd=&quot;/path/to/data/&quot; --i1=input1.tif --i2=input2.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/histogram_matching_two_images.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/08/2017</p>
<p><a name="MinMaxContrastStretch"></a></p>
<a class="header" href="#minmaxcontraststretch" id="minmaxcontraststretch"><h1>MinMaxContrastStretch</h1></a>
<p>This tool performs a minimum-maximum contrast stretch on a raster image. This operation maps each grid cell
value in the input raster image (z) onto a new scale that ranges from the user-specified lower-tail clip
value (<code>min_val</code>) to the upper-tail clip value (<code>max_val</code>), with the specified number of tonal values
(<code>num_tones</code>), such that:</p>
<blockquote>
<p>z<sub>out</sub> = ((z<sub>in</sub> – min_val)/(max_val – min_val)) x num_tones</p>
</blockquote>
<p>where z<sub>out</sub> is the output value. Notice that any values in the input image that are less than
<code>min_val</code> are assigned a value of <code>min_val</code> in the output image. Similarly, any input values greater than
<code>max_val</code> are assigned a value of <code>max_val</code> in the output image.</p>
<p>This is a type of linear contrast stretch with saturation at the tails of the frequency distribution. This is
the same kind of stretch that is used to display raster type data on the fly in many GIS software packages,
such that the lower and upper tail values are set using the minimum and maximum display values and the number
of tonal values is determined by the number of palette entries.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#percentagecontraststretch"><strong>PercentageContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#sigmoidalcontraststretch"><strong>SigmoidalContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#standarddeviationcontraststretch"><strong>StandardDeviationContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--min_val          </td><td> Lower tail clip value</td></tr>
<tr><td>--max_val          </td><td> Upper tail clip value</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min_max_contrast_stretch(
    i, 
    output, 
    min_val, 
    max_val, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinMaxContrastStretch -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--min_val=45.0 --max_val=200.0 --num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/min_max_contrast_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="PanchromaticSharpening"></a></p>
<a class="header" href="#panchromaticsharpening" id="panchromaticsharpening"><h1>PanchromaticSharpening</h1></a>
<p>Panchromatic sharpening, or simply pan-sharpening, refers to a range of techniques that can be used to merge
finer spatial resolution panchromatic images with coarser spatial resolution multi-spectral images. The
multi-spectral data provides colour information while the panchromatic image provides improved spatial information.
This procedure is sometimes called image fusion. Jensen (2015) describes panchromatic sharpening in detail.</p>
<p>Whitebox provides two common methods for panchromatic sharpening including the Brovey transformation and the
Intensity-Hue-Saturation (IHS) methods. Both of these techniques provide the best results when the range of
wavelengths detected by the panchromatic image overlap significantly with the wavelength range covered by the
three multi-spectral bands that are used. When this is not the case, the resulting colour composite will likely
have colour properties that are dissimilar to the colour composite generated by the original multispectral images.
For Landsat ETM+ data, the panchromatic band is sensitive to EMR in the range of 0.52-0.90 micrometres. This
corresponds closely to the green (band 2), red (band 3), and near-infrared (band 4).</p>
<p><em>Reference</em>:</p>
<p>Jensen, J. R. (2015). Introductory Digital Image Processing: A Remote Sensing Perspective.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#createcolourcomposite"><strong>CreateColourComposite</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--red              </td><td> Input red band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--green            </td><td> Input green band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--blue             </td><td> Input blue band image file. Optionally specified if colour-composite not specified</td></tr>
<tr><td>--composite        </td><td> Input colour-composite image file. Only used if individual bands are not specified</td></tr>
<tr><td>--pan              </td><td> Input panchromatic band file</td></tr>
<tr><td>-o, --output       </td><td> Output colour composite file</td></tr>
<tr><td>--method           </td><td> Options include 'brovey' (default) and 'ihs'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.panchromatic_sharpening(
    pan, 
    output, 
    red=None, 
    green=None, 
    blue=None, 
    composite=None, 
    method=&quot;brovey&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PanchromaticSharpening -v ^
--wd=&quot;/path/to/data/&quot; --red=red.tif --green=green.tif ^
--blue=blue.tif --pan=pan.tif --output=pan_sharp.tif ^
--method='brovey'
&gt;&gt;./whitebox_tools -r=PanchromaticSharpening ^
-v --wd=&quot;/path/to/data/&quot; --composite=image.tif --pan=pan.tif ^
--output=pan_sharp.tif --method='ihs' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/pan_sharpening.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/07/2017</p>
<p><a name="PercentageContrastStretch"></a></p>
<a class="header" href="#percentagecontraststretch" id="percentagecontraststretch"><h1>PercentageContrastStretch</h1></a>
<p>This tool performs a percentage contrast stretch on a raster image. This operation maps each grid cell value
in the input raster image (z<sub>in</sub>) onto a new scale that ranges from a lower-tail clip value (<code>min_val</code>)
to the upper-tail clip value (<code>max_val</code>), with the user-specified number of tonal values (<code>num_tones</code>), such that:</p>
<blockquote>
<p>z<sub>out</sub> = ((z<sub>in</sub> – min_val)/(max_val – min_val)) x num_tones</p>
</blockquote>
<p>where z<sub>out</sub> is the output value. The values of <code>min_val</code> and <code>max_val</code> are determined from the frequency
distribution and the user-specified tail clip value (<code>--clip</code>). For example, if a value of 1% is specified, the tool
will determine the values in the input image for which 1% of the grid cells have a lower value <code>min_val</code> and 1% of
the grid cells have a higher value <code>max_val</code>. The user must also specify which tails (upper, lower, or both) to clip
(<code>--tail</code>).</p>
<p>This is a type of linear contrast stretch with saturation at the tails of the frequency distribution. This is
the same kind of stretch that is used to display raster type data on the fly in many GIS software packages,
such that the lower and upper tail values are set using the minimum and maximum display values and the number
of tonal values is determined by the number of palette entries.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#minmaxcontraststretch"><strong>MinMaxContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#sigmoidalcontraststretch"><strong>SigmoidalContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#standarddeviationcontraststretch"><strong>StandardDeviationContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
<tr><td>--tail             </td><td> Specified which tails to clip; options include 'upper', 'lower', and 'both' (default is 'both')</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.percentage_contrast_stretch(
    i, 
    output, 
    clip=1.0, 
    tail=&quot;both&quot;, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentageContrastStretch -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --clip=2.0 ^
--tail='both' --num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/percentage_contrast_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="SigmoidalContrastStretch"></a></p>
<a class="header" href="#sigmoidalcontraststretch" id="sigmoidalcontraststretch"><h1>SigmoidalContrastStretch</h1></a>
<p>This tool performs a sigmoidal stretch on a raster image. This is a transformation where the input image value for a
grid cell (z<sub>in</sub>) is transformed to an output value zout such that:</p>
<blockquote>
<p>z<sub>out</sub> = (1.0 / (1.0 + exp(<em>gain</em>(<em>cutoff</em> - z))) - <em>a</em> ) / <em>b</em> x <em>num_tones</em></p>
</blockquote>
<p>where,</p>
<blockquote>
<p>z = (z<sub>in</sub> - <em>MIN</em>) / <em>RANGE</em>,</p>
</blockquote>
<blockquote>
<p><em>a</em> = 1.0 / (1.0 + exp(<em>gain</em> x <em>cutoff</em>)),</p>
</blockquote>
<blockquote>
<p><em>b</em> = 1.0 / (1.0 + exp(<em>gain</em> x (<em>cutoff</em> - 1.0))) - 1.0 / (1.0 + exp(<em>gain</em> x <em>cutoff</em>)),</p>
</blockquote>
<p><em>MIN</em> and <em>RANGE</em> are the minimum value and data range in the input image respectively and <em>gain</em> and <em>cutoff</em> are
user specified parameters (<code>--gain</code>, <code>--cutoff</code>).</p>
<p>Like all of <em>WhiteboxTools</em>'s contrast enhancement tools, this operation will work on either greyscale or RGB input
images.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#minmaxcontraststretch"><strong>MinMaxContrastStretch</strong></a>,  <a href="./image_processing_tools_image_enhancement.html#percentagecontraststretch"><strong>PercentageContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#standarddeviationcontraststretch"><strong>StandardDeviationContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--cutoff           </td><td> Cutoff value between 0.0 and 0.95</td></tr>
<tr><td>--gain             </td><td> Gain value</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sigmoidal_contrast_stretch(
    i, 
    output, 
    cutoff=0.0, 
    gain=1.0, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SigmoidalContrastStretch -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --cutoff=0.1 ^
--gain=2.0 --num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/sigmoidal_contrast_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="StandardDeviationContrastStretch"></a></p>
<a class="header" href="#standarddeviationcontraststretch" id="standarddeviationcontraststretch"><h1>StandardDeviationContrastStretch</h1></a>
<p>This tool performs a standard deviation contrast stretch on a raster image. This operation maps each grid cell value
in the input raster image (z<sub>in</sub>) onto a new scale that ranges from a lower-tail clip value (<code>min_val</code>)
to the upper-tail clip value (<code>max_val</code>), with the user-specified number of tonal values (<code>num_tones</code>), such that:</p>
<blockquote>
<p>z<sub>out</sub> = ((z<sub>in</sub> – min_val)/(max_val – min_val)) x num_tones</p>
</blockquote>
<p>where z<sub>out</sub> is the output value. The values of <code>min_val</code> and <code>max_val</code> are determined based on the image
mean and standard deviation. Specifically, the user must specify the number of standard deviations (<code>--clip</code> or
<code>--stdev</code>) to be used in determining the min and max clip values. The tool will then calculate the input image mean
and standard deviation and estimate the clip values from these statistics.</p>
<p>This is the same kind of stretch that is used to display raster type data on the fly in many GIS software packages.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_image_enhancement.html#gaussiancontraststretch"><strong>GaussianContrastStretch</strong></a>, <a href="./image_processing_tools_image_enhancement.html#histogramequalization"><strong>HistogramEqualization</strong></a>, <a href="./image_processing_tools_image_enhancement.html#minmaxcontraststretch"><strong>MinMaxContrastStretch</strong></a>,  <a href="./image_processing_tools_image_enhancement.html#percentagecontraststretch"><strong>PercentageContrastStretch</strong></a>,
<a href="./image_processing_tools_image_enhancement.html#sigmoidalcontraststretch"><strong>SigmoidalContrastStretch</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip, --stdev   </td><td> Standard deviation clip value</td></tr>
<tr><td>--num_tones        </td><td> Number of tones in the output image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.standard_deviation_contrast_stretch(
    i, 
    output, 
    stdev=2.0, 
    num_tones=256, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationContrastStretch -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --stdev=2.0 ^
--num_tones=1024 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/stdev_contrast_stretch.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<a class="header" href="#lidar-tools" id="lidar-tools"><h1>LiDAR Tools</h1></a>
<ul>
<li><a href="#ClassifyOverlapPoints">ClassifyOverlapPoints</a></li>
<li><a href="#ClipLidarToPolygon">ClipLidarToPolygon</a></li>
<li><a href="#ErasePolygonFromLidar">ErasePolygonFromLidar</a></li>
<li><a href="#FilterLidarClasses">FilterLidarClasses</a></li>
<li><a href="#FilterLidarScanAngles">FilterLidarScanAngles</a></li>
<li><a href="#FindFlightlineEdgePoints">FindFlightlineEdgePoints</a></li>
<li><a href="#FlightlineOverlap">FlightlineOverlap</a></li>
<li><a href="#LasToAscii">LasToAscii</a></li>
<li><a href="#LasToMultipointShapefile">LasToMultipointShapefile</a></li>
<li><a href="#LasToShapefile">LasToShapefile</a></li>
<li><a href="#LidarBlockMaximum">LidarBlockMaximum</a></li>
<li><a href="#LidarBlockMinimum">LidarBlockMinimum</a></li>
<li><a href="#LidarClassifySubset">LidarClassifySubset</a></li>
<li><a href="#LidarColourize">LidarColourize</a></li>
<li><a href="#LidarConstructVectorTin">LidarConstructVectorTin</a></li>
<li><a href="#LidarElevationSlice">LidarElevationSlice</a></li>
<li><a href="#LidarGroundPointFilter">LidarGroundPointFilter</a></li>
<li><a href="#LidarHexBinning">LidarHexBinning</a></li>
<li><a href="#LidarHillshade">LidarHillshade</a></li>
<li><a href="#LidarHistogram">LidarHistogram</a></li>
<li><a href="#LidarIdwInterpolation">LidarIdwInterpolation</a></li>
<li><a href="#LidarInfo">LidarInfo</a></li>
<li><a href="#LidarJoin">LidarJoin</a></li>
<li><a href="#LidarKappaIndex">LidarKappaIndex</a></li>
<li><a href="#LidarNearestNeighbourGridding">LidarNearestNeighbourGridding</a></li>
<li><a href="#LidarPointDensity">LidarPointDensity</a></li>
<li><a href="#LidarPointStats">LidarPointStats</a></li>
<li><a href="#LidarRansacPlanes">LidarRansacPlanes</a></li>
<li><a href="#LidarRemoveDuplicates">LidarRemoveDuplicates</a></li>
<li><a href="#LidarRemoveOutliers">LidarRemoveOutliers</a></li>
<li><a href="#LidarSegmentation">LidarSegmentation</a></li>
<li><a href="#LidarSegmentationBasedFilter">LidarSegmentationBasedFilter</a></li>
<li><a href="#LidarThin">LidarThin</a></li>
<li><a href="#LidarThinHighDensity">LidarThinHighDensity</a></li>
<li><a href="#LidarTile">LidarTile</a></li>
<li><a href="#LidarTileFootprint">LidarTileFootprint</a></li>
<li><a href="#LidarTinGridding">LidarTinGridding</a></li>
<li><a href="#LidarTophatTransform">LidarTophatTransform</a></li>
<li><a href="#NormalVectors">NormalVectors</a></li>
<li><a href="#SelectTilesByPolygon">SelectTilesByPolygon</a></li>
</ul>
<p><a name="ClassifyOverlapPoints"></a></p>
<a class="header" href="#classifyoverlappoints" id="classifyoverlappoints"><h1>ClassifyOverlapPoints</h1></a>
<p>Classifies or filters LAS points in regions of overlapping flight lines.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--resolution       </td><td> The size of the square area used to evaluate nearby points in the LiDAR data</td></tr>
<tr><td>--filter           </td><td> Filter out points from overlapping flightlines? If false, overlaps will simply be classified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.classify_overlap_points(
    i, 
    output, 
    resolution=2.0, 
    filter=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ClassifyOverlapPoints -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.las ^
--resolution=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/classify_overlap_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/04/2018</p>
<p><a name="ClipLidarToPolygon"></a></p>
<a class="header" href="#cliplidartopolygon" id="cliplidartopolygon"><h1>ClipLidarToPolygon</h1></a>
<p>This tool can be used to isolate, or clip, all of the LiDAR points in a LAS file (<code>--input</code>) contained within
one or more vector polygon features. The user must specify the name of the input clip file (--polygons), wich
must be a vector of a Polygon base shape type. The clip file may contain multiple polygon features and polygon hole
parts will be respected during clipping, i.e. LiDAR points within polygon holes will be removed from the output LAS
file.</p>
<p>Use the <a href="./lidar_tools.html#erasepolygonfromlidar"><strong>ErasePolygonFromLidar</strong></a> tool to perform the complementary operation of removing points from a LAS file
that are contained within a set of polygons.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#erasepolygonfromlidar"><strong>ErasePolygonFromLidar</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#cliprastertopolygon"><strong>ClipRasterToPolygon</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>--polygons         </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.clip_lidar_to_polygon(
    i, 
    polygons, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ClipLidarToPolygon -v ^
--wd=&quot;/path/to/data/&quot; -i='data.las' --polygons='lakes.shp' ^
-o='output.las' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/clip_lidar_to_polygon.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/04/2018</p>
<p><a name="ErasePolygonFromLidar"></a></p>
<a class="header" href="#erasepolygonfromlidar" id="erasepolygonfromlidar"><h1>ErasePolygonFromLidar</h1></a>
<p>This tool can be used to remove, or erase, all of the LiDAR points in a LAS file (<code>--input</code>) contained within
one or more vector polygon features. The user must specify the name of the input clip file (--polygons), wich
must be a vector of a Polygon base shape type. The clip file may contain multiple polygon features and polygon hole
parts will be respected during clipping, i.e. LiDAR points within polygon holes will be remain in the output LAS
file.</p>
<p>Use the <a href="./lidar_tools.html#cliplidartopolygon"><strong>ClipLidarToPolygon</strong></a> tool to perform the complementary operation of clipping (isolating) points from a LAS file
that are contained within a set of polygons, while removing points that lie outside the input polygons.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#cliplidartopolygon"><strong>ClipLidarToPolygon</strong></a>, <a href="./gis_analysis_overlay_tools.html#clip"><strong>Clip</strong></a>, <a href="./gis_analysis_overlay_tools.html#cliprastertopolygon"><strong>ClipRasterToPolygon</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>--polygons         </td><td> Input vector polygons file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.erase_polygon_from_lidar(
    i, 
    polygons, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ErasePolygonFromLidar -v ^
--wd=&quot;/path/to/data/&quot; -i='data.las' --polygons='lakes.shp' ^
-o='output.las' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/erase_polygon_from_lidar.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/04/2018</p>
<p><a name="FilterLidarClasses"></a></p>
<a class="header" href="#filterlidarclasses" id="filterlidarclasses"><h1>FilterLidarClasses</h1></a>
<p>This tool can be used to remove points within a LAS LiDAR file that possess certain
specified class values. The user must input the names of the input (<code>--input</code>) and
output (<code>--output</code>) LAS files and the class values to be excluded (<code>--exclude_cls</code>).
Class values are specified by their numerical values, such that:</p>
<table><thead><tr><th> Classification Value  </th><th> Meaning                              </th></tr></thead><tbody>
<tr><td align="left"> 0                     </td><td align="left"> Created never classified</td></tr>
<tr><td align="left"> 1                     </td><td align="left"> Unclassified</td></tr>
<tr><td align="left"> 2                     </td><td align="left"> Ground</td></tr>
<tr><td align="left"> 3                     </td><td align="left"> Low Vegetation</td></tr>
<tr><td align="left"> 4                     </td><td align="left"> Medium Vegetation</td></tr>
<tr><td align="left"> 5                     </td><td align="left"> High Vegetation</td></tr>
<tr><td align="left"> 6                     </td><td align="left"> Building</td></tr>
<tr><td align="left"> 7                     </td><td align="left"> Low Point (noise)</td></tr>
<tr><td align="left"> 8                     </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 9                     </td><td align="left"> Water</td></tr>
<tr><td align="left"> 10                    </td><td align="left"> Rail</td></tr>
<tr><td align="left"> 11                    </td><td align="left"> Road Surface</td></tr>
<tr><td align="left"> 12                    </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 13                    </td><td align="left">   Wire – Guard (Shield)</td></tr>
<tr><td align="left"> 14                    </td><td align="left"> Wire – Conductor (Phase)</td></tr>
<tr><td align="left"> 15                    </td><td align="left"> Transmission Tower</td></tr>
<tr><td align="left"> 16                    </td><td align="left"> Wire-structure Connector (e.g. Insulator)</td></tr>
<tr><td align="left"> 17                    </td><td align="left"> Bridge Deck</td></tr>
<tr><td align="left"> 18                    </td><td align="left"> High Noise</td></tr>
</tbody></table>
<p>Thus, to filter out low and high noise points from a point cloud, specify
<code>--exclude_cls='7,18'</code>. Notice that usage of this tool assumes that the
LAS file has underwent a comprehensive point classification, which not all
point clouds have had. Use the <a href="./lidar_tools.html#lidarinfo"><strong>LidarInfo</strong></a> tool determine the distribution
of various class values in your file.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarinfo"><strong>LidarInfo</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.filter_lidar_classes(
    i, 
    output, 
    exclude_cls=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FilterLidarClasses -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--exclude_cls='7,18' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/filter_lidar_classes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/07/2019</p>
<p><a name="FilterLidarScanAngles"></a></p>
<a class="header" href="#filterlidarscanangles" id="filterlidarscanangles"><h1>FilterLidarScanAngles</h1></a>
<p>Removes points in a LAS file with scan angles greater than a threshold.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--threshold        </td><td> Scan angle threshold</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.filter_lidar_scan_angles(
    i, 
    output, 
    threshold, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FilterLidarScanAngles -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--threshold=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/filter_lidar_scan_angles.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: September 17, 2017</p>
<p><a name="FindFlightlineEdgePoints"></a></p>
<a class="header" href="#findflightlineedgepoints" id="findflightlineedgepoints"><h1>FindFlightlineEdgePoints</h1></a>
<p>Identifies points along a flightline's edge in a LAS file.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_flightline_edge_points(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindFlightlineEdgePoints -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/find_flightline_edge_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 14, 2017</p>
<p><a name="FlightlineOverlap"></a></p>
<a class="header" href="#flightlineoverlap" id="flightlineoverlap"><h1>FlightlineOverlap</h1></a>
<p>Reads a LiDAR (LAS) point file and outputs a raster containing the number of overlapping flight lines in each grid cell.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.flightline_overlap(
    i=None, 
    output=None, 
    resolution=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FlightlineOverlap -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=2.0&quot;
./whitebox_tools -r=FlightlineOverlap -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=5.0 --palette=light_quant.plt 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/flightline_overlap.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/06/2017</p>
<p><a name="LasToAscii"></a></p>
<a class="header" href="#lastoascii" id="lastoascii"><h1>LasToAscii</h1></a>
<p>This tool can be used to convert one or more LAS file, containing LiDAR data, into ASCII files. The user must
specify the name(s) of the input LAS file(s) (<code>--inputs</code>). Each input file will have a coorespondingly named
output file with a <code>.csv</code> file extension. CSV files are comma separated value files and contain tabular data
with each column cooresponding to a field in the table and each row a point value. Fields are separated by
commas in the ASCII formated file. The output point data, each on a seperate line, will take the format:</p>
<pre><code>X,Y,Z,INTENSITY,CLASS,RETURN,NUM_RETURN,SCAN_ANGLE
</code></pre>
<p>If the LAS file has a point format that contains RGB data, the final three columns will contain the RED,
GREEN, and BLUE values respectively. Use the <a href="./thread&#x27;main&#x27;panickedat&#x27;_unrecognizedtoolname_asciitolas.&#x27;,srcmain.rs:66:21note:runwith%60rust_backtrace=1%60environmentvariabletodisplayabacktrace..html#asciitolas"><strong>AsciiToLas</strong></a> tool to convert a text file containing LiDAR
point data into a LAS file.</p>
<p><em>See Also</em>:</p>
<p><a href="./thread&#x27;main&#x27;panickedat&#x27;_unrecognizedtoolname_asciitolas.&#x27;,srcmain.rs:66:21note:runwith%60rust_backtrace=1%60environmentvariabletodisplayabacktrace..html#asciitolas"><strong>AsciiToLas</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input LiDAR files</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.las_to_ascii(
    inputs, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LasToAscii -v --wd=&quot;/path/to/data/&quot; ^
-i=&quot;file1.las, file2.las, file3.las&quot; -o=outfile.las&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/las_to_ascii.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/07/2017</p>
<p><a name="LasToMultipointShapefile"></a></p>
<a class="header" href="#lastomultipointshapefile" id="lastomultipointshapefile"><h1>LasToMultipointShapefile</h1></a>
<p>Converts one or more LAS files into MultipointZ vector Shapefiles. When the input parameter is
not specified, the tool grids all LAS files contained within the working directory.</p>
<p>This tool can be used in place of the <a href="./lidar_tools.html#lastoshapefile"><strong>LasToShapefile</strong></a> tool when the number of points are
relatively high and when the desire is to represent the x,y,z position of points only. The z
values of LAS points will be stored in the z-array of the output Shapefile. Notice that because
the output file stores each point in a single multi-point record, this Shapefile representation,
while unable to represent individual point classes, return numbers, etc, is an efficient means
of converting LAS point positional information.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lastoshapefile"><strong>LasToShapefile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.las_to_multipoint_shapefile(
    i=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LasToMultipointShapefile -v ^
--wd=&quot;/path/to/data/&quot; -i=input.las 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/las_to_multipoint_shapefile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 04/09/2018</p>
<p><a name="LasToShapefile"></a></p>
<a class="header" href="#lastoshapefile" id="lastoshapefile"><h1>LasToShapefile</h1></a>
<p>This tool converts one or more LAS files into a POINT vector. When the input parameter is
not specified, the tool grids all LAS files contained within the working directory.
The attribute table of the output Shapefile will contain fields for the z-value,
intensity, point class, return number, and number of return.</p>
<p>This tool can be used in place of the <a href="./lidar_tools.html#lastomultipointshapefile"><strong>LasToMultipointShapefile</strong></a> tool when the
number of points are relatively low and when the desire is to represent more than
simply the x,y,z position of points. Notice however that because each point in
the input LAS file will be represented as a separate record in the output
Shapefile, the output file will be many time larger than the equivalent output of
the <a href="./lidar_tools.html#lastomultipointshapefile"><strong>LasToMultipointShapefile</strong></a> tool. There is also a practical limit on the
total number of records that can be held in a single Shapefile and large LAS
files approach this limit. In these cases, the <a href="./lidar_tools.html#lastomultipointshapefile"><strong>LasToMultipointShapefile</strong></a> tool
should be preferred instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lastomultipointshapefile"><strong>LasToMultipointShapefile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.las_to_shapefile(
    i=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LasToShapefile -v --wd=&quot;/path/to/data/&quot; ^
-i=input.las 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/las_to_shapefile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/10/2018</p>
<p><a name="LidarBlockMaximum"></a></p>
<a class="header" href="#lidarblockmaximum" id="lidarblockmaximum"><h1>LidarBlockMaximum</h1></a>
<p>Creates a block-maximum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_block_maximum(
    i=None, 
    output=None, 
    resolution=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarBlockMaximum -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=2.0&quot;
./whitebox_tools -r=LidarBlockMaximum -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=5.0 --palette=light_quant.plt 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/block_maximum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="LidarBlockMinimum"></a></p>
<a class="header" href="#lidarblockminimum" id="lidarblockminimum"><h1>LidarBlockMinimum</h1></a>
<p>Creates a block-minimum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_block_minimum(
    i=None, 
    output=None, 
    resolution=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarBlockMinimum -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=2.0&quot;
./whitebox_tools -r=LidarBlockMinimum -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=5.0 --palette=light_quant.plt 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/block_minimum.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="LidarClassifySubset"></a></p>
<a class="header" href="#lidarclassifysubset" id="lidarclassifysubset"><h1>LidarClassifySubset</h1></a>
<p>This tool classifies points within a user-specified LiDAR point cloud (<code>--base</code>) that correpond
with points in a subset cloud (<code>--subset</code>). The subset point cloud may have been derived by filtering
the original point cloud. The user must specify the names of the two input LAS files (i.e.
the full and subset clouds) and the class value (<code>--subset_class</code>) to assign the matching points. This class
value will be assigned to points in the base cloud, overwriting their input class values in the
output LAS file (<code>--output</code>). Class values
should be numerical (integer valued) and shoud follow the LAS specifications below:</p>
<table><thead><tr><th> Classification Value  </th><th> Meaning                              </th></tr></thead><tbody>
<tr><td align="left"> 0                     </td><td align="left"> Created never classified</td></tr>
<tr><td align="left"> 1                     </td><td align="left"> Unclassified3</td></tr>
<tr><td align="left"> 2                     </td><td align="left"> Ground</td></tr>
<tr><td align="left"> 3                     </td><td align="left"> Low Vegetation</td></tr>
<tr><td align="left"> 4                     </td><td align="left"> Medium Vegetation</td></tr>
<tr><td align="left"> 5                     </td><td align="left"> High Vegetation</td></tr>
<tr><td align="left"> 6                     </td><td align="left"> Building</td></tr>
<tr><td align="left"> 7                     </td><td align="left"> Low Point (noise)</td></tr>
<tr><td align="left"> 8                     </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 9                     </td><td align="left"> Water</td></tr>
<tr><td align="left"> 10                    </td><td align="left"> Rail</td></tr>
<tr><td align="left"> 11                    </td><td align="left"> Road Surface</td></tr>
<tr><td align="left"> 12                    </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 13                    </td><td align="left">   Wire – Guard (Shield)</td></tr>
<tr><td align="left"> 14                    </td><td align="left"> Wire – Conductor (Phase)</td></tr>
<tr><td align="left"> 15                    </td><td align="left"> Transmission Tower</td></tr>
<tr><td align="left"> 16                    </td><td align="left"> Wire-structure Connector (e.g. Insulator)</td></tr>
<tr><td align="left"> 17                    </td><td align="left"> Bridge Deck</td></tr>
<tr><td align="left"> 18                    </td><td align="left"> High Noise</td></tr>
</tbody></table>
<p>The user may optionally specify a class value to be assigned to non-subset (i.e. non-matching)
points (<code>--nonsubset_class</code>) in the base file. If this parameter is not specified, output
non-sutset points will have the same class value as the base file.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--base             </td><td> Input base LiDAR file</td></tr>
<tr><td>--subset           </td><td> Input subset LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--subset_class     </td><td> Subset point class value (must be 0-18; see LAS specifications)</td></tr>
<tr><td>--nonsubset_class  </td><td> Non-subset point class value (must be 0-18; see LAS specifications)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_classify_subset(
    base, 
    subset, 
    output, 
    subset_class, 
    nonsubset_class=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarClassifySubset -v ^
--wd=&quot;/path/to/data/&quot; --base=&quot;full_cloud.las&quot; ^
--subset=&quot;filtered_cloud.las&quot; -o=&quot;output.las&quot; ^
--subset_class=2 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_classify_subset.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay and Kevin Roberts</p>
<p><em>Created</em>: 24/10/2018</p>
<p><a name="LidarColourize"></a></p>
<a class="header" href="#lidarcolourize" id="lidarcolourize"><h1>LidarColourize</h1></a>
<p>Adds the red-green-blue colour fields of a LiDAR (LAS) file based on an input image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--in_lidar         </td><td> Input LiDAR file</td></tr>
<tr><td>--in_image         </td><td> Input colour image file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_colourize(
    in_lidar, 
    in_image, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarColourize -v --wd=&quot;/path/to/data/&quot; ^
--in_lidar=&quot;input.las&quot; --in_image=&quot;image.tif&quot; ^
-o=&quot;output.las&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_colourize.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: February 18, 2018</p>
<p><a name="LidarConstructVectorTin"></a></p>
<a class="header" href="#lidarconstructvectortin" id="lidarconstructvectortin"><h1>LidarConstructVectorTin</h1></a>
<p>This tool creates a vector triangular irregular network (TIN) for a set of LiDAR points (<code>--input</code>)
using a 2D <a href="https://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> algorithm.
LiDAR points may be excluded from the triangulation operation based on a number of criteria,
include the point return number (<code>--returns</code>), point classification value (<code>--exclude_cls</code>), or
a minimum (<code>--minz</code>) or maximum (<code>--maxz</code>) elevation.</p>
<p>For vector points, use the <a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#constructvectortin"><strong>ConstructVectorTIN</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file (including extension)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file (including extension)</td></tr>
<tr><td>--returns          </td><td> Point return types to include; options are 'all' (default), 'last', 'first'</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
<tr><td>--minz             </td><td> Optional minimum elevation for inclusion in interpolation</td></tr>
<tr><td>--maxz             </td><td> Optional maximum elevation for inclusion in interpolation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_construct_vector_tin(
    i=None, 
    output=None, 
    returns=&quot;all&quot;, 
    exclude_cls=None, 
    minz=None, 
    maxz=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarConstructVectorTIN -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--returns=last --exclude_cls='3,4,5,6,7,18' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_construct_vector_tin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/09/2018</p>
<p><a name="LidarElevationSlice"></a></p>
<a class="header" href="#lidarelevationslice" id="lidarelevationslice"><h1>LidarElevationSlice</h1></a>
<p>This tool can be used to either extract or classify the elevation values (z) of LiDAR points within
a specified elevation range (slice). In addition to the names of the input and output LiDAR files
(<code>--input</code> and <code>--output</code>), the user must specify the lower (<code>--minz</code>) and upper (<code>--maxz</code>) bounds of
the elevation range. By default, the tool will only output points within the elevation slice, filtering
out all points lying outside of this range. If the <code>--class</code> parameter is used, the tool will operate
by assigning a class value (<code>--inclassval</code>) to the classification bit of points within the slice and
another class value (<code>--outclassval</code>) to those points falling outside the range.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarremoveoutliers"><strong>LidarRemoveOutliers</strong></a>, <a href="./lidar_tools.html#lidarclassifysubset"><strong>LidarClassifySubset</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--minz             </td><td> Minimum elevation value (optional)</td></tr>
<tr><td>--maxz             </td><td> Maximum elevation value (optional)</td></tr>
<tr><td>--class            </td><td> Optional boolean flag indicating whether points outside the range should be retained in output but reclassified</td></tr>
<tr><td>--inclassval       </td><td> Optional parameter specifying the class value assigned to points within the slice</td></tr>
<tr><td>--outclassval      </td><td> Optional parameter specifying the class value assigned to points within the slice</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_elevation_slice(
    i, 
    output, 
    minz=None, 
    maxz=None, 
    cls=False, 
    inclassval=2, 
    outclassval=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarElevationSlice -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--minz=100.0 --maxz=250.0
&gt;&gt;./whitebox_tools ^
-r=LidarElevationSlice -v -i=&quot;/path/to/data/input.las&quot; ^
-o=&quot;/path/to/data/output.las&quot; --minz=100.0 --maxz=250.0 ^
--class
&gt;&gt;./whitebox_tools -r=LidarElevationSlice -v ^
-i=&quot;/path/to/data/input.las&quot; -o=&quot;/path/to/data/output.las&quot; ^
--minz=100.0 --maxz=250.0 --inclassval=1 --outclassval=0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_elevation_slice.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/06/2017</p>
<p><a name="LidarGroundPointFilter"></a></p>
<a class="header" href="#lidargroundpointfilter" id="lidargroundpointfilter"><h1>LidarGroundPointFilter</h1></a>
<p>This tool can be used to perform a slope-based classification, or filtering (i.e. removal), of
non-ground points within a LiDAR point-cloud. The user must specify the name of the input and output
LiDAR files (<code>--input</code> and <code>--output</code>). Inter-point slopes are compared between pair of points
contained within local neighbourhoods of size <code>--radius</code>. Neighbourhoods with fewer than the
user-specified minimum number of points (<code>--min_neighbours</code>) are extended until the minimum point
number is equaled or exceeded. Points that are above neighbouring points by the minimum
(<code>--height_threshold</code>) and have an inter-point slope greater than the user-specifed threshold
(<code>--slope_threshold</code>) are considered non-ground points and are either optionally (<code>--classify</code>)
excluded from the output point-cloud or assigned the <em>unclassified</em> (value 1) class value.</p>
<p>Slope-based ground-point classification methods suffer from the challenge of uses a constant
slope threshold under varying terrain slopes. Some researchers have developed schemes for varying
the slope threshold based on underlying terrain slopes. <a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a> instead allow the
user to optionally (<code>--slope_norm</code>) normalize the underlying terrain (i.e. flatten the terrain)
using a white top-hat transform. A constant slope threshold may then be used without contributing
to poorer performance under steep topography. Note, that this option, while useful in rugged
terrain, is computationally intensive. If the point-cloud is of a relatively flat terrain,
this option may be excluded.</p>
<p>While this tool is appropriately applied to LiDAR point-clouds, the <a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a>
tool can be used to remove off-terrain objects from rasterized LiDAR digital elevation models (DEMs).</p>
<p><em>Reference</em>:</p>
<p>Vosselman, G. (2000). Slope based filtering of laser altimetry data. <em>International Archives of
Photogrammetry and Remote Sensing</em>, 33(B3/2; PART 3), 935-942.</p>
<p><em>See Also</em>:</p>
<p><a href="./geomorphometric_analysis.html#removeoffterrainobjects"><strong>RemoveOffTerrainObjects</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--min_neighbours   </td><td> The minimum number of neighbouring points within search areas. If fewer points than this threshold are idenfied during the fixed-radius search, a subsequent kNN search is performed to identify the k number of neighbours</td></tr>
<tr><td>--slope_threshold  </td><td> Maximum inter-point slope to be considered an off-terrain point</td></tr>
<tr><td>--height_threshold </td><td> Inter-point height difference to be considered an off-terrain point</td></tr>
<tr><td>--classify         </td><td> Classify points as ground (2) or off-ground (1)</td></tr>
<tr><td>--slope_norm       </td><td> Perform initial ground slope normalization?</td></tr>
<tr><td>--height_above_ground</td><td> Transform output to height above average ground elevation?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_ground_point_filter(
    i, 
    output, 
    radius=2.0, 
    min_neighbours=0, 
    slope_threshold=45.0, 
    height_threshold=1.0, 
    classify=True, 
    slope_norm=True, 
    height_above_ground=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarGroundPointFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 --min_neighbours=10 --slope_threshold=30.0 ^
--height_threshold=0.5 --classify --slope_norm 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_ground_point_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/06/2017</p>
<p><a name="LidarHexBinning"></a></p>
<a class="header" href="#lidarhexbinning" id="lidarhexbinning"><h1>LidarHexBinning</h1></a>
<p>The practice of binning point data to form a type of 2D histogram, density plot,
or what is sometimes called a heatmap, is quite useful as an alternative for the
cartographic display of of very dense points sets. This is particularly the case
when the points experience significant overlap at the displayed scale. The
<a href="./lidar_tools.html#lidarpointdensity"><strong>LidarPointDensity</strong></a> tool can be used to perform binning based on a regular grid
(raster output). This tool, by comparison, bases the binning on a hexagonal grid.</p>
<p>The tool is similar to the <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a> tool, however instead will
create an output hexagonal grid in which each hexagonal cell possesses a <code>COUNT</code>
attribute which specifies the number of points from an input points file (LAS file)
that are contained within the hexagonal cell. The tool will also calculate the
minimum and maximum elevations and intensity values and outputs these data to the
attribute table.</p>
<p>In addition to the names of the input points file and the output Shapefile, the user
must also specify the desired hexagon width (w), which is the distance between opposing
sides of each hexagon. The size (s) each side of the hexagon can then be calculated as,
s = w / [2 x cos(PI / 6)]. The area of each hexagon (A) is, A = 3s(w / 2). The user must
also specify the orientation of the grid with options of horizontal (pointy side up) and
vertical (flat side up).</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#vectorhexbinning"><strong>VectorHexBinning</strong></a>, <a href="./lidar_tools.html#lidarpointdensity"><strong>LidarPointDensity</strong></a>, <a href="./gis_analysis.html#createhexagonalvectorgrid"><strong>CreateHexagonalVectorGrid</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input base file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--width            </td><td> The grid cell width</td></tr>
<tr><td>--orientation      </td><td> Grid Orientation, 'horizontal' or 'vertical'</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_hex_binning(
    i, 
    output, 
    width, 
    orientation=&quot;horizontal&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarHexBinning -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.shp --width=10.0 ^
--orientation=vertical 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_hex_bin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 16/09/2018</p>
<p><a name="LidarHillshade"></a></p>
<a class="header" href="#lidarhillshade" id="lidarhillshade"><h1>LidarHillshade</h1></a>
<p>Calculates a hillshade value for points within a LAS file and stores these data in the RGB field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--azimuth          </td><td> Illumination source azimuth in degrees</td></tr>
<tr><td>--altitude         </td><td> Illumination source altitude in degrees</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_hillshade(
    i, 
    output, 
    azimuth=315.0, 
    altitude=30.0, 
    radius=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarHillshade -v --wd=&quot;/path/to/data/&quot; ^
-i=&quot;input.las&quot; -o=&quot;output.las&quot; --radius=10.0
&gt;&gt;./whitebox_tools ^
-r=LidarHillshade -v --wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; ^
-o=&quot;output.las&quot; --azimuth=180.0 --altitude=20.0 --radius=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_hillshade.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 14, 2017</p>
<p><a name="LidarHistogram"></a></p>
<a class="header" href="#lidarhistogram" id="lidarhistogram"><h1>LidarHistogram</h1></a>
<p>This tool can be used to plot a histogram of data derived from a LiDAR file. The user must specify the
name of the input LAS file (<code>--input</code>), the name of the output HTML file (<code>--output</code>), the parameter
(<code>--parameter</code>) to be plotted, and the amount (in percent) to clip the upper and lower tails of the f
requency distribution (<code>--clip</code>). The LiDAR parameters that can be plotted using <a href="./lidar_tools.html#lidarhistogram"><strong>LidarHistogram</strong></a>
include the point elevations, intensity values, scan angles, and class values.</p>
<p>Use the <a href="./lidar_tools.html#lidarpointstats"><strong>LidarPointStats</strong></a> tool instead to examine the spatial distribution of LiDAR points.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarpointstats"><strong>LidarPointStats</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
<tr><td>--parameter        </td><td> Parameter; options are 'elevation' (default), 'intensity', 'scan angle', 'class'</td></tr>
<tr><td>--clip             </td><td> Amount to clip distribution tails (in percent)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_histogram(
    i, 
    output, 
    parameter=&quot;elevation&quot;, 
    clip=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarHistogram -v --wd=&quot;/path/to/data/&quot; ^
-i=&quot;file1.tif, file2.tif, file3.tif&quot; -o=outfile.htm ^
--contiguity=Bishopsl 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_histogram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/12/2017</p>
<p><a name="LidarIdwInterpolation"></a></p>
<a class="header" href="#lidaridwinterpolation" id="lidaridwinterpolation"><h1>LidarIdwInterpolation</h1></a>
<p>Interpolates LAS files using an inverse-distance weighted (IDW) scheme. When the input/output parameters are not specified, the tool interpolates all LAS files contained within the working directory.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file (including extension)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file (including extension)</td></tr>
<tr><td>--parameter        </td><td> Interpolation parameter; options are 'elevation' (default), 'intensity', 'class', 'scan angle', 'user data'</td></tr>
<tr><td>--returns          </td><td> Point return types to include; options are 'all' (default), 'last', 'first'</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--weight           </td><td> IDW weight value</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
<tr><td>--minz             </td><td> Optional minimum elevation for inclusion in interpolation</td></tr>
<tr><td>--maxz             </td><td> Optional maximum elevation for inclusion in interpolation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_idw_interpolation(
    i=None, 
    output=None, 
    parameter=&quot;elevation&quot;, 
    returns=&quot;all&quot;, 
    resolution=1.0, 
    weight=1.0, 
    radius=2.5, 
    exclude_cls=None, 
    minz=None, 
    maxz=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarIdwInterpolation -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=2.0 --radius=5.0&quot;
./whitebox_tools ^
-r=LidarIdwInterpolation --wd=&quot;/path/to/data/&quot; -i=file.las ^
-o=outfile.tif --resolution=5.0 --weight=2.0 --radius=2.0 ^
--exclude_cls='3,4,5,6,7,18' --palette=light_quant.plt 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_idw_interpolation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/07/2017</p>
<p><a name="LidarInfo"></a></p>
<a class="header" href="#lidarinfo" id="lidarinfo"><h1>LidarInfo</h1></a>
<p>This tool can be used to print basic information about the data contained within a LAS file, used to store LiDAR
data. The reported information will include including data on the header, point return frequency, and classification
data and information about the variable length records (VLRs) and geokeys.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file for summary report</td></tr>
<tr><td>--vlr              </td><td> Flag indicating whether or not to print the variable length records (VLRs)</td></tr>
<tr><td>--geokeys          </td><td> Flag indicating whether or not to print the geokeys</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_info(
    i, 
    output=None, 
    vlr=False, 
    geokeys=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarInfo -v --wd=&quot;/path/to/data/&quot; ^
-i=file.las --vlr --geokeys&quot;
./whitebox_tools -r=LidarInfo ^
--wd=&quot;/path/to/data/&quot; -i=file.las 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_info.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 1, 2017</p>
<p><a name="LidarJoin"></a></p>
<a class="header" href="#lidarjoin" id="lidarjoin"><h1>LidarJoin</h1></a>
<p>This tool can be used to merge multiple LiDAR LAS files into a single output LAS file. Due to their large size,
LiDAR data sets are often tiled into smaller, non-overlapping tiles. Sometimes it is more convenient to combine
multiple tiles together for data processing and <a href="./lidar_tools.html#lidarjoin"><strong>LidarJoin</strong></a> can be used for this purpose.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidartile"><strong>LidarTile</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input LiDAR files</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_join(
    inputs, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarJoin -v --wd=&quot;/path/to/data/&quot; ^
-i=&quot;file1.las, file2.las, file3.las&quot; -o=outfile.las&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_join.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/06/2017</p>
<p><a name="LidarKappaIndex"></a></p>
<a class="header" href="#lidarkappaindex" id="lidarkappaindex"><h1>LidarKappaIndex</h1></a>
<p>This tool performs a kappa index of agreement (KIA) analysis on the classification values of two LiDAR
(LAS) files. The output report HTML file should be displayed automatically but can also be displayed
afterwards in any web browser. As a measure of overall classification accuracy, the KIA is more robust
than the percent agreement calculation because it takes into account the agreement occurring by random
chance. In addition to the KIA, the tool will output the producer's and user's accuracy, the overall
accuracy, and the error matrix. The KIA is often used as a means of assessing the accuracy of an image
classification analysis; however the <a href="./lidar_tools.html#lidarkappaindex"><strong>LidarKappaIndex</strong></a> tool performs the analysis on a point-to-point
basis, comparing the class values of the points in one input LAS file with the corresponding nearest
points in the second input LAS file.</p>
<p>The user must also specify the name and resolution of an output raster file, which is used to show the
spatial distribution of class accuracy. Each grid cell contains the overall accuracy, i.e. the points
correctly classified divided by the total number of points contained within the cell, expressed as a
percentage.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input LiDAR classification file</td></tr>
<tr><td>--i2, --input2    </td><td> Input LiDAR reference file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--class_accuracy   </td><td> Output classification accuracy raster file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_kappa_index(
    input1, 
    input2, 
    output, 
    class_accuracy, 
    resolution=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarKappaIndex -v ^
--wd=&quot;/path/to/data/&quot; --i1=class.las --i2=reference.las ^
-o=kia.html --class_accuracy=new_file.tif --resolution=0.5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_kappa.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/09/2017</p>
<p><a name="LidarNearestNeighbourGridding"></a></p>
<a class="header" href="#lidarnearestneighbourgridding" id="lidarnearestneighbourgridding"><h1>LidarNearestNeighbourGridding</h1></a>
<p>Grids LAS files using nearest-neighbour scheme. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file (including extension)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file (including extension)</td></tr>
<tr><td>--parameter        </td><td> Interpolation parameter; options are 'elevation' (default), 'intensity', 'class', 'scan angle', 'user data'</td></tr>
<tr><td>--returns          </td><td> Point return types to include; options are 'all' (default), 'last', 'first'</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
<tr><td>--minz             </td><td> Optional minimum elevation for inclusion in interpolation</td></tr>
<tr><td>--maxz             </td><td> Optional maximum elevation for inclusion in interpolation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_nearest_neighbour_gridding(
    i=None, 
    output=None, 
    parameter=&quot;elevation&quot;, 
    returns=&quot;all&quot;, 
    resolution=1.0, 
    radius=2.5, 
    exclude_cls=None, 
    minz=None, 
    maxz=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarNearestNeighbourGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--returns=last --resolution=2.0 --radius=5.0&quot;
./whitebox_tools ^
-r=LidarNearestNeighbourGridding --wd=&quot;/path/to/data/&quot; ^
-i=file.las -o=outfile.tif --resolution=5.0 --radius=2.0 ^
--exclude_cls='3,4,5,6,7,18' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_nn_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="LidarPointDensity"></a></p>
<a class="header" href="#lidarpointdensity" id="lidarpointdensity"><h1>LidarPointDensity</h1></a>
<p>Calculates the spatial pattern of point density for a LiDAR data set. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file (including extension)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file (including extension)</td></tr>
<tr><td>--returns          </td><td> Point return types to include; options are 'all' (default), 'last', 'first'</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
<tr><td>--minz             </td><td> Optional minimum elevation for inclusion in interpolation</td></tr>
<tr><td>--maxz             </td><td> Optional maximum elevation for inclusion in interpolation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_point_density(
    i=None, 
    output=None, 
    returns=&quot;all&quot;, 
    resolution=1.0, 
    radius=2.5, 
    exclude_cls=None, 
    minz=None, 
    maxz=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarPointDensity -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--resolution=2.0 --radius=5.0&quot;
./whitebox_tools ^
-r=LidarPointDensity -v --wd=&quot;/path/to/data/&quot; -i=file.las ^
-o=outfile.tif --resolution=5.0 --radius=2.0 ^
--exclude_cls='3,4,5,6,7,18' --palette=light_quant.plt 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_point_density.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/07/2017</p>
<p><a name="LidarPointStats"></a></p>
<a class="header" href="#lidarpointstats" id="lidarpointstats"><h1>LidarPointStats</h1></a>
<p>This tool creates several rasters summarizing the distribution of LiDAR points in a LAS data file.
The user must specify the name of an input LAS file (<code>--input</code>) and the output raster grid
resolution (<code>--resolution</code>). Additionally, the user must specify one or more of the possible
output rasters to create using the various available flags, which include:</p>
<table><thead><tr><th> Flag                     </th><th> Meaning                                               </th></tr></thead><tbody>
<tr><td align="left"> <code>--num_points</code>           </td><td align="left"> Number of points (returns) in each grid cell          </td></tr>
<tr><td align="left"> <code>--num_pulses</code>           </td><td align="left"> Number of pulses in each grid cell                    </td></tr>
<tr><td align="left"> <code>--avg_points_per_pulse</code> </td><td align="left"> Average number of points per pulse in each grid cells </td></tr>
<tr><td align="left"> <code>--z_range</code>              </td><td align="left"> Elevation range within each grid cell                 </td></tr>
<tr><td align="left"> <code>--intensity_range</code>      </td><td align="left"> Intensity range within each grid cell                 </td></tr>
<tr><td align="left"> <code>--predom_class</code>         </td><td align="left"> Predominant class value within each grid cell         </td></tr>
</tbody></table>
<p>If no output raster flags are specified, all of the output rasters will be created. All output
rasters will have the same base name as the input LAS file but will have a suffix that
reflects the statistic type (e.g. _num_pnts, _num_pulses, _avg_points_per_pulse, etc.). Output
files will be in the GeoTIFF (*.tif) file format.</p>
<p>When the input/output parameters are not specified, the tool works on all LAS files contained within
the working directory.</p>
<p><strong>Notes</strong>:</p>
<ol>
<li>The num_pulses output is actually the number of pulses with at lease one return; specifically it is
the sum of the early returns (first and only) in a grid cell. In areas of low reflectance, such as
over water surfaces, the system may have emited a significantly higher pulse rate but far fewer
returns are observed.</li>
<li>The memory requirement of this tool is high, particulalry if the grid resolution is fine and
the spatial extent is large.</li>
</ol>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarblockminimum"><strong>LidarBlockMinimum</strong></a>, <a href="./lidar_tools.html#lidarblockmaximum"><strong>LidarBlockMaximum</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--num_points       </td><td> Flag indicating whether or not to output the number of points raster</td></tr>
<tr><td>--num_pulses       </td><td> Flag indicating whether or not to output the number of pulses raster</td></tr>
<tr><td>--z_range          </td><td> Flag indicating whether or not to output the elevation range raster</td></tr>
<tr><td>--intensity_range  </td><td> Flag indicating whether or not to output the intensity range raster</td></tr>
<tr><td>--predom_class     </td><td> Flag indicating whether or not to output the predominant classification raster</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_point_stats(
    i=None, 
    resolution=1.0, 
    num_points=True, 
    num_pulses=False, 
    z_range=False, 
    intensity_range=False, 
    predom_class=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarPointStats -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las --resolution=1.0 ^
--num_points 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_point_stats.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/02/2018</p>
<p><a name="LidarRansacPlanes"></a></p>
<a class="header" href="#lidarransacplanes" id="lidarransacplanes"><h1>LidarRansacPlanes</h1></a>
<p>This tool uses the <a href="https://en.wikipedia.org/wiki/Random_sample_consensus">random sample concensus (RANSAC)</a>
method to identify points within a LiDAR point cloud that belong to linear planes. RANSAC is a common
method used in the field of computer vision to identify a subset of inliner points in a noisy data set
containing abundant outlier points. Because LiDAR point clouds often contain vegetation points that do not
form planar surfaces, this tool can be used to largely strip vegetation points from the point cloud, leaving
behind the ground returns, buildings, and other points belonging to planar surfaces. If the <code>--classify</code> flag
is used, non-planar points will not be removed but rather will be assigned a different class (1) than the
planar points (0).</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidargroundpointfilter"><strong>LidarGroundPointFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--num_iter         </td><td> Number of iterations</td></tr>
<tr><td>--num_samples      </td><td> Number of sample points on which to build the model</td></tr>
<tr><td>--threshold        </td><td> Threshold used to determine inliner points</td></tr>
<tr><td>--model_size       </td><td> Acceptable model size</td></tr>
<tr><td>--classify         </td><td> Classify points as ground (2) or off-ground (1)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_ransac_planes(
    i, 
    output, 
    radius=2.0, 
    num_iter=50, 
    num_samples=5, 
    threshold=0.35, 
    model_size=8, 
    classify=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarRansacPlanes -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 --num_iter=10 --num_samples=5 --threshold=0.25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_ransac_planes.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 23/07/2019</p>
<p><a name="LidarRemoveDuplicates"></a></p>
<a class="header" href="#lidarremoveduplicates" id="lidarremoveduplicates"><h1>LidarRemoveDuplicates</h1></a>
<p>This tool removes duplicate points from a LiDAR data set. Duplicates are determined
by their x, y, and optionally (<code>--include_z</code>) z coordinates.</p>
<p><em>See Also</em>:</p>
<p><a href="./gis_analysis.html#eliminatecoincidentpoints"><strong>EliminateCoincidentPoints</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--include_z        </td><td> Include z-values in point comparison?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_remove_duplicates(
    i, 
    output, 
    include_z=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarRemoveDuplicates -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/remove_duplicates.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/03/2018</p>
<p><a name="LidarRemoveOutliers"></a></p>
<a class="header" href="#lidarremoveoutliers" id="lidarremoveoutliers"><h1>LidarRemoveOutliers</h1></a>
<p>This tool will filter out points from a LiDAR point cloud if the absolute elevation
difference between a point and the averge elevation of its neighbourhood, calculated
without the point, exceeds a threshold (elev_diff).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
<tr><td>--elev_diff        </td><td> Max. elevation difference</td></tr>
<tr><td>--use_median       </td><td> Optional flag indicating whether to use the difference from median elevation rather than mean</td></tr>
<tr><td>--classify         </td><td> Classify points as ground (2) or off-ground (1)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_remove_outliers(
    i, 
    output, 
    radius=2.0, 
    elev_diff=50.0, 
    use_median=False, 
    classify=True, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarRemoveOutliers -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 --elev_diff=25.0 --use_median 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_outliers.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/02/2018</p>
<p><a name="LidarSegmentation"></a></p>
<a class="header" href="#lidarsegmentation" id="lidarsegmentation"><h1>LidarSegmentation</h1></a>
<p>This tool segments a LiDAR point cloud based on normal vectors. The segment values
are stored as unique, random red-green-blue (RGB) colour values stored in the output
(<code>--output</code>) LAS file.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarsegmentationbasedfilter"><strong>LidarSegmentationBasedFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--dist, --radius  </td><td> Search Radius</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--maxzdiff         </td><td> Maximum difference in elevation (z units) between neighbouring points of the same segment</td></tr>
<tr><td>--classes          </td><td> Segments don't cross class boundaries</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_segmentation(
    i, 
    output, 
    radius=5.0, 
    norm_diff=10.0, 
    maxzdiff=1.0, 
    classes=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarSegmentation -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 --norm_diff=2.5 --maxzdiff=0.75 --classes 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_segmentation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 5/12/2017</p>
<p><a name="LidarSegmentationBasedFilter"></a></p>
<a class="header" href="#lidarsegmentationbasedfilter" id="lidarsegmentationbasedfilter"><h1>LidarSegmentationBasedFilter</h1></a>
<p>Identifies ground points within LiDAR point clouds using a segmentation based approach.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--dist, --radius  </td><td> Search Radius</td></tr>
<tr><td>--norm_diff        </td><td> Maximum difference in normal vectors, in degrees</td></tr>
<tr><td>--maxzdiff         </td><td> Maximum difference in elevation (z units) between neighbouring points of the same segment</td></tr>
<tr><td>--classify         </td><td> Classify points as ground (2) or off-ground (1)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_segmentation_based_filter(
    i, 
    output, 
    radius=5.0, 
    norm_diff=2.0, 
    maxzdiff=1.0, 
    classify=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarSegmentationBasedFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 --norm_diff=2.5 --maxzdiff=0.75 --classify 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_segmentation_based_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 5/12/2017, 2017</p>
<p><a name="LidarThin"></a></p>
<a class="header" href="#lidarthin" id="lidarthin"><h1>LidarThin</h1></a>
<p>Thins a LiDAR point cloud, reducing point density.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--resolution       </td><td> The size of the square area used to evaluate nearby points in the LiDAR data</td></tr>
<tr><td>--method           </td><td> Point selection method; options are 'first', 'last', 'lowest' (default), 'highest', 'nearest'</td></tr>
<tr><td>--save_filtered    </td><td> Save filtered points to seperate file?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_thin(
    i, 
    output, 
    resolution=2.0, 
    method=&quot;lowest&quot;, 
    save_filtered=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarThin -v --wd=&quot;/path/to/data/&quot; ^
-i=file.las -o=outfile.las --resolution=2.0, --method=first ^
--save_filtered 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_thin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 06/05/2018</p>
<p><a name="LidarThinHighDensity"></a></p>
<a class="header" href="#lidarthinhighdensity" id="lidarthinhighdensity"><h1>LidarThinHighDensity</h1></a>
<p>Thins points from high density areas within a LiDAR point cloud.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--density          </td><td> Max. point density (points / m^3)</td></tr>
<tr><td>--save_filtered    </td><td> Save filtered points to seperate file?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_thin_high_density(
    i, 
    output, 
    density, 
    resolution=1.0, 
    save_filtered=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarThinHighDensity -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--resolution=1.0 --density=100.0 --save_filtered 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_thin_high_density.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: February 6, 2018</p>
<p><a name="LidarTile"></a></p>
<a class="header" href="#lidartile" id="lidartile"><h1>LidarTile</h1></a>
<p>This tool can be used to break a LiDAR LAS file into multiple, non-overlapping tiles, each saved as a
single LAS file. The user must specify the parameter of the tile grid, including its origin (<code>--origin_x</code> and
<code>--origin_y</code>) and the tile width and height (<code>--width</code> and <code>--height</code>). Tiles containing fewer points than
specified in the <code>--min_points</code> parameter will not be output. This can be useful when tiling terrestrial LiDAR
datasets because the low point density at the edges of the point cloud (i.e. most distant from the scan
station) can result in poorly populated tiles containing relatively few points.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidarjoin"><strong>LidarJoin</strong></a>, <a href="./lidar_tools.html#lidartilefootprint"><strong>LidarTileFootprint</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>--width            </td><td> Width of tiles in the X dimension; default 1000.0</td></tr>
<tr><td>--height           </td><td> Height of tiles in the Y dimension</td></tr>
<tr><td>--origin_x         </td><td> Origin point X coordinate for tile grid</td></tr>
<tr><td>--origin_y         </td><td> Origin point Y coordinate for tile grid</td></tr>
<tr><td>--min_points       </td><td> Minimum number of points contained in a tile for it to be saved</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_tile(
    i, 
    width=1000.0, 
    height=1000.0, 
    origin_x=0.0, 
    origin_y=0.0, 
    min_points=2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarTile -v -i=/path/to/data/input.las ^
--width=1000.0 --height=2500.0 -=min_points=100 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_tile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="LidarTileFootprint"></a></p>
<a class="header" href="#lidartilefootprint" id="lidartilefootprint"><h1>LidarTileFootprint</h1></a>
<p>This tool can be used to create a vector polygon of the bounding box or convex hull of a LiDAR point cloud (i.e. LAS file).
If the user specified an input file (<code>--input</code>) and output file (<code>--output</code>), the tool will calculate the footprint,
containing all of the data points, and output this feature to a vector polygon file. If the <code>input</code> and
<code>output</code> parameters are left unspecified, the tool will calculate the footprint of every LAS file contained within the
working directory and output these features to a single vector polygon file. If this is the desired mode of
operation, it is important to specify the working directory (<code>--wd</code>) containing the group of LAS files; do not
specify the optional <code>--input</code> and <code>--output</code> parameters in this case. Each polygon in the output vector will contain
a <code>LAS_NM</code> field, specifying the source LAS file name, a <code>NUM_PNTS</code> field, containing the number of points
within the source file, and Z_MIN and Z_MAX fields, containing the minimum and maximum elevations. This output can
therefore be useful to create an index map of a large tiled LiDAR dataset.</p>
<p>By default, this tool identifies the axis-aligned minimum rectangular hull, or bounding box, containing the points
in each of the input tiles. If the user specifies the <code>--hull</code> flag, the tool will identify the
<a href="https://en.wikipedia.org/wiki/Convex_hull">minimum convex hull</a> instead of the bounding box. This option is considerably
more computationally intensive and will be a far longer running operation if many tiles are specified as inputs.</p>
<p><strong>A note on LAZ file inputs:</strong> While WhiteboxTools does not currently support the reading and writing of the compressed
LiDAR format <code>LAZ</code>, it is able to read <code>LAZ</code> file headers. This tool, when run in in the bounding box mode (rather than
the convex hull mode), is able to take <code>LAZ</code> input files.</p>
<p><a href="./lidar_tools.html#lidartile"><strong>LidarTile</strong></a>, <a href="./gis_analysis.html#layerfootprint"><strong>LayerFootprint</strong></a>, <a href="./gis_analysis.html#minimumboundingbox"><strong>MinimumBoundingBox</strong></a>, <a href="./gis_analysis.html#minimumconvexhull"><strong>MinimumConvexHull</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output vector polygon file</td></tr>
<tr><td>--hull             </td><td> Identify the convex hull around points</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_tile_footprint(
    output, 
    i=None, 
    hull=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarTileFootprint -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.shp 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_tile_footprint.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 31/08/2018</p>
<p><a name="LidarTinGridding"></a></p>
<a class="header" href="#lidartingridding" id="lidartingridding"><h1>LidarTinGridding</h1></a>
<p>Creates a raster grid based on a Delaunay triangular irregular network (TIN) fitted to LiDAR points.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file (including extension)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file (including extension)</td></tr>
<tr><td>--parameter        </td><td> Interpolation parameter; options are 'elevation' (default), 'intensity', 'class', 'scan angle', 'user data'</td></tr>
<tr><td>--returns          </td><td> Point return types to include; options are 'all' (default), 'last', 'first'</td></tr>
<tr><td>--resolution       </td><td> Output raster's grid resolution</td></tr>
<tr><td>--exclude_cls      </td><td> Optional exclude classes from interpolation; Valid class values range from 0 to 18, based on LAS specifications. Example, --exclude_cls='3,4,5,6,7,18'</td></tr>
<tr><td>--minz             </td><td> Optional minimum elevation for inclusion in interpolation</td></tr>
<tr><td>--maxz             </td><td> Optional maximum elevation for inclusion in interpolation</td></tr>
<tr><td>--max_triangle_edge_length</td><td> Optional maximum triangle edge length; triangles larger than this size will not be gridded</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_tin_gridding(
    i=None, 
    output=None, 
    parameter=&quot;elevation&quot;, 
    returns=&quot;all&quot;, 
    resolution=1.0, 
    exclude_cls=None, 
    minz=None, 
    maxz=None, 
    max_triangle_edge_length=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarTINGridding -v ^
--wd=&quot;/path/to/data/&quot; -i=file.las -o=outfile.tif ^
--returns=last --resolution=2.0 --exclude_cls='3,4,5,6,7,18' ^
--max_triangle_edge_length=5.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_tin_gridding.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/09/2018</p>
<p><a name="LidarTophatTransform"></a></p>
<a class="header" href="#lidartophattransform" id="lidartophattransform"><h1>LidarTophatTransform</h1></a>
<p>This tool performs a white <a href="https://en.wikipedia.org/wiki/Top-hat_transform">top-hat transform</a> on a LiDAR point cloud.
A top-hat transform is a common digital image processing operation used for various tasks, such
as feature extraction, background equalization, and image enhancement. When applied to a LiDAR point cloud, the white
top-hat transform provides an estimate of <em>height above ground</em>, which is useful for modelling the vegetation canopy.</p>
<p>The white top-hat transform is defined as the difference between a point's original elevation and its
<a href="https://en.wikipedia.org/wiki/Opening_(morphology)">opening</a>. The opening operation can be thought of as the local
neighbourhood maximum of a previous local minimum surface. The user must specify the size of the neighbourhood using the
<code>--radius</code> parameter.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools.html#tophattransform"><strong>TophatTransform</strong></a>, <a href="./image_processing_tools.html#closing"><strong>Closing</strong></a>, <a href="./image_processing_tools.html#opening"><strong>Opening</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.lidar_tophat_transform(
    i, 
    output, 
    radius=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarTophatTransform -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;input.las&quot; -o=&quot;output.las&quot; ^
--radius=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/lidar_tophat_transform.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/09/2017</p>
<p><a name="NormalVectors"></a></p>
<a class="header" href="#normalvectors" id="normalvectors"><h1>NormalVectors</h1></a>
<p>Calculates normal vectors for points within a LAS file and stores these data (XYZ vector components) in the RGB field.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input LiDAR file</td></tr>
<tr><td>-o, --output       </td><td> Output LiDAR file</td></tr>
<tr><td>--radius           </td><td> Search Radius</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.normal_vectors(
    i, 
    output, 
    radius=1.0, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NormalVectors -v --wd=&quot;/path/to/data/&quot; ^
-i=&quot;input.las&quot; -o=&quot;output.las&quot; --radius=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/normal_vectors.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="SelectTilesByPolygon"></a></p>
<a class="header" href="#selecttilesbypolygon" id="selecttilesbypolygon"><h1>SelectTilesByPolygon</h1></a>
<p>This tool copies LiDAR tiles overlapping with a polygon into an output directory.</p>
<p><strong>A note on LAZ file inputs:</strong> While WhiteboxTools does not currently support the reading and writing of the compressed
LiDAR format <code>LAZ</code>, it is able to read <code>LAZ</code> file headers. Because this tool only requires information contained
in the input file's header (i.e. the bounding box of the data), it is able to take <code>LAZ</code> input files.</p>
<p><em>See Also</em>:</p>
<p><a href="./lidar_tools.html#lidartilefootprint"><strong>LidarTileFootprint</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--indir            </td><td> Input LAS file source directory</td></tr>
<tr><td>--outdir           </td><td> Output directory into which LAS files within the polygon are copied</td></tr>
<tr><td>--polygons         </td><td> Input vector polygons file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.select_tiles_by_polygon(
    indir, 
    outdir, 
    polygons, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SelectTilesByPolygon -v ^
--indir='/path/to/lidar/' --outdir='/output/path/' ^
--polygons='watershed.shp' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/lidar_analysis/select_tiles_by_polygon.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/08/2018</p>
<a class="header" href="#math-and-stats-tools" id="math-and-stats-tools"><h1>Math and Stats Tools</h1></a>
<ul>
<li><a href="#AbsoluteValue">AbsoluteValue</a></li>
<li><a href="#Add">Add</a></li>
<li><a href="#And">And</a></li>
<li><a href="#Anova">Anova</a></li>
<li><a href="#ArcCos">ArcCos</a></li>
<li><a href="#ArcSin">ArcSin</a></li>
<li><a href="#ArcTan">ArcTan</a></li>
<li><a href="#Atan2">Atan2</a></li>
<li><a href="#AttributeCorrelation">AttributeCorrelation</a></li>
<li><a href="#AttributeHistogram">AttributeHistogram</a></li>
<li><a href="#AttributeScattergram">AttributeScattergram</a></li>
<li><a href="#Ceil">Ceil</a></li>
<li><a href="#Cos">Cos</a></li>
<li><a href="#Cosh">Cosh</a></li>
<li><a href="#CrispnessIndex">CrispnessIndex</a></li>
<li><a href="#CrossTabulation">CrossTabulation</a></li>
<li><a href="#CumulativeDistribution">CumulativeDistribution</a></li>
<li><a href="#Decrement">Decrement</a></li>
<li><a href="#Divide">Divide</a></li>
<li><a href="#EqualTo">EqualTo</a></li>
<li><a href="#Exp">Exp</a></li>
<li><a href="#Exp2">Exp2</a></li>
<li><a href="#Floor">Floor</a></li>
<li><a href="#GreaterThan">GreaterThan</a></li>
<li><a href="#ImageAutocorrelation">ImageAutocorrelation</a></li>
<li><a href="#ImageCorrelation">ImageCorrelation</a></li>
<li><a href="#ImageRegression">ImageRegression</a></li>
<li><a href="#InPlaceAdd">InPlaceAdd</a></li>
<li><a href="#InPlaceDivide">InPlaceDivide</a></li>
<li><a href="#InPlaceMultiply">InPlaceMultiply</a></li>
<li><a href="#InPlaceSubtract">InPlaceSubtract</a></li>
<li><a href="#Increment">Increment</a></li>
<li><a href="#IntegerDivision">IntegerDivision</a></li>
<li><a href="#IsNoData">IsNoData</a></li>
<li><a href="#KappaIndex">KappaIndex</a></li>
<li><a href="#KsTestForNormality">KsTestForNormality</a></li>
<li><a href="#LessThan">LessThan</a></li>
<li><a href="#ListUniqueValues">ListUniqueValues</a></li>
<li><a href="#Ln">Ln</a></li>
<li><a href="#Log10">Log10</a></li>
<li><a href="#Log2">Log2</a></li>
<li><a href="#Max">Max</a></li>
<li><a href="#Min">Min</a></li>
<li><a href="#Modulo">Modulo</a></li>
<li><a href="#Multiply">Multiply</a></li>
<li><a href="#Negate">Negate</a></li>
<li><a href="#Not">Not</a></li>
<li><a href="#NotEqualTo">NotEqualTo</a></li>
<li><a href="#Or">Or</a></li>
<li><a href="#Power">Power</a></li>
<li><a href="#PrincipalComponentAnalysis">PrincipalComponentAnalysis</a></li>
<li><a href="#Quantiles">Quantiles</a></li>
<li><a href="#RandomField">RandomField</a></li>
<li><a href="#RandomSample">RandomSample</a></li>
<li><a href="#RasterHistogram">RasterHistogram</a></li>
<li><a href="#RasterSummaryStats">RasterSummaryStats</a></li>
<li><a href="#Reciprocal">Reciprocal</a></li>
<li><a href="#RescaleValueRange">RescaleValueRange</a></li>
<li><a href="#RootMeanSquareError">RootMeanSquareError</a></li>
<li><a href="#Round">Round</a></li>
<li><a href="#Sin">Sin</a></li>
<li><a href="#Sinh">Sinh</a></li>
<li><a href="#Square">Square</a></li>
<li><a href="#SquareRoot">SquareRoot</a></li>
<li><a href="#Subtract">Subtract</a></li>
<li><a href="#Tan">Tan</a></li>
<li><a href="#Tanh">Tanh</a></li>
<li><a href="#ToDegrees">ToDegrees</a></li>
<li><a href="#ToRadians">ToRadians</a></li>
<li><a href="#TrendSurface">TrendSurface</a></li>
<li><a href="#TrendSurfaceVectorPoints">TrendSurfaceVectorPoints</a></li>
<li><a href="#Truncate">Truncate</a></li>
<li><a href="#TurningBandsSimulation">TurningBandsSimulation</a></li>
<li><a href="#Xor">Xor</a></li>
<li><a href="#ZScores">ZScores</a></li>
<li><a href="#ZonalStatistics">ZonalStatistics</a></li>
</ul>
<p><a name="AbsoluteValue"></a></p>
<a class="header" href="#absolutevalue" id="absolutevalue"><h1>AbsoluteValue</h1></a>
<p>Calculates the absolute value of every cell in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.absolute_value(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AbsoluteValue -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/abs.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Add"></a></p>
<a class="header" href="#add" id="add"><h1>Add</h1></a>
<p>This tool creates a new raster in which each grid cell is equal to the addition of the corresponding grid
cells in two input rasters or one input raster and a constant value. If two images are input, both
images must possess the same number of rows and columns and spatial extent, as the analysis will be
carried out on a cell-by-cell basis. If a grid cell contains a <strong>NoData</strong> value in either of the input
images, the cell will be excluded from the analysis.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a>, <a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a>, <a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a>, <a href="./mathand_stats_tools.html#inplaceadd"><strong>InPlaceAdd</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.add(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Add -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/add.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="And"></a></p>
<a class="header" href="#and" id="and"><h1>And</h1></a>
<p>Performs a logical AND operator on two Boolean raster images.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.And(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=And -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/and.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 1, 2017</p>
<p><a name="Anova"></a></p>
<a class="header" href="#anova" id="anova"><h1>Anova</h1></a>
<p>Performs an analysis of variance (ANOVA) test on a raster dataset.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--features         </td><td> Feature definition (or class) raster</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.anova(
    i, 
    features, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Anova -v --wd=&quot;/path/to/data/&quot; ^
-i=data.tif --features=classes.tif -o=anova.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/anova.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: September 23, 2017</p>
<p><a name="ArcCos"></a></p>
<a class="header" href="#arccos" id="arccos"><h1>ArcCos</h1></a>
<p>Returns the inverse cosine (arccos) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.arc_cos(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ArcCos -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/arccos.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="ArcSin"></a></p>
<a class="header" href="#arcsin" id="arcsin"><h1>ArcSin</h1></a>
<p>Returns the inverse sine (arcsin) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.arc_sin(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ArcSin -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/arcsin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="ArcTan"></a></p>
<a class="header" href="#arctan" id="arctan"><h1>ArcTan</h1></a>
<p>Returns the inverse tangent (arctan) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.arc_tan(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ArcTan -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/arctan.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Atan2"></a></p>
<a class="header" href="#atan2" id="atan2"><h1>Atan2</h1></a>
<p>Returns the 2-argument inverse tangent (atan2).</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input_y          </td><td> Input y raster file or constant value (rise)</td></tr>
<tr><td>--input_x          </td><td> Input x raster file or constant value (run)</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.atan2(
    input_y, 
    input_x, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Atan2 -v --wd=&quot;/path/to/data/&quot; ^
--input_y='in1.tif' --input_x='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/atan2.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="AttributeCorrelation"></a></p>
<a class="header" href="#attributecorrelation" id="attributecorrelation"><h1>AttributeCorrelation</h1></a>
<p>Performs a correlation analysis on attribute fields from a vector database.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.attribute_correlation(
    i, 
    output=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AttributeCorrelation -v ^
--wd=&quot;/path/to/data/&quot; -i=file.shp -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/attribute_correlation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 29/04/2018</p>
<p><a name="AttributeHistogram"></a></p>
<a class="header" href="#attributehistogram" id="attributehistogram"><h1>AttributeHistogram</h1></a>
<p>This tool can be used to create a histogram, which is a graph displaying the frequency
distribution of data, for the values contained in a field of an input vector's attribute
table. The user must specify the name of an input vector (<code>--input</code>) and the name of one
of the fields (<code>--field</code>) contained in the associated attribute table. The tool output
(<code>--output</code>) is an HTML formated histogram analysis report. If the specified field
is non-numerical, the tool will produce a bar-chart of class frequency, similar to the
tabular output of the <a href="./mathand_stats_tools.html#listuniquevalues"><strong>ListUniqueValues</strong></a> tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#listuniquevalues"><strong>ListUniqueValues</strong></a>, <a href="./mathand_stats_tools.html#rasterhistogram"><strong>RasterHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.attribute_histogram(
    i, 
    field, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AttributeHistogram -v ^
--wd=&quot;/path/to/data/&quot; -i=lakes.shp --field=HEIGHT ^
-o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/attribute_histogram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/04/2018</p>
<p><a name="AttributeScattergram"></a></p>
<a class="header" href="#attributescattergram" id="attributescattergram"><h1>AttributeScattergram</h1></a>
<p>This tool can be used to create a <a href="https://en.wikipedia.org/wiki/Scatter_plot">scattergram</a> for
two numerical fields (<code>--fieldx</code> and <code>--fieldy</code>) contained within an input vector's attribute
table (<code>--input</code>). The user must specify the name of an input shapefile and the name of two of
the fields contained it the associated attribute table. The tool output (<code>--output</code>) is an
HTML formated report containing a graphical scattergram plot.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#attributehistogram"><strong>AttributeHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--fieldx           </td><td> Input field name in attribute table for the x-axis</td></tr>
<tr><td>--fieldy           </td><td> Input field name in attribute table for the y-axis</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
<tr><td>--trendline        </td><td> Draw the trendline</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.attribute_scattergram(
    i, 
    fieldx, 
    fieldy, 
    output, 
    trendline=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AttributeScattergram -v ^
--wd=&quot;/path/to/data/&quot; -i=lakes.shp --fieldx=HEIGHT ^
--fieldy=area -o=outfile.html --trendline 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/attribute_scattergram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/04/2018</p>
<p><a name="Ceil"></a></p>
<a class="header" href="#ceil" id="ceil"><h1>Ceil</h1></a>
<p>Returns the smallest (closest to negative infinity) value that is greater than or equal to the values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ceil(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Ceil -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/ceil.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Cos"></a></p>
<a class="header" href="#cos" id="cos"><h1>Cos</h1></a>
<p>Returns the cosine (cos) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cos(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Cos -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/cos.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Cosh"></a></p>
<a class="header" href="#cosh" id="cosh"><h1>Cosh</h1></a>
<p>Returns the hyperbolic cosine (cosh) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cosh(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Cosh -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/cosh.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="CrispnessIndex"></a></p>
<a class="header" href="#crispnessindex" id="crispnessindex"><h1>CrispnessIndex</h1></a>
<p>The Crispness Index (<em>C</em>) provides a means of quantifying the crispness, or fuzziness, of a membership
probability (MP) image. MP images describe the probability of each grid cell belonging to some feature
or class. MP images contain values ranging from 0 to 1.</p>
<p>The index, as described by Lindsay (2006), is the ratio between the sum of the squared differences (from
the image mean) in the MP image divided by the sum of the squared differences for the Boolean case in which
the total probability, summed for the image, is arranged crisply.</p>
<p><em>C</em> is closely related to a family of relative variation coefficients that measure variation in an MP
image relative to the maximum possible variation (i.e. when the total probability is arranged such that grid
cells contain only 1s or 0s). Notice that 0 &lt; <em>C</em> &lt; 1 and a low <em>C</em>-value indicates a nearly uniform spatial
distribution of any probability value, and <em>C</em> = 1 indicates a crisp spatial probability distribution,
containing only 1's and 0's.</p>
<p><em>C</em> is calculated as follows:</p>
<blockquote>
<p>C = SS_mp ∕ SS_B = [∑(pij − p-bar)^2] ∕ [ ∑pij(1 − p-bar)^2 + p2(RC − ∑pij)]</p>
</blockquote>
<p>Note that there is an error in the original published equation. Specifically, the denominator
read:</p>
<blockquote>
<p>∑pij(1 - p_bar)^2 + p_bar^2 (RC - ∑pij)</p>
</blockquote>
<p>instead of the original:</p>
<blockquote>
<p>∑pij(1 - p_bar^2) - p_bar^2 (RC - ∑pij)</p>
</blockquote>
<p><em>References</em>:</p>
<p>Lindsay, J. B. (2006). Sensitivity of channel mapping techniques to uncertainty in digital elevation data.
International Journal of Geographical Information Science, 20(6), 669-692.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Optional output html file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.crispness_index(
    i, 
    output=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CrispnessIndex -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif
&gt;&gt;./whitebox_tools -r=CrispnessIndex -v ^
--wd=&quot;/path/to/data/&quot; -o=crispness.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/crispness_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/08/2017</p>
<p><a name="CrossTabulation"></a></p>
<a class="header" href="#crosstabulation" id="crosstabulation"><h1>CrossTabulation</h1></a>
<p>This tool can be used to perform a cross-tabulation on two input raster images (<code>--i1</code> and <code>--i2</code>) containing
categorical data, i.e. classes. It will output a <a href="https://en.wikipedia.org/wiki/Contingency_table">contingency table</a>
in HTML format (<code>--output</code>). A contingency table, also known as a cross tabulation or crosstab, is a type of table
that displays the multivariate frequency distribution of the variables. These tables provide a basic picture of the
interrelation between two categorical variables and can help find interactions between them. <a href="./mathand_stats_tools.html#crosstabulation"><strong>CrossTabulation</strong></a>
can provide useful information about the nature of land-use/land-cover (LULC) changes between two dates of classified
multi-spectral satellite imagery. For example, the extent of urban expansion could be described using the information
about the extent of pixels in an 'urban' class in Date 2 that were previously assigned to other classes (e.g.
agricultural LULC categories) in the Date 1 imagery.</p>
<p>Both input images must share the same grid, as the analysis requires a comparison of a pair of images on a cell-by-cell
basis. If a grid cell contains a <strong>NoData</strong> value in either of the input images, the cell will be excluded from the
analysis.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input raster file 1</td></tr>
<tr><td>--i2, --input2    </td><td> Input raster file 1</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cross_tabulation(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CrossTabulation -v ^
--wd=&quot;/path/to/data/&quot; --i1=&quot;file1.tif&quot; --i2=&quot;file2.tif&quot; ^
-o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/cross_tabulation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/12/2017</p>
<p><a name="CumulativeDistribution"></a></p>
<a class="header" href="#cumulativedistribution" id="cumulativedistribution"><h1>CumulativeDistribution</h1></a>
<p>This tool converts the values in an input image (<code>--input</code>) into
[cumulative probabilities]<a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">cumulative distribution function</a>.
Therefore, the output raster (<code>--output</code>) will contain the cumulative probability value (0-1) of
of values equal to or less than the value in the corresponding grid cell in the input image. NoData
values in the input image are not considered during the transformation and remain NoData values in
the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#zscores"><strong>ZScores</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.cumulative_distribution(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CumulativeDistribution -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/cumulative_dist.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 22/07/2017</p>
<p><a name="Decrement"></a></p>
<a class="header" href="#decrement" id="decrement"><h1>Decrement</h1></a>
<p>This tool can be used to decrease the values of each grid cell in an input raster (<code>--input</code>)
by 1.0. Note that this tool will modify the input raster. If you would rather create a new
raster file, leaving the input unmodified, use the <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#inplacesubtract"><strong>InPlaceSubtract</strong></a>, <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.decrement(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Decrement -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/decrement.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="Divide"></a></p>
<a class="header" href="#divide" id="divide"><h1>Divide</h1></a>
<p>This tool creates a new raster in which each grid cell is equal to the division of the corresponding grid
cells in two input rasters or one input raster and a constant value. If two images are input, both
images must possess the same number of rows and columns and spatial extent, as the analysis will be
carried out on a cell-by-cell basis. If a grid cell contains a <strong>NoData</strong> value in either of the input
images, the cell will be excluded from the analysis.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a>, <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a>, <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a>, <a href="./mathand_stats_tools.html#inplacedivide"><strong>InPlaceDivide</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.divide(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Divide -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/divide.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="EqualTo"></a></p>
<a class="header" href="#equalto" id="equalto"><h1>EqualTo</h1></a>
<p>Performs a equal-to comparison operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.equal_to(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EqualTo -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/equal_to.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 1, 2017</p>
<p><a name="Exp"></a></p>
<a class="header" href="#exp" id="exp"><h1>Exp</h1></a>
<p>Returns the exponential (base e) of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.exp(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Exp -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/exp.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Exp2"></a></p>
<a class="header" href="#exp2" id="exp2"><h1>Exp2</h1></a>
<p>Returns the exponential (base 2) of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.exp2(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Exp2 -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/exp2.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Floor"></a></p>
<a class="header" href="#floor" id="floor"><h1>Floor</h1></a>
<p>Returns the largest (closest to positive infinity) value that is less than or equal to the values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.floor(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Floor -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o='output.tif' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/floor.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="GreaterThan"></a></p>
<a class="header" href="#greaterthan" id="greaterthan"><h1>GreaterThan</h1></a>
<p>Performs a greater-than comparison operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--incl_equals      </td><td> Perform a greater-than-or-equal-to operation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.greater_than(
    input1, 
    input2, 
    output, 
    incl_equals=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=GreaterThan -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif ^
--incl_equals 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/greater_than.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 1, 2017</p>
<p><a name="ImageAutocorrelation"></a></p>
<a class="header" href="#imageautocorrelation" id="imageautocorrelation"><h1>ImageAutocorrelation</h1></a>
<p>Performs Moran's I analysis on two or more input images.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--contiguity       </td><td> Contiguity type</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.image_autocorrelation(
    inputs, 
    output, 
    contiguity=&quot;Rook&quot;, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ImageAutocorrelation -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;file1.tif, file2.tif, file3.tif&quot; ^
-o=outfile.html --contiguity=Bishops 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/image_autocorrelation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: Dec. 16, 2017</p>
<p><a name="ImageCorrelation"></a></p>
<a class="header" href="#imagecorrelation" id="imagecorrelation"><h1>ImageCorrelation</h1></a>
<p>This tool can be used to estimate the Pearson product-moment correlation coefficient (<em>r</em>) between two or
more input images (<code>--inputs</code>). The <em>r</em>-value is a measure of the linear association in the variation of
the input variables (images, in this case). The coefficient ranges from -1.0, indicated a perfect negative
linear association, to 1.0, indicated a perfect positive linear association. An <em>r</em>-value of 0.0 indicates
no correlation between the test variables.</p>
<p>Note that this index is a measure of the linear association; two variables may be strongly related by a
non-linear association (e.g. a power function curve) which will lead to an apparent weak association based
on the Pearson coefficient. In fact, non-linear associations are very common among spatial variables,
e.g. terrain indices such as slope and contributing area. In such cases, it is advisable that the input
images are transformed prior to the estimation of the Pearson coefficient, or that an alternative,
non-parametric statistic be used, e.g. the Spearman rank correlation coefficient.</p>
<p>The user must specify the names of two or more input images (<code>--inputs</code>). All input images must share the
same grid, as the coefficient requires a comparison of a pair of images on a grid-cell-by-grid-cell basis.
If more than two image names are selected, the correlation coefficient will be calculated for each pair of
images and reported in the HTML output report (<code>--output</code>) as a correlation matrix. Caution must be
exercised when attempted to estimate the significance of a correlation coefficient derived from image data.
The very high <em>N</em>-value (essentially the number of pixels in the image pair) means that even small correlation
coefficients can be found to be statistically significant, despite being practically insignificant.</p>
<p><strong>NoData</strong> values in either of the two input images are ignored during the calculation of the correlation
between images.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#imageregression"><strong>ImageRegression</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.image_correlation(
    inputs, 
    output=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ImageCorrelation -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;file1.tif, file2.tif, file3.tif&quot; ^
-o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/image_correlation.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 03/09/2017</p>
<p><a name="ImageRegression"></a></p>
<a class="header" href="#imageregression" id="imageregression"><h1>ImageRegression</h1></a>
<p>This tool performs a bivariate linear regression analysis on two input raster images. The first image
(<code>--i1</code>) is considered to be the independent variable while the second image (<code>--i2</code>) is considered to
be the dependent variable in the analysis. Both input images must share the same grid, as the coefficient
requires a comparison of a pair of images on a grid-cell-by-grid-cell basis. The tool will output an HTML
report (<code>--output</code>) summarizing the regression model, an Analysis of Variance (ANOVA), and the
significance of the regression coefficients. The regression residuals can optionally be output as a new
raster image (<code>--out_residuals</code>) and the user can also optionally specify to standardize the residuals
(<code>--standardize</code>).</p>
<p>Note that the analysis performs a linear regression; two variables may be strongly related by a non-linear
association (e.g. a power function curve) which will lead to an apparently weak fitting regression model.
In fact, non-linear relations are very common among spatial variables, e.g. terrain indices such as slope
and contributing area. In such cases, it is advisable that the input images are transformed prior to the
analysis.</p>
<p><strong>NoData</strong> values in either of the two input images are ignored during the calculation of the correlation
between images.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#imagecorrelation"><strong>ImageCorrelation</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input raster file (independent variable, X)</td></tr>
<tr><td>--i2, --input2    </td><td> Input raster file (dependent variable, Y)</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file for regression summary report</td></tr>
<tr><td>--out_residuals    </td><td> Output raster regression resdidual file</td></tr>
<tr><td>--standardize      </td><td> Optional flag indicating whether to standardize the residuals map</td></tr>
<tr><td>--scattergram      </td><td> Optional flag indicating whether to output a scattergram</td></tr>
<tr><td>--num_samples      </td><td> Number of samples used to create scattergram</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.image_regression(
    input1, 
    input2, 
    output, 
    out_residuals=None, 
    standardize=False, 
    scattergram=False, 
    num_samples=1000, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ImageRegression -v ^
--wd=&quot;/path/to/data/&quot; --i1='file1.tif' --i2='file2.tif' ^
-o='outfile.html' --out_residuals='residuals.tif' ^
--standardize 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/image_regression.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/09/2017</p>
<p><a name="InPlaceAdd"></a></p>
<a class="header" href="#inplaceadd" id="inplaceadd"><h1>InPlaceAdd</h1></a>
<p>This tool performs an in-place addition, or increment operation (i.e. <code>input1 += input2</code>). The
user must specify the names of two input images (<code>--input1</code> and <code>--input2</code>) and the tool will
add the values of <code>input2</code> to the <code>input1</code> raster on a pixel-by-pixel basis. Therefore, the
<code>input1</code> raster is modified by this tool. Note that <code>input2</code> may either be an existing raster
file or a constant value. If <code>input2</code> is a raster, it must have the same dimensions (rows and
columns) as <code>input1</code>.</p>
<p>The difference between this tool and the <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a> tool is that <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a> does not modify either of its
two operands, and instead creates a new output raster to save the resultant value into.</p>
<p>If <code>input2 = 1</code>, use the <a href="./mathand_stats_tools.html#increment"><strong>Increment</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#add"><strong>Add</strong></a>, <a href="./mathand_stats_tools.html#inplacesubtract"><strong>InPlaceSubtract</strong></a>, <a href="./mathand_stats_tools.html#inplacedivide"><strong>InPlaceDivide</strong></a>, <a href="./mathand_stats_tools.html#inplacemultiply"><strong>InPlaceMultiply</strong></a>, <a href="./mathand_stats_tools.html#increment"><strong>Increment</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.in_place_add(
    input1, 
    input2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=InPlaceAdd -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif'&quot;
&gt;&gt;./whitebox_tools ^
-r=InPlaceAdd -v --wd=&quot;/path/to/data/&quot; --input1='in1.tif' ^
--input2=10.5' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/inplace_add.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/03/2018</p>
<p><a name="InPlaceDivide"></a></p>
<a class="header" href="#inplacedivide" id="inplacedivide"><h1>InPlaceDivide</h1></a>
<p>This tool performs an in-place division operation (i.e. <code>input1 /= input2</code>). The
user must specify the names of two input images (<code>--input1</code> and <code>--input2</code>) and the tool will
divide the <code>input1</code> raster by the <code>input2</code> values on a pixel-by-pixel basis. Therefore, the
<code>input1</code> raster is modified by this tool. Note that <code>input2</code> may either be an existing raster
file or a non-zero constant value. If <code>input2</code> is a raster, it must have the same dimensions (rows and
columns) as <code>input1</code>. Zero-valued pixels in <code>input2</code> will be assigned the NoData value in
<code>input1</code> after this operation.</p>
<p>The difference between this tool and the <a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a> tool is that <a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a> does not modify either of its
two operands, and instead creates a new output raster to save the resultant value into.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a>, <a href="./mathand_stats_tools.html#inplaceadd"><strong>InPlaceAdd</strong></a>, <a href="./mathand_stats_tools.html#inplacemultiply"><strong>InPlaceMultiply</strong></a>, <a href="./mathand_stats_tools.html#inplacesubtract"><strong>InPlaceSubtract</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.in_place_divide(
    input1, 
    input2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=InPlaceDivide -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif'&quot;
&gt;&gt;./whitebox_tools ^
-r=InPlaceDivide -v --wd=&quot;/path/to/data/&quot; --input1='in1.tif' ^
--input2=10.5' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/inplace_divide.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/03/2018</p>
<p><a name="InPlaceMultiply"></a></p>
<a class="header" href="#inplacemultiply" id="inplacemultiply"><h1>InPlaceMultiply</h1></a>
<p>This tool performs an in-place multiplication operation (i.e. <code>input1 *= input2</code>). The
user must specify the names of two input images (<code>--input1</code> and <code>--input2</code>) and the tool will
multiply the <code>input1</code> raster by the <code>input2</code> values on a pixel-by-pixel basis. Therefore, the
<code>input1</code> raster is modified by this tool. Note that <code>input2</code> may either be an existing raster
file or a constant value. If <code>input2</code> is a raster, it must have the same dimensions (rows and
columns) as <code>input1</code>.</p>
<p>The difference between this tool and the <a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a> tool is that <a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a> does not modify either of its
two operands, and instead creates a new output raster to save the resultant value into.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a>, <a href="./mathand_stats_tools.html#inplaceadd"><strong>InPlaceAdd</strong></a>, <a href="./mathand_stats_tools.html#inplacedivide"><strong>InPlaceDivide</strong></a>, <a href="./mathand_stats_tools.html#inplacesubtract"><strong>InPlaceSubtract</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.in_place_multiply(
    input1, 
    input2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=InPlaceMultiply -v ^
--wd=&quot;/path/to/data/&quot; --input1='in1.tif' ^
--input2='in2.tif'&quot;
&gt;&gt;./whitebox_tools -r=InPlaceMultiply -v ^
--wd=&quot;/path/to/data/&quot; --input1='in1.tif' --input2=10.5' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/inplace_multiply.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/03/2018</p>
<p><a name="InPlaceSubtract"></a></p>
<a class="header" href="#inplacesubtract" id="inplacesubtract"><h1>InPlaceSubtract</h1></a>
<p>This tool performs an in-place subtraction, or decrement operation (i.e. <code>input1 -= input2</code>). The
user must specify the names of two input images (<code>--input1</code> and <code>--input2</code>) and the tool will
subtact the values of <code>input2</code> from the <code>input1</code> raster on a pixel-by-pixel basis. Therefore, the
<code>input1</code> raster is modified by this tool. Note that <code>input2</code> may either be an existing raster
file or a constant value. If <code>input2</code> is a raster, it must have the same dimensions (rows and
columns) as <code>input1</code>.</p>
<p>The difference between this tool and the <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a> tool is that <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a> does not modify either of its
two operands, and instead creates a new output raster to save the resultant value into.</p>
<p>If <code>input2 = 1</code>, use the <a href="./mathand_stats_tools.html#decrement"><strong>Decrement</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a>, <a href="./mathand_stats_tools.html#inplaceadd"><strong>InPlaceAdd</strong></a>, <a href="./mathand_stats_tools.html#inplacedivide"><strong>InPlaceDivide</strong></a>, <a href="./mathand_stats_tools.html#inplacemultiply"><strong>InPlaceMultiply</strong></a>, <a href="./mathand_stats_tools.html#decrement"><strong>Decrement</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.in_place_subtract(
    input1, 
    input2, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=InPlaceSubtract -v ^
--wd=&quot;/path/to/data/&quot; --input1='in1.tif' ^
--input2='in2.tif'&quot;
&gt;&gt;./whitebox_tools -r=InPlaceSubtract -v ^
--wd=&quot;/path/to/data/&quot; --input1='in1.tif' --input2=10.5' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/inplace_subtract.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 18/03/2018</p>
<p><a name="Increment"></a></p>
<a class="header" href="#increment" id="increment"><h1>Increment</h1></a>
<p>This tool can be used to increase the values of each grid cell in an input raster (<code>--input</code>)
by 1.0. Note that this tool will modify the input raster. If you would rather create a new
raster file, leaving the input unmodified, use the <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a> tool instead.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#inplaceadd"><strong>InPlaceAdd</strong></a>, <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.increment(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Increment -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/increment.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="IntegerDivision"></a></p>
<a class="header" href="#integerdivision" id="integerdivision"><h1>IntegerDivision</h1></a>
<p>Performs an integer division operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.integer_division(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IntegerDivision -v ^
--wd=&quot;/path/to/data/&quot; --input1='in1.tif' --input2='in2.tif' ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/integer_division.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="IsNoData"></a></p>
<a class="header" href="#isnodata" id="isnodata"><h1>IsNoData</h1></a>
<p>This tool can be used to identify areas of NoData values within an input image.The user must specify the name
of the input and output (<code>--input</code> and <code>--output</code>) raster images. Grid cells containing the NoData value in
the input image will be assigned a value of 1.0 in the output image. All non-NoData valued grid cells will
be assigned 0.0 in the output image.</p>
<p><em>See Also</em>:</p>
<p><a href="./data_tools.html#setnodatavalue"><strong>SetNodataValue</strong></a>, <a href="./data_tools.html#convertnodatatozero"><strong>ConvertNodataToZero</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.is_no_data(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=IsNoData -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/isnodata.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="KappaIndex"></a></p>
<a class="header" href="#kappaindex" id="kappaindex"><h1>KappaIndex</h1></a>
<p>Performs a kappa index of agreement (KIA) analysis on two categorical raster files.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--i1, --input1    </td><td> Input classification raster file</td></tr>
<tr><td>--i2, --input2    </td><td> Input reference raster file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.kappa_index(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=KappaIndex -v --wd=&quot;/path/to/data/&quot; ^
--i1=class.tif --i2=reference.tif -o=kia.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/kappa_index.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: September 24, 2017</p>
<p><a name="KsTestForNormality"></a></p>
<a class="header" href="#kstestfornormality" id="kstestfornormality"><h1>KsTestForNormality</h1></a>
<p>This tool will perform a Kolmogorov-Smirnov (K-S) test for normality to evaluate
whether the frequency distribution of values within a raster image are drawn from a
Gaussian (normal) distribution. The user must specify the name of the raster image. The
test can be performed optionally on the entire image or on a random sub-sample of pixel
values of a user-specified size. In evaluating the significance of the test, it is
important to keep in mind that given a sufficiently large sample, extremely small and
non-notable differences can be found to be statistically significant. Furthermore
statistical significance says nothing about the practical significance of a difference.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--num_samples      </td><td> Number of samples. Leave blank to use whole image</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ks_test_for_normality(
    i, 
    output, 
    num_samples=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=KSTestForNormality -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.html ^
--num_samples=1000
&gt;&gt;./whitebox_tools -r=KSTestForNormality -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/ks_normality_test.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: January 2, 2018</p>
<p><a name="LessThan"></a></p>
<a class="header" href="#lessthan" id="lessthan"><h1>LessThan</h1></a>
<p>Performs a less-than comparison operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--incl_equals      </td><td> Perform a less-than-or-equal-to operation</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.less_than(
    input1, 
    input2, 
    output, 
    incl_equals=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LessThan -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif ^
--incl_equals 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/less_than.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 1, 2017</p>
<p><a name="ListUniqueValues"></a></p>
<a class="header" href="#listuniquevalues" id="listuniquevalues"><h1>ListUniqueValues</h1></a>
<p>This tool can be used to list each of the unique values contained within a categorical field
of an input vector file's attribute table. The tool outputs an HTML formated report (<code>--output</code>)
containing a table of the unique values and their frequency of occurrence within the data. The user must
specify the name of an input shapefile (<code>--input</code>) and the name of one of the fields (<code>--field</code>)
contained in the associated attribute table. The specified field <em>should not contained floating-point
numerical data</em>, since the number of categories will likely equal the number of records, which may be
quite large. The tool effectively provides tabular output that is similar to the graphical output
provided by the <a href="./mathand_stats_tools.html#attributehistogram"><strong>AttributeHistogram</strong></a> tool, which, however, can be applied to continuous data.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#attributehistogram"><strong>AttributeHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.list_unique_values(
    i, 
    field, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ListUniqueValues -v ^
--wd=&quot;/path/to/data/&quot; -i=lakes.shp --field=HEIGHT ^
-o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/list_unique_values.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/04/2018</p>
<p><a name="Ln"></a></p>
<a class="header" href="#ln" id="ln"><h1>Ln</h1></a>
<p>Returns the natural logarithm of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.ln(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Ln -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/ln.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Log10"></a></p>
<a class="header" href="#log10" id="log10"><h1>Log10</h1></a>
<p>Returns the base-10 logarithm of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.log10(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Log10 -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/log10.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Log2"></a></p>
<a class="header" href="#log2" id="log2"><h1>Log2</h1></a>
<p>Returns the base-2 logarithm of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.log2(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Log2 -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/log2.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Max"></a></p>
<a class="header" href="#max" id="max"><h1>Max</h1></a>
<p>Performs a MAX operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.max(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Max -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/max.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Min"></a></p>
<a class="header" href="#min" id="min"><h1>Min</h1></a>
<p>Performs a MIN operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.min(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Min -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/min.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Modulo"></a></p>
<a class="header" href="#modulo" id="modulo"><h1>Modulo</h1></a>
<p>Performs a modulo operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.modulo(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Modulo -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/modulo.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Multiply"></a></p>
<a class="header" href="#multiply" id="multiply"><h1>Multiply</h1></a>
<p>This tool creates a new raster in which each grid cell is equal to the multiplication (product) of the corresponding grid
cells in two input rasters or one input raster and a constant value. If two images are input, both
images must possess the same number of rows and columns and spatial extent, as the analysis will be
carried out on a cell-by-cell basis. If a grid cell contains a <strong>NoData</strong> value in either of the input
images, the cell will be excluded from the analysis.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a>, <a href="./mathand_stats_tools.html#add"><strong>Add</strong></a>, <a href="./mathand_stats_tools.html#subtract"><strong>Subtract</strong></a>, <code>InPlaceMulitply</code></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.multiply(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Multiply -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/multiply.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="Negate"></a></p>
<a class="header" href="#negate" id="negate"><h1>Negate</h1></a>
<p>Changes the sign of values in a raster or the 0-1 values of a Boolean raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.negate(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Negate -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/negate.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Not"></a></p>
<a class="header" href="#not" id="not"><h1>Not</h1></a>
<p>Performs a logical NOT operator on two Boolean raster images.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.Not(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Not -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/not.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 2, 2017</p>
<p><a name="NotEqualTo"></a></p>
<a class="header" href="#notequalto" id="notequalto"><h1>NotEqualTo</h1></a>
<p>Performs a not-equal-to comparison operation on two rasters or a raster and a constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.not_equal_to(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=NotEqualTo -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/not_equal_to.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 1, 2017</p>
<p><a name="Or"></a></p>
<a class="header" href="#or" id="or"><h1>Or</h1></a>
<p>Performs a logical OR operator on two Boolean raster images.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.Or(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Or -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/or.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 2, 2017</p>
<p><a name="Power"></a></p>
<a class="header" href="#power" id="power"><h1>Power</h1></a>
<p>Raises the values in grid cells of one rasters, or a constant value, by values in another raster or constant value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.power(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Power -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/power.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="PrincipalComponentAnalysis"></a></p>
<a class="header" href="#principalcomponentanalysis" id="principalcomponentanalysis"><h1>PrincipalComponentAnalysis</h1></a>
<p>Principal component analysis (PCA) is a common data reduction technique that is used to reduce the dimensionality of
multi-dimensional space. In the field of remote sensing, PCA is often used to reduce the number of bands of
multi-spectral, or hyper-spectral, imagery. Image correlation analysis often reveals a substantial level of correlation
among bands of multi-spectral imagery. This correlation represents data redundancy, i.e. fewer images than the number
of bands are required to represent the same information, where the information is related to variation within the imagery.
PCA transforms the original data set of <em>n</em> bands into <em>n</em> 'component' images, where each component image is uncorrelated
with all other components. The technique works by transforming the axes of the multi-spectral space such that it coincides
with the directions of greatest correlation. Each of these new axes are orthogonal to one another, i.e. they are at right
angles. PCA is therefore a type of coordinate system transformation. The PCA component images are arranged such that the
greatest amount of variance (or information) within the original data set, is contained within the first component and the
amount of variance decreases with each component. It is often the case that the majority of the information contained in a
multi-spectral data set can be represented by the first three or four PCA components. The higher-order components are often
associated with noise in the original data set.</p>
<p>The user must specify the names of the multiple input images (<code>--inputs</code>). Additionally, the user must specify whether to
perform a standardized PCA (<code>--standardized</code>) and the number of output components (<code>--num_comp</code>) to generate (all components
will be output unless otherwise specified). A standardized PCA is performed using the correlation matrix rather than the
variance-covariance matrix. This is appropriate when the variances in the input images differ substantially, such as would be
the case if they contained values that were recorded in different units (e.g. feet and meters) or on different scales (e.g.
8-bit vs. 16 bit).</p>
<p>Several outputs will be generated when the tool has completed. The PCA report will be embeded within an output (<code>--output</code>)
HTML file, which should be automatically displayed after the tool has completed. This report contains useful data summarizing
the results of the PCA, including the explained variances of each factor, the Eigenvalues and Eigenvectors associated with
factors, the factor loadings, and a scree plot. The first table that is in the PCA report lists the amount of explained
variance (in non-cumulative and cumulative form), the Eigenvalue, and the Eigenvector for each component. Each of the PCA
components refer to the newly created, transformed images that are created by running the tool. The amount of explained
variance associated with each component can be thought of as a measure of how much information content within the original
multi-spectral data set that a component has. The higher this value is, the more important the component is. This same
information is presented in graphical form in the <em>scree plot</em>, found at the bottom of the PCA report. The Eigenvalue is
another measure of the information content of a component and the eigenvector describes the mathematical transformation
(rotation coordinates) that correspond to a particular component image.</p>
<p>Factor loadings are also output in a table within the PCA text report (second table). These loading values describe the
correlation (i.e. <em>r</em> values) between each of the PCA components (columns) and the original images (rows). These values
show you how the information contained in an image is spread among the components. An analysis of factor loadings can be
reveal useful information about the data set. For example, it can help to identify groups of similar images.</p>
<p>PCA is used to reduce the number of band images necessary for classification (i.e. as a data reduction technique), for
noise reduction, and for change detection applications. When used as a change detection technique, the major PCA components
tend to be associated with stable elements of the data set while variance due to land-cover change tend to manifest in the
high-order, 'change components'. When used as a noise reduction technique, an inverse PCA is generally performed, leaving
out one or more of the high-order PCA components, which account for noise variance.</p>
<p>Note: the current implementation reads every raster into memory at one time. This is because of the calculation of the
co-variances. As such, if the entire image stack cannot fit in memory, the tool will likely experience an out-ofs-memory error.
This tool should be run using the <code>--wd</code> flag to spectify the working directory into which the component images will be
written.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --inputs       </td><td> Input raster files</td></tr>
<tr><td>--out_html, --output</td><td> Output HTML report file</td></tr>
<tr><td>--num_comp         </td><td> Number of component images to output; &lt;= to num. input images</td></tr>
<tr><td>--standardized     </td><td> Perform standardized PCA?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.principal_component_analysis(
    inputs, 
    output, 
    num_comp=None, 
    standardized=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PrincipalComponentAnalysis -v ^
--wd='/path/to/data/' -i='image1.tif;image2.tif;image3.tif' ^
--output=report.html --num_comp=3 --standardized 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/principal_component_analysis.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 15/03/2018</p>
<p><a name="Quantiles"></a></p>
<a class="header" href="#quantiles" id="quantiles"><h1>Quantiles</h1></a>
<p>Transforms raster values into quantiles.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--num_quantiles    </td><td> Number of quantiles</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.quantiles(
    i, 
    output, 
    num_quantiles=5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Quantiles -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --num_quantiles=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/quantiles.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="RandomField"></a></p>
<a class="header" href="#randomfield" id="randomfield"><h1>RandomField</h1></a>
<p>This tool can be used to a raster image filled with random values drawn from a standard normal distribution.
The values range from appoximately -4.0 to 4.0, with a mean of 0 and a standard deviation of 1.0. The
dimensions and georeferencing of the output random field (<code>--output</code>) are based on an existing, user-specified
raster grid (<code>--base</code>). Note that the output field will not possess any spatial autocorrelation. If spatially
autocorrelated random fields are desired, the <a href="./mathand_stats_tools.html#turningbandssimulation"><strong>TurningBandsSimulation</strong></a> tool is more appropriate, or alternatively,
the <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a> tool may be used to force spatial autocorrelation onto the distribution of the
<a href="./mathand_stats_tools.html#randomfield"><strong>RandomField</strong></a> tool.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#turningbandssimulation"><strong>TurningBandsSimulation</strong></a>, <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base         </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.random_field(
    base, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RandomField -v --wd=&quot;/path/to/data/&quot; ^
--base=in.tif -o=out.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/random_field.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="RandomSample"></a></p>
<a class="header" href="#randomsample" id="randomsample"><h1>RandomSample</h1></a>
<p>This tool can be used to create a random sample of grid cells. The user specifies
the base raster file, which is used to determine the grid dimensions and georeference
information for the output raster, and the number of sample random samples (n). The
output grid will contain n non-zero grid cells, randomly distributed throughout the
raster grid, and a background value of zero. This tool is useful when performing
statistical analyses on raster images when you wish to obtain a random sample of data.</p>
<p>Only valid, non-nodata, cells in the base raster will be sampled.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base         </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--num_samples      </td><td> Number of samples</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.random_sample(
    base, 
    output, 
    num_samples=1000, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RandomSample -v --wd=&quot;/path/to/data/&quot; ^
--base=in.tif -o=out.tif --num_samples=1000 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/random_sample.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: January 2, 2018</p>
<p><a name="RasterHistogram"></a></p>
<a class="header" href="#rasterhistogram" id="rasterhistogram"><h1>RasterHistogram</h1></a>
<p>This tool produces a histogram (i.e. a frequency distribution graph) for the values contained within
an input raster file (<code>--input</code>). The histogram will be embeded within an output (<code>--output</code>)
HTML file, which should be automatically displayed after the tool has completed.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#attributehistogram"><strong>AttributeHistogram</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file (default name will be based on input file if unspecified)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_histogram(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterHistogram -v ^
--wd=&quot;/path/to/data/&quot; -i=&quot;file1.tif&quot; -o=outfile.html 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/raster_histogram.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/12/2017</p>
<p><a name="RasterSummaryStats"></a></p>
<a class="header" href="#rastersummarystats" id="rastersummarystats"><h1>RasterSummaryStats</h1></a>
<p>This tool outputs distribution summary statistics for input raster images (<code>--input</code>).
The distribution statistics include the raster minimum, maximum, range, total, mean,
variance, and standard deviation. These summary statistics are output to the system <code>stdout</code>.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_summary_stats(
    i, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterSummaryStats -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/raster_summary_stats.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="Reciprocal"></a></p>
<a class="header" href="#reciprocal" id="reciprocal"><h1>Reciprocal</h1></a>
<p>Returns the reciprocal (i.e. 1 / z) of values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.reciprocal(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Reciprocal -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/reciprocal.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="RescaleValueRange"></a></p>
<a class="header" href="#rescalevaluerange" id="rescalevaluerange"><h1>RescaleValueRange</h1></a>
<p>Performs a min-max contrast stretch on an input greytone image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--out_min_val      </td><td> New minimum value in output image</td></tr>
<tr><td>--out_max_val      </td><td> New maximum value in output image</td></tr>
<tr><td>--clip_min         </td><td> Optional lower tail clip value</td></tr>
<tr><td>--clip_max         </td><td> Optional upper tail clip value</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.rescale_value_range(
    i, 
    output, 
    out_min_val, 
    out_max_val, 
    clip_min=None, 
    clip_max=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RescaleValueRange -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif ^
--out_min_val=0.0 --out_max_val=1.0
&gt;&gt;./whitebox_tools ^
-r=RescaleValueRange -v --wd=&quot;/path/to/data/&quot; -i=input.tif ^
-o=output.tif --out_min_val=0.0 --out_max_val=1.0 ^
--clip_min=45.0 --clip_max=200.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/rescale_value_range.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: September 10, 2017</p>
<p><a name="RootMeanSquareError"></a></p>
<a class="header" href="#rootmeansquareerror" id="rootmeansquareerror"><h1>RootMeanSquareError</h1></a>
<p>This tool calculates the root-mean-square-error (RMSE) or root-mean-square-difference (RMSD) from two
input rasters. If the two input rasters possess the same number of rows and columns, the RMSE is
calucated on a cell-by-cell basis, otherwise bilinear resampling is used. In addition to RMSE,
the tool also reports other common accuracy statistics including the mean verical error, the
95% confidence limit (RMSE x 1.96), and the 90% linear error (LE90), which is the 90% percentile of
the residuals between two raster surfaces. The LE90 is the most robust of the reported accuracy
statistics when the residuals are non-Gaussian. The LE90 requires sorting the residual values, which
can be a relatively slow operation for larger rasters.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--base             </td><td> Input base raster file used for comparison</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.root_mean_square_error(
    i, 
    base, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RootMeanSquareError -v ^
--wd=&quot;/path/to/data/&quot; -i=DEM.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/root_mean_square_error.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: September 18, 2017</p>
<p><a name="Round"></a></p>
<a class="header" href="#round" id="round"><h1>Round</h1></a>
<p>Rounds the values in an input raster to the nearest integer value.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.round(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Round -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/round.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Sin"></a></p>
<a class="header" href="#sin" id="sin"><h1>Sin</h1></a>
<p>Returns the sine (sin) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sin(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Sin -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/sin.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Sinh"></a></p>
<a class="header" href="#sinh" id="sinh"><h1>Sinh</h1></a>
<p>Returns the hyperbolic sine (sinh) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.sinh(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Sinh -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/sinh.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Square"></a></p>
<a class="header" href="#square" id="square"><h1>Square</h1></a>
<p>Squares the values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.square(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Square -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/square.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="SquareRoot"></a></p>
<a class="header" href="#squareroot" id="squareroot"><h1>SquareRoot</h1></a>
<p>Returns the square root of the values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.square_root(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SquareRoot -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/sqrt.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="Subtract"></a></p>
<a class="header" href="#subtract" id="subtract"><h1>Subtract</h1></a>
<p>This tool creates a new raster in which each grid cell is equal to the subtraction (difference) of the corresponding grid
cells in two input rasters or one input raster and a constant value. If two images are input, both
images must possess the same number of rows and columns and spatial extent, as the analysis will be
carried out on a cell-by-cell basis. If a grid cell contains a <strong>NoData</strong> value in either of the input
images, the cell will be excluded from the analysis.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#add"><strong>Add</strong></a>,  <a href="./mathand_stats_tools.html#divide"><strong>Divide</strong></a>, <a href="./mathand_stats_tools.html#multiply"><strong>Multiply</strong></a>, <a href="./mathand_stats_tools.html#inplacesubtract"><strong>InPlaceSubtract</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file or constant value</td></tr>
<tr><td>--input2           </td><td> Input raster file or constant value</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.subtract(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Subtract -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/subtract.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 05/07/2017</p>
<p><a name="Tan"></a></p>
<a class="header" href="#tan" id="tan"><h1>Tan</h1></a>
<p>Returns the tangent (tan) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tan(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Tan -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/tan.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="Tanh"></a></p>
<a class="header" href="#tanh" id="tanh"><h1>Tanh</h1></a>
<p>Returns the hyperbolic tangent (tanh) of each values in a raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tanh(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Tanh -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/tanh.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="ToDegrees"></a></p>
<a class="header" href="#todegrees" id="todegrees"><h1>ToDegrees</h1></a>
<p>Converts a raster from radians to degrees.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.to_degrees(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ToDegrees -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/to_degrees.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="ToRadians"></a></p>
<a class="header" href="#toradians" id="toradians"><h1>ToRadians</h1></a>
<p>Converts a raster from degrees to radians.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.to_radians(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ToRadians -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/to_radians.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="TrendSurface"></a></p>
<a class="header" href="#trendsurface" id="trendsurface"><h1>TrendSurface</h1></a>
<p>This tool can be used to interpolate a trend surface from a raster image. The
technique uses a polynomial, least-squares regression analysis. The user must
specify the name of the input raster file. In addition, the user must specify
the polynomial order (1 to 10) for the analysis. A first-order polynomial is a
planar surface with no curvature. As the polynomial order is increased, greater
flexibility is allowed in the fitted surface. Although polynomial orders as high
as 10 are accepted, numerical instability in the analysis often creates artifacts
in trend surfaces of orders greater than 5. The operation will display a text
report on completion, in addition to the output raster image. The report will
list each of the coefficient values and the r-square value. Note that the entire
raster image must be able to fit into computer memory, limiting the use of this
tool to relatively small rasters. The Trend Surface (Vector Points) tool can be
used instead if the input data is vector points contained in a shapefile.</p>
<p>Numerical stability is enhanced by transforming the x, y, z data by their minimum
values before performing the regression analysis. These transform parameters
are also reported in the output report.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--order            </td><td> Polynomial order (1 to 10)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.trend_surface(
    i, 
    output, 
    order=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TrendSurface -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o='output.tif' --order=2 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/trend_surface.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 30/04/2018</p>
<p><a name="TrendSurfaceVectorPoints"></a></p>
<a class="header" href="#trendsurfacevectorpoints" id="trendsurfacevectorpoints"><h1>TrendSurfaceVectorPoints</h1></a>
<p>This tool can be used to interpolate a trend surface from a vector points file. The
technique uses a polynomial, least-squares regression analysis. The user must specify
the name of the input shapefile, which must be of a 'Points' base ShapeType and select
the attribute in the shapefile's associated attribute table for which to base the trend
surface analysis. The attribute must be numerical. In addition, the user must specify
the polynomial order (1 to 10) for the analysis. A first-order polynomial is a planar
surface with no curvature. As the polynomial order is increased, greater flexibility is
allowed in the fitted surface. Although polynomial orders as high as 10 are accepted,
numerical instability in the analysis often creates artifacts in trend surfaces of orders
greater than 5. The operation will display a text report on completion, in addition to
the output raster image. The report will list each of the coefficient values and the
r-square value. The Trend Surface tool can be used instead if the input data is a raster
image.</p>
<p>Numerical stability is enhanced by transforming the x, y, z data by their minimum
values before performing the regression analysis. These transform parameters
are also reported in the output report.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input vector Points file</td></tr>
<tr><td>--field            </td><td> Input field name in attribute table</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--order            </td><td> Polynomial order (1 to 10)</td></tr>
<tr><td>--cell_size        </td><td> Optionally specified cell size of output raster. Not used when base raster is specified</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.trend_surface_vector_points(
    i, 
    field, 
    output, 
    cell_size, 
    order=1, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TrendSurfaceVectorPoints -v ^
--wd=&quot;/path/to/data/&quot; -i='input.shp' --field=ELEV ^
-o='output.tif' --order=2 --cell_size=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/trend_surface_vector_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/05/2018</p>
<p><a name="Truncate"></a></p>
<a class="header" href="#truncate" id="truncate"><h1>Truncate</h1></a>
<p>Truncates the values in a raster to the desired number of decimal places.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--num_decimals     </td><td> Number of decimals left after truncation (default is zero)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.truncate(
    i, 
    output, 
    num_decimals=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Truncate -v --wd=&quot;/path/to/data/&quot; ^
-i='input.tif' -o=output.tif --num_decimals=2 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/truncate.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="TurningBandsSimulation"></a></p>
<a class="header" href="#turningbandssimulation" id="turningbandssimulation"><h1>TurningBandsSimulation</h1></a>
<p>This tool can be used to create a random field using the turning bands algorithm. The user must specify
the name of a base raster image (<code>--base</code>) from which the output raster will derive its geographical
information, dimensions (rows and columns), and other information. In addition, the range (<code>--range</code>), in
x-y units, must be specified. The range determines the correlation length of the resulting field. For a
good description of how the algorithm works, see Carr (2002). The turning bands method creates a number
of 1-D simulations (called bands) and fuses these together to create a 2-D error field. There is no
natural stopping condition in this process, so the user must specify the number of bands to create
(<code>--iterations</code>). The default value of 1000 iterations is reasonable. The fewer iterations used, the
more prevalent the 1-D simulations will be in the output error image, effectively creating artifacts.
Run time increases with the number of iterations.</p>
<p>Turning bands simulation is a commonly applied technique in Monte Carlo style simulations of uncertainty.
As such, it is frequently run many times during a simulation (often 1000s of times). When this is the
case, algorithm performance and efficiency are key considerations. One alternative method to efficiently
generate spatially autcorrelated random fields is to apply the <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a> tool to the
output of the <a href="./mathand_stats_tools.html#randomfield"><strong>RandomField</strong></a> tool. This can be used to generate a random field with the desired spatial
characteristics and frequency distribution. This is the alternative approach used by the
<a href="./hydrological_analysis.html#stochasticdepressionanalysis"><strong>StochasticDepressionAnalysis</strong></a> tool.</p>
<p><em>Reference</em>:</p>
<p>Carr, J. R. (2002). Data visualization in the geosciences. Upper Saddle River, NJ: Prentice Hall. pp. 267.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#randomfield"><strong>RandomField</strong></a>, <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a>, <a href="./hydrological_analysis.html#stochasticdepressionanalysis"><strong>StochasticDepressionAnalysis</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --base         </td><td> Input base raster file</td></tr>
<tr><td>-o, --output       </td><td> Output file</td></tr>
<tr><td>--range            </td><td> The field's range, in xy-units, related to the extent of spatial autocorrelation</td></tr>
<tr><td>--iterations       </td><td> The number of iterations</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.turning_bands_simulation(
    base, 
    output, 
    range, 
    iterations=1000, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TurningBandsSimulation -v ^
--wd=&quot;/path/to/data/&quot; --base=in.tif -o=out.tif --range=850.0 ^
--iterations=2500 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/turning_bands.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 14/07/2017</p>
<p><a name="Xor"></a></p>
<a class="header" href="#xor" id="xor"><h1>Xor</h1></a>
<p>This tool is a Boolean operator, i.e. it works on <em>True</em> or <em>False</em> (1 and 0) values. Grid cells for which
THE FIRST input raster (<code>--input1</code>) has a <em>True</em> value BUT NOT THE SECOND raster (<code>--input2</code>) are assigned
1 in the output raster, otherwise grid cells are assigned a value of 0. All non-zero values in the input
rasters are considered to be <em>True</em>, while all zero-valued grid cells are considered to be <em>False</em>. Grid
cells containing <strong>NoData</strong> values in either of the input rasters will be assigned a <strong>NoData</strong> value in
the output raster (<code>--output</code>).</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#or"><strong>Or</strong></a>, <a href="./mathand_stats_tools.html#and"><strong>And</strong></a>, <a href="./mathand_stats_tools.html#not"><strong>Not</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--input1           </td><td> Input raster file</td></tr>
<tr><td>--input2           </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.xor(
    input1, 
    input2, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=Xor -v --wd=&quot;/path/to/data/&quot; ^
--input1='in1.tif' --input2='in2.tif' -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/xor.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/07/2017</p>
<p><a name="ZScores"></a></p>
<a class="header" href="#zscores" id="zscores"><h1>ZScores</h1></a>
<p>This tool will transform the values in an input raster image (<code>--input</code>) into
<a href="https://en.wikipedia.org/wiki/Standard_score">z-scores</a>. Z-scores are also called standard scores,
normal scores, or z-values. A z-score is a dimensionless quantity that is calculated by subtracting
the mean from an individual raw value and then dividing the difference by the standard deviation.
This conversion process is called <em>standardizing</em> or <em>normalizing</em> and the result is sometimes referred
to as a standardized variable. The mean and standard deviation are estimated using all values in the
input image except for NoData values. The input image should not have a Boolean or categorical data
scale, i.e. it should be on a continuous scale.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#cumulativedistribution"><strong>CumulativeDistribution</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.z_scores(
    i, 
    output, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ZScores -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/zscores.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 01/07/2017</p>
<p><a name="ZonalStatistics"></a></p>
<a class="header" href="#zonalstatistics" id="zonalstatistics"><h1>ZonalStatistics</h1></a>
<p>This tool can be used to extract common descriptive statistics associated with the distribution
of some underlying data raster based on feature units defined by a feature definition raster.
For example, this tool can be used to measure the maximum or average slope gradient (data image)
for each of a group of watersheds (feature definitions). Although the data raster can contain any
type of data, the feature definition raster must be categorical, i.e. it must define area entities
using integer values.</p>
<p>The <code>--stat</code> parameter can take the values, 'mean', 'median', 'minimum', 'maximum', 'range',
'standard deviation', or 'total'.</p>
<p>If an output image name is specified, the tool will assign the descriptive statistic value to
each of the spatial entities defined in the feature definition raster. If text output is selected,
an HTML table will be output, which can then be readily copied into a spreadsheet program for
further analysis. This is a very powerful and useful tool for creating numerical summary data from
spatial data which can then be interrogated using statistical analyses. At least one output type
(image or text) must be specified for the tool to operate.</p>
<p>NoData values in either of the two input images are ignored during the calculation of the
descriptive statistic.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input data raster file</td></tr>
<tr><td>--features         </td><td> Input feature definition raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--stat             </td><td> Statistic to extract, including 'mean', 'median', 'minimum', 'maximum', 'range', 'standard deviation', and 'total'</td></tr>
<tr><td>--out_table        </td><td> Output HTML Table file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.zonal_statistics(
    i, 
    features, 
    output=None, 
    stat=&quot;mean&quot;, 
    out_table=None, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ZonalStatistics -v ^
--wd=&quot;/path/to/data/&quot; -i='input.tif' --features='groups.tif' ^
-o='output.tif' --stat='minimum'
&gt;&gt;./whitebox_tools ^
-r=ZonalStatistics -v --wd=&quot;/path/to/data/&quot; -i='input.tif' ^
--features='groups.tif' --out_table='output.html' 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/math_stat_analysis/zonal_statistics.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: Dec. 15, 2017</p>
<a class="header" href="#stream-network-analysis" id="stream-network-analysis"><h1>Stream Network Analysis</h1></a>
<ul>
<li><a href="#DistanceToOutlet">DistanceToOutlet</a></li>
<li><a href="#ExtractStreams">ExtractStreams</a></li>
<li><a href="#ExtractValleys">ExtractValleys</a></li>
<li><a href="#FarthestChannelHead">FarthestChannelHead</a></li>
<li><a href="#FindMainStem">FindMainStem</a></li>
<li><a href="#HackStreamOrder">HackStreamOrder</a></li>
<li><a href="#HortonStreamOrder">HortonStreamOrder</a></li>
<li><a href="#LengthOfUpstreamChannels">LengthOfUpstreamChannels</a></li>
<li><a href="#LongProfile">LongProfile</a></li>
<li><a href="#LongProfileFromPoints">LongProfileFromPoints</a></li>
<li><a href="#RasterStreamsToVector">RasterStreamsToVector</a></li>
<li><a href="#RasterizeStreams">RasterizeStreams</a></li>
<li><a href="#RemoveShortStreams">RemoveShortStreams</a></li>
<li><a href="#ShreveStreamMagnitude">ShreveStreamMagnitude</a></li>
<li><a href="#StrahlerStreamOrder">StrahlerStreamOrder</a></li>
<li><a href="#StreamLinkClass">StreamLinkClass</a></li>
<li><a href="#StreamLinkIdentifier">StreamLinkIdentifier</a></li>
<li><a href="#StreamLinkLength">StreamLinkLength</a></li>
<li><a href="#StreamLinkSlope">StreamLinkSlope</a></li>
<li><a href="#StreamSlopeContinuous">StreamSlopeContinuous</a></li>
<li><a href="#TopologicalStreamOrder">TopologicalStreamOrder</a></li>
<li><a href="#TributaryIdentifier">TributaryIdentifier</a></li>
</ul>
<p><a name="DistanceToOutlet"></a></p>
<a class="header" href="#distancetooutlet" id="distancetooutlet"><h1>DistanceToOutlet</h1></a>
<p>This tool calculates the distance of stream grid cells to the channel network outlet cell for each grid cell belonging to a
raster stream network. The user must specify the name of a raster containing streams data (<code>--streams</code>), where
stream grid cells are denoted by all positive non-zero values, and a D8 flow pointer (i.e. flow direction) raster
(<code>--d8_pntr</code>). The pointer image is used to traverse the stream network and must only be created using the D8 algorithm.
Stream cells are designated in the streams image as all values
greater than zero. Thus, all non-stream or background grid cells are commonly assigned either zeros or NoData
values. Background cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code>
parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#downslopedistancetostream"><strong>DownslopeDistanceToStream</strong></a>, <a href="./stream_network_analysis.html#lengthofupstreamchannels"><strong>LengthOfUpstreamChannels</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.distance_to_outlet(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DistanceToOutlet -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=DistanceToOutlet -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/dist_to_outlet.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 13/07/2017</p>
<p><a name="ExtractStreams"></a></p>
<a class="header" href="#extractstreams" id="extractstreams"><h1>ExtractStreams</h1></a>
<p>This tool can be used to extract, or map, the likely stream cells from an input flow-accumulation image
(<code>--flow_accum</code>). The algorithm applies a threshold to the input flow accumulation image such that streams
are considered to be all grid cells with accumulation values greater than the specified threshold
(<code>--threshold</code>). As such, this threshold represents the minimum area (area is used here as a surrogate
for discharge) required to <em>initiate and maintain a channel</em>. Smaller threshold values result in more
extensive stream networks and vice versa. Unfortunately there is very little guidance regarding an appropriate
method for determining the channel initiation area threshold. As such, it is frequently determined either by
examining map or imagery data or by experimentation until a suitable or desirable channel network is
identified. Notice that the threshold value will be unique for each landscape and dataset (including source
and grid resolution), further complicating its <em>a priori</em> determination. There is also evidence that in some
landscape the threshold is a combined upslope area-slope function. Generally, a lower threshold is appropriate
in humid climates and a higher threshold is appropriate in areas underlain by more resistant bedrock. Climate
and bedrock resistance are two factors related to drainage density, i.e. the extent to which a landscape is
dissected by drainage channels.</p>
<p>The background value of the ouput raster (<code>--output</code>) will be the NoData value unless the <code>--zero_background</code>
flag is specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./mathand_stats_tools.html#greaterthan"><strong>GreaterThan</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--flow_accum       </td><td> Input raster D8 flow accumulation file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--threshold        </td><td> Threshold in flow accumulation values for channelization</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_streams(
    flow_accum, 
    output, 
    threshold, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractStreams -v --wd=&quot;/path/to/data/&quot; ^
--flow_accum='d8accum.tif' -o='output.tif' --threshold=100.0 ^
--zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/extract_streams.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="ExtractValleys"></a></p>
<a class="header" href="#extractvalleys" id="extractvalleys"><h1>ExtractValleys</h1></a>
<p>This tool can be used to extract channel networks from an input digital elevation models (<code>--dem</code>) using
one of three techniques that are based on local topography alone.</p>
<p>The Lindsay (2006) 'lower-quartile' method (<code>--variant='LQ'</code>) algorithm is a type of 'valley recognition'
method. Other channel mapping methods, such as the Johnston and Rosenfeld (1975) algorithm, experience
problems because channel profiles are not always 'v'-shaped, nor are they always apparent in small
3 x 3 windows. The lower-quartile method was developed as an alternative and more flexible valley
recognition channel mapping technique. The lower-quartile method operates by running a filter over the
DEM that calculates the percentile value of the centre cell with respect to the distribution of
elevations within the filter window. The roving window is circular, the diameter of which should reflect
the topographic variation of the area (e.g. the channel width or average hillslope length). If this variant
is selected, the user must specify the filter size (<code>--filter</code>), in pixels, and this value should be an odd
number (e.g. 3, 5, 7, etc.). The appropriateness of the selected window diameter will depend on the grid
resolution relative to the scale of topographic features. Cells that are within the lower quartile of the
distribution of elevations of their neighbourhood are flagged. Thus, the algorithm identifies grid cells
that are in relatively low topographic positions at a local scale. This approach to channel mapping is only
appropriate in fluvial landscapes. In regions containing numerous lakes and wetlands, the algorithm will
pick out the edges of features.</p>
<p>The Johnston and Rosenfeld (1975) algorithm (<code>--variant='JandR'</code>) is a type of 'valley recognition' method
and operates as follows: channel cells are flagged in a 3 x 3 window if the north and south neighbours are
higher than the centre grid cell or if the east and west neighbours meet this same criterion. The group of
cells that are flagged after one pass of the roving window constituted the drainage network. This method is
best applied to DEMs that are relatively smooth and do not exhibit high levels of short-range roughness. As
such, it may be desirable to use a smoothing filter before applying this tool. The <code>FeaturePreservingDenoise</code>
is a good option for removing DEM roughness while preserving the topographic information contain in
breaks-in-slope (i.e. edges).</p>
<p>The Peucker and Douglas (1975) algorithm (<code>--variant='PandD'</code>) is one of the simplest and earliest algorithms
for topography-based network extraction. Their 'valley recognition' method operates by passing a 2 x 2 roving
window over a DEM and flagging the highest grid cell in each group of four. Once the window has passed over
the entire DEM, channel grid cells are left unflagged. This method is also best applied to DEMs that are relatively
smooth and do not exhibit high levels of short-range roughness. Pre-processing the DEM with the <code>FeaturePreservingDenoise</code>
tool may also be useful when applying this method.</p>
<p>Each of these methods of extracting valley networks result in line networks that can be wider than a single
grid cell. As such, it is often desirable to thin the resulting network using a line-thinning algorithm.
The option to perform line-thinning is provided by the tool as a post-processing step (<code>--line_thin</code>).</p>
<p><em>References</em>:</p>
<p>Johnston, E. G., &amp; Rosenfeld, A. (1975). Digital detection of pits, peaks, ridges, and ravines. IEEE
Transactions on Systems, Man, and Cybernetics, (4), 472-480.</p>
<p>Lindsay, J. B. (2006). Sensitivity of channel mapping techniques to uncertainty in digital elevation data.
International Journal of Geographical Information Science, 20(6), 669-692.</p>
<p>Peucker, T. K., &amp; Douglas, D. H. (1975). Detection of surface-specific points by local parallel
processing of discrete terrain elevation data. Computer Graphics and image processing, 4(4), 375-387.</p>
<p><em>See Also</em>:</p>
<p><code>FeaturePreservingDenoise</code></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Options include 'LQ' (lower quartile), 'JandR' (Johnston and Rosenfeld), and 'PandD' (Peucker and Douglas); default is 'LQ'</td></tr>
<tr><td>--line_thin        </td><td> Optional flag indicating whether post-processing line-thinning should be performed</td></tr>
<tr><td>--filter           </td><td> Optional argument (only used when variant='lq') providing the filter size, in grid cells, used for lq-filtering (default is 5)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.extract_valleys(
    dem, 
    output, 
    variant=&quot;LQ&quot;, 
    line_thin=True, 
    filter=5, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ExtractValleys -v --wd=&quot;/path/to/data/&quot; ^
--dem=pointer.tif -o=out.tif --variant='JandR' ^
--line_thin
&gt;&gt;./whitebox_tools -r=ExtractValleys -v ^
--wd=&quot;/path/to/data/&quot; --dem=pointer.tif -o=out.tif ^
--variant='lq' --filter=7 --line_thin 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/extract_valleys.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 12, 2017</p>
<p><a name="FarthestChannelHead"></a></p>
<a class="header" href="#farthestchannelhead" id="farthestchannelhead"><h1>FarthestChannelHead</h1></a>
<p>This tool calculates the upstream distance to the farthest stream head for each grid cell belonging to a
raster stream network. The user must specify the name of a raster containing streams data (<code>--streams</code>), where
stream grid cells are denoted by all positive non-zero values, and a D8 flow pointer (i.e. flow direction) raster
(<code>--d8_pntr</code>). The pointer image is used to traverse the stream network and must only be created using the D8 algorithm.
Stream cells are designated in the streams image as all values
greater than zero. Thus, all non-stream or background grid cells are commonly assigned either zeros or NoData
values. Background cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code>
parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#lengthofupstreamchannels"><strong>LengthOfUpstreamChannels</strong></a>, <a href="./stream_network_analysis.html#findmainstem"><strong>FindMainStem</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.farthest_channel_head(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FarthestChannelHead -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=FarthestChannelHead -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/farthest_channel_head.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="FindMainStem"></a></p>
<a class="header" href="#findmainstem" id="findmainstem"><h1>FindMainStem</h1></a>
<p>This tool can be used to identify the main channel in a stream network. The user must specify the names of
a D8 pointer (flow direction) raster (<code>--d8_pntr</code>), and a streams raster (<code>--streams</code>). The pointer raster
is used to traverse the stream network and should only be created using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>. By default, the pointer
raster is assumed to use the clockwise indexing method used by WhiteboxTools:</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 64 </td><td align="center"> 128 </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 32 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> 16 </td><td align="center">  8  </td><td align="center"> 4  </td></tr>
</tbody></table>
<p>If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p>The streams raster should have been created using one of the DEM-based stream mapping methods, i.e. contributing
area thresholding. Stream grid cells are designated in the streams image as all positive, non-zero values. All
non-stream cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code> parameter
is specified.</p>
<p>The algorithm operates by traversing each stream and identifying the longest stream-path draining to each outlet.
When a confluence is encountered, the traverse follows the branch with the larger distance-to-head.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.find_main_stem(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FindMainStem -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=FindMainStem -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/find_main_stem.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="HackStreamOrder"></a></p>
<a class="header" href="#hackstreamorder" id="hackstreamorder"><h1>HackStreamOrder</h1></a>
<p>This tool can be used to assign the Hack stream order to each link in a stream network. According to this common
stream numbering system, the main stream is assigned an order of one. All tributaries to the main stream (i.e. the trunk)
are assigned an order of two; tributaries to second-order links are assigned an order of three, and so on. The trunk or
main stream of the stream network can be defined either based on the furthest upstream distance, at each bifurcation
(i.e. network junction).</p>
<p>Stream order is often used in hydro-geomorphic and ecological studies to quantify the relative size and importance of a
stream segment to the overall river system. Unlike some other stream ordering systems, e.g. Horton-Strahler stream order
(<a href="./stream_network_analysis.html#strahlerstreamorder"><strong>StrahlerStreamOrder</strong></a>) and Shreve's stream magnitude (<a href="./stream_network_analysis.html#shrevestreammagnitude"><strong>ShreveStreamMagnitude</strong></a>), Hack's stream ordering method increases
from the catchment outlet towards the channel heads. This has the main advantage that the catchment outlet is likely to
be accurately located while the channel network extent may be less accurately mapped.</p>
<p>The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams image as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer image is used to traverse the stream network and should only
be created using the D8 algorithm. Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>Reference</em>:</p>
<p>Hack, J. T. (1957). Studies of longitudinal stream profiles in Virginia and Maryland (Vol. 294). US Government
Printing Office.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>, <a href="./stream_network_analysis.html#strahlerstreamorder"><strong>StrahlerStreamOrder</strong></a>, <a href="./stream_network_analysis.html#shrevestreammagnitude"><strong>ShreveStreamMagnitude</strong></a>, <a href="./stream_network_analysis.html#topologicalstreamorder"><strong>TopologicalStreamOrder</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.hack_stream_order(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HackStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=HackStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/hack_order.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="HortonStreamOrder"></a></p>
<a class="header" href="#hortonstreamorder" id="hortonstreamorder"><h1>HortonStreamOrder</h1></a>
<p>This tool can be used to assign the Strahler stream order to each link in a stream network. Stream ordering is often used
in hydro-geomorphic and ecological studies to quantify the relative size and importance of a stream segment to the overall
river system. There are several competing stream ordering schemes. Based on to this common stream numbering system, headwater
stream links are assigned an order of one. Stream order only increases downstream when two links of equal order join, otherwise
the downstream link is assigned the larger of the two link orders.</p>
<p>Strahler order and Horton order are similar approaches to assigning stream network hierarchy. Horton stream
order essentially starts with the Strahler order scheme, but subsequently replaces each of the assigned stream order
value along the main trunk of the network with the order value of the outlet. The main channel is not treated
differently compared with other tributaries in the Strahler ordering scheme.</p>
<p>The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams image as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer image is used to traverse the stream network and should only
be created using the D8 algorithm (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>). Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>Reference</em>:</p>
<p>Horton, R. E. (1945). Erosional development of streams and their drainage basins; hydrophysical approach to quantitative
morphology. Geological society of America bulletin, 56(3), 275-370.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hackstreamorder"><strong>HackStreamOrder</strong></a>, <a href="./stream_network_analysis.html#shrevestreammagnitude"><strong>ShreveStreamMagnitude</strong></a>, <a href="./stream_network_analysis.html#strahlerstreamorder"><strong>StrahlerStreamOrder</strong></a>, <a href="./stream_network_analysis.html#topologicalstreamorder"><strong>TopologicalStreamOrder</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.horton_stream_order(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HortonStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=HortonStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/horton_order.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="LengthOfUpstreamChannels"></a></p>
<a class="header" href="#lengthofupstreamchannels" id="lengthofupstreamchannels"><h1>LengthOfUpstreamChannels</h1></a>
<p>This tool calculates, for each stream grid cell in an input streams raster (<code>--streams</code>) the
total length of channels upstream. The user must specify the name of a raster containing streams data (<code>--streams</code>), where
stream grid cells are denoted by all positive non-zero values, and a D8 flow pointer (i.e. flow direction) raster
(<code>--d8_pntr</code>). The pointer image is used to traverse the stream network and must only be created using the D8 algorithm.
Stream cells are designated in the streams image as all values greater than zero. Thus, all non-stream or background
grid cells are commonly assigned either zeros or NoData values. Background cells will be assigned the NoData value
in the output image, unless the <code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged
zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#farthestchannelhead"><strong>FarthestChannelHead</strong></a>, <a href="./stream_network_analysis.html#findmainstem"><strong>FindMainStem</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.length_of_upstream_channels(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LengthOfUpstreamChannels -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=LengthOfUpstreamChannels -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/total_length_channels.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="LongProfile"></a></p>
<a class="header" href="#longprofile" id="longprofile"><h1>LongProfile</h1></a>
<p>This tool can be used to create a <a href="http://www.fao.org/docrep/003/X6841E/X6841E02.HTM">longitudinal profile</a> plot.
A longitudinal stream profile is a plot of elevation against downstream distance. Most long profiles use distance
from channel head as the distance measure. This tool, however, uses the distance to the stream network outlet cell,
or mouth, as the distance measure. The reason for this difference is that while for any one location within a stream
network there is only ever one downstream outlet, there is usually many upstream channel heads. Thus plotted using
the traditional downstream-distance method, the same point within a network will plot in many different long profile
locations, whereas it will always plot on one unique location in the distance-to-mouth method. One consequence of
this difference is that the long profile will be oriented from right-to-left rather than left-to-right, as would
traditionally be the case.</p>
<p>The tool outputs an interactive SVG line graph embedded in an HTML document (<code>--output</code>). The user must specify the
names of a D8 pointer (<code>--d8_pntr</code>) image (flow direction), a streams raster image
(<code>--streams</code>), and a digital elevation model (<code>--dem</code>). Stream cells are designated in the streams image as all
positive, nonzero values. Thus all non-stream or background grid cells are commonly assigned either zeros or NoData
values. The pointer image is used to traverse the stream network and should only be created using the D8 algorithm
(<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>). The streams image should be derived using a flow accumulation based stream network extraction
algorithm, also based on the D8 flow algorithm.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#longprofilefrompoints"><strong>LongProfileFromPoints</strong></a>, <a href="./geomorphometric_analysis.html#profile"><strong>Profile</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.long_profile(
    d8_pntr, 
    streams, 
    dem, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LongProfile -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr=D8.tif --streams=streams.tif --dem=dem.tif ^
-o=output.html --esri_pntr 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/long_profile.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 20/02/2018</p>
<p><a name="LongProfileFromPoints"></a></p>
<a class="header" href="#longprofilefrompoints" id="longprofilefrompoints"><h1>LongProfileFromPoints</h1></a>
<p>This tool can be used to create a <a href="http://www.fao.org/docrep/003/X6841E/X6841E02.HTM">longitudinal profile</a> plot
for a set of vector points (<code>--points</code>).  A longitudinal stream profile is a plot of elevation against downstream
distance. Most long profiles use distance from channel head as the distance measure. This tool, however, uses the
distance to the outlet cell, or mouth, as the distance measure.</p>
<p>The tool outputs an interactive SVG line graph embedded in an HTML document (<code>--output</code>). The user must specify the
names of a D8 pointer (<code>--d8_pntr</code>) image (flow direction), a vector points file (<code>--points</code>), and a digital
elevation model (<code>--dem</code>). The pointer image is used to traverse the flow path issuing from each initiation point
in the vector file; this pointer file should only be created using the D8 algorithm (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>).</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#longprofile"><strong>LongProfile</strong></a>, <a href="./geomorphometric_analysis.html#profile"><strong>Profile</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--points           </td><td> Input vector points file</td></tr>
<tr><td>--dem              </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output HTML file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.long_profile_from_points(
    d8_pntr, 
    points, 
    dem, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LongProfileFromPoints -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --points=stream_head.shp ^
--dem=dem.tif -o=output.html --esri_pntr 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/long_profile_from_points.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 21/02/2018</p>
<p><a name="RasterStreamsToVector"></a></p>
<a class="header" href="#rasterstreamstovector" id="rasterstreamstovector"><h1>RasterStreamsToVector</h1></a>
<p>This tool converts a raster stream file into a vector file. The user must specify: 1)
the name of the raster streams file, 2) the name of the D8 flow pointer file,
and 3) the name of the output vector file. Streams in the input raster streams
file are denoted by cells containing any positive, non-zero integer. A field in
the vector database file, called STRM_VAL, will correspond to this positive
integer value. The database file will also have a field for the length of each
link in the stream network. The flow pointer file must be calculated from a DEM with
all topographic depressions and flat areas removed and must be calculated using the
D8 flow pointer algorithm. The output vector will contain PolyLine features.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#rasterizestreams"><strong>RasterizeStreams</strong></a>, <a href="./data_tools.html#rastertovectorlines"><strong>RasterToVectorLines</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>-o, --output       </td><td> Output vector file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.raster_streams_to_vector(
    streams, 
    d8_pntr, 
    output, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterStreamsToVector -v ^
--wd=&quot;/path/to/data/&quot; --streams=streams.tif --d8_pntr=D8.tif ^
-o=output.shp
&gt;&gt;./whitebox_tools -r=RasterStreamsToVector -v ^
--wd=&quot;/path/to/data/&quot; --streams=streams.tif --d8_pntr=D8.tif ^
-o=output.shp --esri_pntr 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/raster_streams_to_vector.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/09/2018</p>
<p><a name="RasterizeStreams"></a></p>
<a class="header" href="#rasterizestreams" id="rasterizestreams"><h1>RasterizeStreams</h1></a>
<p>This tool can be used rasterize an input vector stream network (<code>--streams</code>) using on Lindsay (2016) method.
The user must specify the name of an existing raster (<code>--base</code>), from which the output raster's grid resolution
is determined.</p>
<p><em>Reference</em>:</p>
<p>Lindsay JB. 2016. The practice of DEM stream burning revisited. Earth Surface Processes and Landforms,
41(5): 658–668. DOI: 10.1002/esp.3888</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#rasterstreamstovector"><strong>RasterStreamsToVector</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--streams          </td><td> Input vector streams file</td></tr>
<tr><td>--base             </td><td> Input base raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--nodata           </td><td> Use NoData value for background?</td></tr>
<tr><td>--feature_id       </td><td> Use feature number as output value?</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.rasterize_streams(
    streams, 
    base, 
    output, 
    nodata=True, 
    feature_id=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RasterizeStreams -v ^
--wd=&quot;/path/to/data/&quot; --streams=streams.shp --base=raster.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/rasterize_streams.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: March 11, 2018</p>
<p><a name="RemoveShortStreams"></a></p>
<a class="header" href="#removeshortstreams" id="removeshortstreams"><h1>RemoveShortStreams</h1></a>
<p>This tool can be used to remove stream links in a stream network that are shorter than a user-specified length (<code>--min_length</code>).
The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams raster as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer raster is used to traverse the stream network and should only
be created using the D8 algorithm. Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#extractstreams"><strong>ExtractStreams</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--min_length       </td><td> Minimum tributary length (in map units) used for network prunning</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.remove_short_streams(
    d8_pntr, 
    streams, 
    output, 
    min_length, 
    esri_pntr=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RemoveShortStreams -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/remove_short_streams.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="ShreveStreamMagnitude"></a></p>
<a class="header" href="#shrevestreammagnitude" id="shrevestreammagnitude"><h1>ShreveStreamMagnitude</h1></a>
<p>This tool can be used to assign the Shreve stream magnitude to each link in a stream network. Stream ordering is often used
in hydro-geomorphic and ecological studies to quantify the relative size and importance of a stream segment to the overall
river system. There are several competing stream ordering schemes. Shreve stream magnitude is equal to the number of
headwater links upstream of each link. Headwater stream links are assigned a magnitude of one.</p>
<p>The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams raster as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer image is used to traverse the stream network and should only
be created using the D8 algorithm. Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>Reference</em>:</p>
<p>Shreve, R. L. (1966). Statistical law of stream numbers. The Journal of Geology, 74(1), 17-37.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>, <a href="./stream_network_analysis.html#hackstreamorder"><strong>HackStreamOrder</strong></a>, <a href="./stream_network_analysis.html#strahlerstreamorder"><strong>StrahlerStreamOrder</strong></a>, <a href="./stream_network_analysis.html#topologicalstreamorder"><strong>TopologicalStreamOrder</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.shreve_stream_magnitude(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ShreveStreamMagnitude -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=ShreveStreamMagnitude -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/shreve_magnitude.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="StrahlerStreamOrder"></a></p>
<a class="header" href="#strahlerstreamorder" id="strahlerstreamorder"><h1>StrahlerStreamOrder</h1></a>
<p>This tool can be used to assign the Strahler stream order to each link in a stream network. Stream ordering is often used
in hydro-geomorphic and ecological studies to quantify the relative size and importance of a stream segment to the overall
river system. There are several competing stream ordering schemes. Based on to this common stream numbering system, headwater
stream links are assigned an order of one. Stream order only increases downstream when two links of equal order join, otherwise
the downstream link is assigned the larger of the two link orders.</p>
<p>Strahler order and Horton order are similar approaches to assigning stream network hierarchy. Horton stream
order essentially starts with the Strahler order scheme, but subsequently replaces each of the assigned stream order
value along the main trunk of the network with the order value of the outlet. The main channel is not treated
differently compared with other tributaries in the Strahler ordering scheme.</p>
<p>The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams image as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer image is used to traverse the stream network and should only
be created using the D8 algorithm. Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>Reference</em>:</p>
<p>Strahler, A. N. (1957). Quantitative analysis of watershed geomorphology. Eos, Transactions American Geophysical Union,
38(6), 913-920.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>, <a href="./stream_network_analysis.html#hackstreamorder"><strong>HackStreamOrder</strong></a>, <a href="./stream_network_analysis.html#shrevestreammagnitude"><strong>ShreveStreamMagnitude</strong></a>, <a href="./stream_network_analysis.html#topologicalstreamorder"><strong>TopologicalStreamOrder</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.strahler_stream_order(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StrahlerStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=StrahlerStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/strahler_order.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="StreamLinkClass"></a></p>
<a class="header" href="#streamlinkclass" id="streamlinkclass"><h1>StreamLinkClass</h1></a>
<p>This tool identifies all interior and exterior links, and source, link, and sink nodes in an input stream network
(<code>--streams</code>). The input streams file is used to designate which grid cells contain a stream and the pointer
image is used to traverse the stream network. Stream cells are designated in the streams image as all values
greater than zero. Thus, all non-stream or background grid cells are commonly assigned either zeros or NoData
values. Background cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code>
parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>Each feature is assigned the following identifier in the output image:</p>
<table><thead><tr><th>Value </th><th> Stream Type</th></tr></thead><tbody>
<tr><td>1    </td><td> Exterior Link</td></tr>
<tr><td>2    </td><td> Interior Link</td></tr>
<tr><td>3    </td><td> Source Node (head water)</td></tr>
<tr><td>4    </td><td> Link Node</td></tr>
<tr><td>5    </td><td> Sink Node</td></tr>
</tbody></table>
<p>The user must specify the names of an input stream file, a pointer (flow direction) file (<code>--d8_pntr</code>)
and the output raster file (<code>--output</code>). The flow pointer and streams rasters should be generated
using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This will require a depressionless DEM, processed using either the
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. flow direction) raster, and the output raster.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_link_class(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamLinkClass -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=StreamLinkClass -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/stream_link_class.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 12/07/2017</p>
<p><a name="StreamLinkIdentifier"></a></p>
<a class="header" href="#streamlinkidentifier" id="streamlinkidentifier"><h1>StreamLinkIdentifier</h1></a>
<p>This tool can be used to assign each link in a stream network a unique numeric identifier. This grid is
used by a number of other stream network analysis tools.</p>
<p>The input streams file (<code>--streams</code>) is used to designate which grid cells contain a stream and the pointer
image is used to traverse the stream network. Stream cells are designated in the streams image as all values
greater than zero. Thus, all non-stream or background grid cells are commonly assigned either zeros or NoData
values. Background cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code>
parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>The user must specify the name of a flow pointer (flow direction) raster (<code>--d8_pntr</code>), a streams raster
(<code>--streams</code>), and the output raster (<code>--output</code>). The flow pointer and streams rasters should be generated
using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This will require a depressionless DEM, processed using either the
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. flow direction) raster, and the output raster.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./stream_network_analysis.html#tributaryidentifier"><strong>TributaryIdentifier</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_link_identifier(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamLinkIdentifier -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=StreamLinkIdentifier -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/stream_link_id.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="StreamLinkLength"></a></p>
<a class="header" href="#streamlinklength" id="streamlinklength"><h1>StreamLinkLength</h1></a>
<p>This tool can be used to measure the length of each link in a stream network. The user must specify the names of
a stream link ID raster (<code>--linkid</code>), created using the <a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a> and D8 pointer raster (<code>--d8_pntr</code>).
The flow pointer raster is used to traverse the stream network and should only be created using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm.
Stream cells are designated in the stream link ID raster as all non-zero, positive values. Background cells will be
assigned the NoData value in the output image, unless the <code>--zero_background</code> parameter is used, in which case non-stream
cells will be assinged zero values in the output.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./stream_network_analysis.html#streamlinkslope"><strong>StreamLinkSlope</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--linkid           </td><td> Input raster streams link ID (or tributary ID) file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_link_length(
    d8_pntr, 
    linkid, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamLinkLength -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --linkid=streamsID.tif ^
--dem=dem.tif -o=output.tif
&gt;&gt;./whitebox_tools ^
-r=StreamLinkLength -v --wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif ^
--linkid=streamsID.tif --dem=dem.tif -o=output.tif --esri_pntr ^
--zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/stream_link_length.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="StreamLinkSlope"></a></p>
<a class="header" href="#streamlinkslope" id="streamlinkslope"><h1>StreamLinkSlope</h1></a>
<p>This tool can be used to measure the average slope gradient, in degrees, of each link in a raster stream
network. To estimate the slope of individual grid cells in a raster stream network, use the
<a href="./stream_network_analysis.html#streamslopecontinuous"><strong>StreamSlopeContinuous</strong></a> tool instead. The user must specify the names of a stream link identifier raster image (<code>--linkid</code>), a D8
pointer image (<code>--d8_pntr</code>), and a digital elevation model (<code>--dem</code>). The pointer image is used to traverse the
stream network and must only be created using the D8 algorithm (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>).
Stream cells are designated in the streams image as all values greater than zero. Thus, all non-stream or background
grid cells are commonly assigned either zeros or NoData values. Background cells will be assigned the NoData value
in the output image, unless the <code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged
zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#streamslopecontinuous"><strong>StreamSlopeContinuous</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--linkid           </td><td> Input raster streams link ID (or tributary ID) file</td></tr>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_link_slope(
    d8_pntr, 
    linkid, 
    dem, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamLinkSlope -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --linkid=streamsID.tif ^
--dem=dem.tif -o=output.tif
&gt;&gt;./whitebox_tools ^
-r=StreamLinkSlope -v --wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif ^
--linkid=streamsID.tif --dem=dem.tif -o=output.tif --esri_pntr ^
--zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/stream_link_slope.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="StreamSlopeContinuous"></a></p>
<a class="header" href="#streamslopecontinuous" id="streamslopecontinuous"><h1>StreamSlopeContinuous</h1></a>
<p>This tool can be used to measure the slope gradient, in degrees, each grid cell in a raster stream network. To
estimate the average slope for each link in a stream network, use the
<a href="./stream_network_analysis.html#streamlinkslope"><strong>StreamLinkSlope</strong></a> tool instead. The user must specify the names of a stream raster image (<code>--streams</code>), a D8
pointer image (<code>--d8_pntr</code>), and a digital elevation model (<code>--dem</code>). The pointer image is used to traverse the
stream network and must only be created using the D8 algorithm (<a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>).
Stream cells are designated in the streams image as all values greater than zero. Thus, all non-stream or background
grid cells are commonly assigned either zeros or NoData values. Background cells will be assigned the NoData value
in the output image, unless the <code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged
zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#streamlinkslope"><strong>StreamLinkSlope</strong></a>, <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-i, --dem          </td><td> Input raster DEM file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.stream_slope_continuous(
    d8_pntr, 
    streams, 
    dem, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StreamSlopeContinuous -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --linkid=streamsID.tif ^
--dem=dem.tif -o=output.tif
&gt;&gt;./whitebox_tools ^
-r=StreamSlopeContinuous -v --wd=&quot;/path/to/data/&quot; ^
--d8_pntr=D8.tif --streams=streamsID.tif --dem=dem.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/stream_slope_continuous.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="TopologicalStreamOrder"></a></p>
<a class="header" href="#topologicalstreamorder" id="topologicalstreamorder"><h1>TopologicalStreamOrder</h1></a>
<p>This tool can be used to assign the topological stream order to each link in a stream network. According to this
stream numbering system, the link directly draining to the outlet is assigned an order of one. Each of the two
tributaries draining to the order-one link are assigned an order of two, and so on until the most distant link from
the catchment outlet has been assigned an order. The topological order can therefore be thought of as a measure of
the topological distance of each link in the network to the catchment outlet and is likely to be related to travel time.</p>
<p>The user must specify the names of a streams raster image (<code>--streams</code>) and D8 pointer image (<code>--d8_pntr</code>). Stream cells
are designated in the streams image as all positive, nonzero values. Thus all non-stream or background grid cells are
commonly assigned either zeros or NoData values. The pointer image is used to traverse the stream network and should only
be created using the D8 algorithm. Background cells will be assigned the NoData value in the output image, unless the
<code>--zero_background</code> parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./stream_network_analysis.html#hackstreamorder"><strong>HackStreamOrder</strong></a>, <a href="./stream_network_analysis.html#hortonstreamorder"><strong>HortonStreamOrder</strong></a>, <a href="./stream_network_analysis.html#strahlerstreamorder"><strong>StrahlerStreamOrder</strong></a>, <a href="./stream_network_analysis.html#shrevestreammagnitude"><strong>ShreveStreamMagnitude</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.topological_stream_order(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TopologicalStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=TopologicalStreamOrder -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/topological_stream_order.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 28/06/2017</p>
<p><a name="TributaryIdentifier"></a></p>
<a class="header" href="#tributaryidentifier" id="tributaryidentifier"><h1>TributaryIdentifier</h1></a>
<p>This tool can be used to assigns a unique identifier to each tributary in a stream network. A tributary is
a section of a stream network extending from a channel head downstream to a confluence with a larger stream.
Relative stream size is estimated using stream length as a surrogate. Tributaries therefore extend from channel
heads downstream until a confluence is encountered in which the intersecting stream is longer, or an outlet
cell is detected.</p>
<p>The input streams file (<code>--streams</code>) is used to designate which grid cells contain a stream and the pointer
image is used to traverse the stream network. Stream cells are designated in the streams image as all values
greater than zero. Thus, all non-stream or background grid cells are commonly assigned either zeros or NoData
values. Background cells will be assigned the NoData value in the output image, unless the <code>--zero_background</code>
parameter is used, in which case non-stream cells will be assinged zero values in the output.</p>
<p>The user must specify the name of a flow pointer (flow direction) raster (<code>--d8_pntr</code>), a streams raster
(<code>--streams</code>), and the output raster (<code>--output</code>). The flow pointer and streams rasters should be generated
using the <a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a> algorithm. This will require a depressionless DEM, processed using either the
<a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a> or <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a> tool. flow direction) raster, and the output raster.</p>
<p>By default, the pointer raster is assumed to use the clockwise indexing method used by WhiteboxTools.
If the pointer file contains ESRI flow direction values instead, the <code>--esri_pntr</code> parameter must be specified.</p>
<p><em>See Also</em>:</p>
<p><a href="./hydrological_analysis.html#d8pointer"><strong>D8Pointer</strong></a>, <a href="./stream_network_analysis.html#streamlinkidentifier"><strong>StreamLinkIdentifier</strong></a>, <a href="./hydrological_analysis.html#breachdepressions"><strong>BreachDepressions</strong></a>, <a href="./hydrological_analysis.html#filldepressions"><strong>FillDepressions</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>--d8_pntr          </td><td> Input raster D8 pointer file</td></tr>
<tr><td>--streams          </td><td> Input raster streams file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--esri_pntr        </td><td> D8 pointer uses the ESRI style scheme</td></tr>
<tr><td>--zero_background  </td><td> Flag indicating whether a background value of zero should be used</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">wbt.tributary_identifier(
    d8_pntr, 
    streams, 
    output, 
    esri_pntr=False, 
    zero_background=False, 
    callback=default_callback
)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TributaryIdentifier -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif
&gt;&gt;./whitebox_tools -r=TributaryIdentifier -v ^
--wd=&quot;/path/to/data/&quot; --d8_pntr=D8.tif --streams=streams.tif ^
-o=output.tif --esri_pntr --zero_background 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/stream_network_analysis/tributary_id.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<a class="header" href="#tutorials" id="tutorials"><h1>Tutorials</h1></a>
<ul>
<li><a href="tutorials/mosaic.html">How can I mosaic hundreds of rasters?</a></li>
<li><a href="tutorials/lidar.html">Processing LiDAR data</a></li>
</ul>
<a class="header" href="#how-can-i-mosaic-hundreds-of-rasters" id="how-can-i-mosaic-hundreds-of-rasters"><h1>How can I mosaic hundreds of rasters?</h1></a>
<p>Sometimes you find that you need to mosaic many individual raster tiles into a single larger raster image. You can use WhiteboxTools' <strong>Mosaic</strong> tool to join multiple rasters together; however, this operation can become extremely challenging if you have many hundreds of large raster tiles. The following script shows how you can use WhiteboxTools' Python interface to mosaic many rasters using intermediate mosaicing steps, which are then merged in a final step. Each intermediate mosaic raster is cleaned up at the end. The script assumes that the initial raster tiles are contained in a single directory (<code>source_data_dir</code>) and that the output mosaics will be contained in a seperate directory (<code>raster_data_dir</code>). Please modify these as needed.</p>
<pre><code class="language-python">import os
from os import path
from WBT.whitebox_tools import WhiteboxTools

def main():
    #####################################################################
    # Script Settings: modify these as is appropriate to your use-case. #
    #####################################################################
    source_data_dir = &quot;/directory/to/source/raster/tiles/&quot;
    # See the user manual for a listing of all supported raster formats.
    tile_extension = &quot;.asc&quot; # Here I've used an ArcGIS ASCII raster format as input. 
    raster_data_dir = &quot;/directory/to/output/raster/mosaic/&quot;
    mosaic_extension = &quot;.tif&quot; # The output mosaic is being saved here as a GeoTIFF.
    mosaic_method = &quot;nn&quot; # &quot;nn&quot; = nearest neighbour; &quot;bilinear&quot; = bilinear; &quot;cc&quot; = cubic convolution
    delete_source_tiles = False
    fill_nodata_gaps = False

    ########################
    # Set up WhiteboxTools #
    ########################
    wbt = WhiteboxTools()
    wbt.work_dir = raster_data_dir # set working directory
    wbt.verbose = False # Make it so that Whitebox doesn't output every progress update
    if not os.path.exists(raster_data_dir):
        os.makedirs(raster_data_dir)

    ##############################################################
    # Mosaic raster tiles; this is done using intermediate steps #
    ##############################################################
    processed_files = []
    num_mosaiced = 1
    flag = True
    round = 1
    while flag:
        # This will mosaic a maximum of 50 tiles together; these sub-files
        # will subsequently be merged. Mosaicing many hundreds of tiles
        # together at one time is otherwise too computationally intensive.
        # Depending on your system resources and the tile sizes, you may have to 
        # adjust this number.
        file_names = find_files(source_data_dir, tile_extension, processed_files, 50)
        if len(file_names) &gt; 1:
            in_files = &quot;&quot;
            for i in range(len(file_names)):
                if i &lt; len(file_names)-1:
                    in_files += f&quot;{file_names[i]};&quot;
                else:
                    in_files += f&quot;{file_names[i]}&quot;

                processed_files.append(file_names[i])
                num_mosaiced += 1

            out_file = raster_data_dir + f&quot;mosaic{round}{mosaic_extension}&quot;
            wbt.mosaic(inputs=in_files, output=out_file, method=mosaic_method)
            print(f&quot;Processing mosaic {round}; num. files = {num_mosaiced}&quot;)

            if delete_source_tiles:
                for i in range(len(file_names)):
                    os.remove(source_data_dir + file_names[i])

        else:
            flag = False

        round += 1

    wbt.verbose = True
    mosaic_file = raster_data_dir + f&quot;final_mosaic{mosaic_extension}&quot;
    file_names = find_mosaic_files(raster_data_dir, mosaic_extension)
    if len(file_names) &gt; 1:
        in_files = &quot;&quot;
        for i in range(len(file_names)):
            if i &lt; len(file_names)-1:
                in_files += f&quot;{file_names[i]};&quot;
            else:
                in_files += f&quot;{file_names[i]}&quot;

            num_mosaiced += 1


        wbt.mosaic(inputs=in_files, output=mosaic_file, method=mosaic_method)

        # now clean up the intermediate mosaics; you'll want to delete them.
        for i in range(len(file_names)):
            os.remove(raster_data_dir + file_names[i])



    ##############################################
    # Would you like to fill in the NoData gaps? #
    ##############################################
    if fill_nodata_gaps:
        dem_nodata_filled = raster_data_dir + f&quot;DEM_gaps_filled{mosaic_extension}&quot;
        wbt.fill_missing_data(mosaic_file, dem_nodata_filled, filter=101)

    print(&quot;Done!&quot;)

def find_files(input_dir, extension, processed_files, max_num=10):
    files = os.listdir(input_dir)
    file_names = []
    for f in files:
        if f.endswith(extension) and f not in processed_files:
            if len(file_names) &lt; max_num:
                file_names.append(f)
            else:
                break

    return file_names

def find_mosaic_files(input_dir, mosaic_extension):
    files = os.listdir(input_dir)
    file_names = []
    for f in files:
        if &quot;mosaic&quot; in f and f.endswith(mosaic_extension):
            file_names.append(f)

    return file_names

main()
</code></pre>
<a class="header" href="#processing-lidar-data" id="processing-lidar-data"><h1>Processing LiDAR data</h1></a>
<ul>
<li><a href="#grid_lidar">How do I convert a LAS point cloud into a raster?</a></li>
<li><a href="#classification">How do I exclude points with certain classifications?</a></li>
<li><a href="#folder">I have many LAS files and want to interpolate all of them at once</a></li>
<li><a href="#low_points">What if my data contains anomalously high/low points?</a></li>
<li><a href="#laz">My data are in LAZ format. How do I interpolate them?</a></li>
<li><a href="#intensity">How do I interpolate an image from the intensity data?</a></li>
<li><a href="#resolution">How do I decide on an appropriate grid resolution?</a></li>
<li><a href="#nodata_gaps">My raster contains NoData gaps. How do I remove these?</a></li>
<li><a href="#mosaic">How do I combine many LiDAR tiles into a single raster?</a></li>
<li><a href="#workflow">Is there a complete example LiDAR processing workflow available?</a></li>
</ul>
<p><a name="grid_lidar"></a></p>
<a class="header" href="#how-do-i-convert-a-las-point-cloud-into-a-raster" id="how-do-i-convert-a-las-point-cloud-into-a-raster"><h2>How do I convert a LAS point cloud into a raster?</h2></a>
<p>Converting your LiDAR data into a raster requires an interpolation operation. There are many such interpolation methods. The following is an example of how to interpolate the last-return points of a LAS (LiDAR) file using an inverse distance weighted (IDW) interpolation scheme, with a search window radius of 2.5 m, an exponent of 2.0, and an output grid resolution of 1.5 m.</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot;

wbt.lidar_idw_interpolation(
i=&quot;myFile.las&quot;,
output=&quot;myRaster.tif&quot;,
parameter=&quot;elevation&quot;,
returns=&quot;last&quot;,
resolution=1.5,
weight=2.0,
radius=2.5
)
</code></pre>
<p>Other methods for gridding a LAS file include nearest neighbour, Delaunay triangulation (TINing), block minimum, and block maximum gridding schemes.</p>
<p><a name="classification"></a></p>
<a class="header" href="#how-do-i-exclude-points-with-certain-classifications" id="how-do-i-exclude-points-with-certain-classifications"><h2>How do I exclude points with certain classifications?</h2></a></h2>
<p>It is commonly the case that points with certain class values should be excluded from the gridding of LiDAR data. For example, you may wish to exclude points associated with vegetation, buildings, bridges, utility lines, etc. The <em>LidarIdwInterpolation</em> and <em>LidarNearestNeighbourGridding</em> tools allow for excluded point classes using the <em>exclude_cls</em> parameter. The parameter takes a numeric list as input, e.g. <code>exclude_cls='3,4,5,6,7,18'</code>. Class values follow those of the LAS v.1.4 specifications:</p>
<p><em>LAS point classification values</em></p>
<table><thead><tr><th align="left"> Classification Value  </th><th align="left"> Meaning                              </th></tr></thead><tbody>
<tr><td align="left"> 0                     </td><td align="left"> Created never classified</td></tr>
<tr><td align="left"> 1                     </td><td align="left"> Unclassified3</td></tr>
<tr><td align="left"> 2                     </td><td align="left"> Ground</td></tr>
<tr><td align="left"> 3                     </td><td align="left"> Low Vegetation</td></tr>
<tr><td align="left"> 4                     </td><td align="left"> Medium Vegetation</td></tr>
<tr><td align="left"> 5                     </td><td align="left"> High Vegetation</td></tr>
<tr><td align="left"> 6                     </td><td align="left"> Building</td></tr>
<tr><td align="left"> 7                     </td><td align="left"> Low Point (noise)</td></tr>
<tr><td align="left"> 8                     </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 9                     </td><td align="left"> Water</td></tr>
<tr><td align="left"> 10                    </td><td align="left"> Rail</td></tr>
<tr><td align="left"> 11                    </td><td align="left"> Road Surface</td></tr>
<tr><td align="left"> 12                    </td><td align="left"> Reserved</td></tr>
<tr><td align="left"> 13                    </td><td align="left"> Wire – Guard (Shield)</td></tr>
<tr><td align="left"> 14                    </td><td align="left"> Wire – Conductor (Phase)</td></tr>
<tr><td align="left"> 15                    </td><td align="left"> Transmission Tower</td></tr>
<tr><td align="left"> 16                    </td><td align="left"> Wire-structure Connector (e.g. Insulator)</td></tr>
<tr><td align="left"> 17                    </td><td align="left"> Bridge Deck</td></tr>
<tr><td align="left"> 18                    </td><td align="left"> High Noise</td></tr>
</tbody></table>
<p>Of course, not all LAS files have had point classifications applied and stored. To determine whether your data contains point class
data, you can run the <em>LidarInfo</em> tool before interpolation.</p>
<p><a name="folder"></a></p>
<a class="header" href="#i-have-many-las-files-and-want-to-interpolate-all-of-them-at-once" id="i-have-many-las-files-and-want-to-interpolate-all-of-them-at-once"><h2>I have many LAS files and want to interpolate all of them at once</h2></a>
<p>When you have hundreds, or even thousands, of LAS files you might be inclined to write a Python script that calls the above function for each input file contained within a folder. But that isn't the best way to handle this common situation. Instead, if the input (i) and output parameters are left unspecified, each of WhiteboxTool's LiDAR gridding methods will interpolate all of the LAS files in the working directory, e.g.</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot;
wbt.lidar_idw_interpolation(
parameter=&quot;elevation&quot;,
returns=&quot;last&quot;,
resolution=1.0,
weight=1.0,
radius=2.5
)
</code></pre>
<p>Using this approach to folder-based interpolation has some advantages other than a greatly simplified script. WhiteboxTools will be able to parallelize the operation better, greatly improving the overall time required to interpolate the batch of files. Also, the gridding operations will be carried out with a strip of buffered data surrounding each LiDAR tile, i.e. there will be reduced edge-effects. This will reduce the potential for artifacts in the final mosaiced DEM.</p>
<p><a name="low_points"></a></p>
<a class="header" href="#what-if-my-data-contains-anomalously-highlow-points" id="what-if-my-data-contains-anomalously-highlow-points"><h2>What if my data contains anomalously high/low points?</h2></a>
<p>This is a fairly common problem with LiDAR data. If you're fortunate, these points, which often fall hundreds of meters above  or below the terrain surface, will be classified appropriately. When  this is the case, you may simply exclude the points with class values of 7 (low point) and 18 (high point). Alternatively, you may use the optional <code>minz</code> and <code>maxz</code> interpolation parameters to exclude unclassified outlier points. Lastly, you may remove these points from the original point cloud data set using the <em>LidarRemoveOutliers</em> tool.</p>
<p><a name="laz"></a></p>
<a class="header" href="#my-data-are-in-laz-format-how-do-i-interpolate-them" id="my-data-are-in-laz-format-how-do-i-interpolate-them"><h2>My data are in LAZ format. How do I interpolate them?</h2></a>
<p>WhiteboxTools does not currently support the compressed LiDAR format LAZ. To use these data, you will first need to decompress the files to a LAS format. You may wish to use LasTools for this purpose.</p>
<p><a name="intensity"></a></p>
<a class="header" href="#how-do-i-interpolate-an-image-from-the-intensity-data" id="how-do-i-interpolate-an-image-from-the-intensity-data"><h2>How do I interpolate an image from the intensity data?</h2></a>
<p>The <code>parameter</code> argument of the IDW and nearest neighbour interpolator tools allows you to interpolate intensity data (options include 'elevation', 'intensity', 'class', 'scan angle', and 'user data'). Here is an example:</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot;

wbt.lidar_nearest_neighbour_gridding(
&quot;in.las&quot;, &quot;out.tif&quot;, parameter=&quot;intensity&quot;)
</code></pre>
<p><a name="resolution"></a></p>
<a class="header" href="#how-do-i-decide-on-an-appropriate-grid-resolution" id="how-do-i-decide-on-an-appropriate-grid-resolution"><h2>How do I decide on an appropriate grid resolution?</h2></a>
<p>You want to choose a grid resolution where the vast majority of grid cells in the area covered by data have at least one return point. If you are interpolating with last-return points only, then this will necessarily reduce the potential resolution. Ultimately, there is not single appropriate value and the range of suitable resolutions will depend on the distribution of point density with the area of coverage. If the specified resolution is too high given the point density of the LiDAR data set, many of the grid cells will either be NoData holes, or represent interpolated values from relatively distant (up to the search radius) points. A higher than necessary grid resolution will also make working with the final mosaiced DEM raster more challenging, due to the computational effort needed to work with massive rasters and increase the storage and memory requirements. It is advisable to experiment with the <em>LidarPointDensity</em> and <em>LidarPointStats</em> tools before deciding upon a grid resolution for interpolation.</p>
<p><a name="nodata_gaps"></a></p>
<a class="header" href="#my-raster-contains-nodata-gaps-how-do-i-remove-these" id="my-raster-contains-nodata-gaps-how-do-i-remove-these"><h2>My raster contains NoData gaps. How do I remove these?</h2></a>
<p>First, we need to distinguish between two common areas of NoData values in the interpolated rasters of LiDAR data sets. Because LiDAR data are often collected for irregularly shaped sites, it is frequently the case that LiDAR DEMs have large NoData areas beyond the area of LiDAR point coverage. These are generally acceptable void areas and should not be altered. The more problemmatic void areas are interior data gaps (so called doughnut holes). These generally arise because the point density in an area of LiDAR coverage is lower than the grid resolution (and search radius) dictate in an area. Sometimes these NoData areas are associated with specific non-reflective surfaces, such as water, or areas of dense vegetation (and therefore the last return point density is far lower than in other areas). If the NoData gaps are extensive and spread throughout he area of coverage, that is a sign that you likely need to interpolate either with a coarser grid resolution or a larger search radius, or quite probably both. If your LiDAR DEM has a small number these void areas, and they are not extensive, then you may interpolate to remove the gaps using the <em>FillMissingData</em> tool:</p>
<pre><code class="language-python">from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot;

wbt.fill_missing_data(&quot;dem.tif&quot;, &quot;new_dem.tif&quot;, filter=11)
</code></pre>
<p>The choice of a filter size will depend on the extent of the largest interior void area.</p>
<p><a name="mosaic"></a></p>
<a class="header" href="#how-do-i-combine-many-lidar-tiles-into-a-single-raster" id="how-do-i-combine-many-lidar-tiles-into-a-single-raster"><h2>How do I combine many LiDAR tiles into a single raster?</h2></a>
<p>Often you have many hundred LAS files, which you've intepolated into an equally large number of raster files. To combine these rasters into a single large DEM, use the Mosaic tool.</p>
<pre><code class="language-python">from os import listdir
from WBT.whitebox_tools import WhiteboxTools

wbt = WhiteboxTools()
wbt.work_dir = &quot;/path/to/data/&quot;

# find all GeoTIFFs in the path
input_files = &quot;&quot;
for f in listdir(wbt.work_dir):
    if f.endswith(&quot;.tif&quot;):
        input_files += &quot;;&quot; + f

input_files = input_files[1:]  # strips the first ';'

wbt.mosaic(inputs=input_files, output=&quot;big_DEM.tif&quot;)&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p><a name="workflow"></a></p>
<a class="header" href="#is-there-a-complete-example-lidar-processing-workflow-available" id="is-there-a-complete-example-lidar-processing-workflow-available"><h2>Is there a complete example LiDAR processing workflow available?</h2></a>
<p>Yes! The following code is an example of some of the common tasks required in processing large LiDAR datasets of many hundreds of LAS files.</p>
<pre><code class="language-python">import os
from os import path
from WBT.whitebox_tools import WhiteboxTools

def main():

    las_files_dir = &quot;/Users/johnlindsay/Documents/data/test_lidar/&quot;
    filtered_las_dir = &quot;/Users/johnlindsay/Documents/data/test_lidar/filtered_LAS/&quot;
    raster_data_dir = &quot;/Users/johnlindsay/Documents/data/test_lidar/interpolated_grids/&quot;

    wbt = WhiteboxTools()
    wbt.work_dir = las_files_dir #set working directory
    wbt.verbose = False
    if not os.path.exists(filtered_las_dir):
        os.makedirs(filtered_las_dir)

    # Sometimes, I like to extract all of the LAS tiles that overlap with a
    # particular area. For example, I might want to interpolate all the files
    # overlapping with a watershed. For this, you can use select_tiles_by_polygon.
    # Uncomment the four lines below if you want to do this.
    # outdir = &quot;/Users/johnlindsay/Documents/data/LAS_files_in_watershed/&quot;
    # polygons = &quot;/Users/johnlindsay/Documents/data/LAS_files_in_watershed/watershed.shp&quot;
    # wbt.select_tiles_by_polygon(las_files_dir, outdir, polygons)
    # las_files_dir = outdir # this way the analysis below works only on the selected tiles.

    ##################################################################################
    # Filter the ground points in the LAS files using lidar_ground_point_filter tool #
    ##################################################################################

    # This one is the SLOWEST part of the workflow and can be avoided if you are
    # confident that you have good point classification data, i.e. that the
    # vegetation and building classes have been properly populated.
    processed_files = []
    num_filtered = 1
    flag = True
    while flag:
        file_names = find_las_files(las_files_dir, processed_files)
        if len(file_names) &gt; 0: # and len(processed_files) &lt; 3000:
            for i in range(len(file_names)):
                in_file = las_files_dir + file_names[i]
                out_file = filtered_las_dir + file_names[i].replace(&quot;.las&quot;, &quot;_filtered.las&quot;)
                print(&quot;Processing LAS {} of {} (total filtered={}) {}&quot;.format(i+1, len(file_names), num_filtered, file_names[i]))
                processed_files.append(file_names[i])
                wbt.lidar_ground_point_filter(in_file, out_file, radius=2.0, slope_threshold=45, height_threshold=1.0)
                num_filtered += 1
        else:
            flag = False


    ##############################
    # Interpolate the LAS files. #
    ##############################

    # If you don't use the above ground point filter the directory below must be
    # updated to point to the original LAS files.
    wbt.work_dir = filtered_las_dir

    # You can use either IDW, nearest neighbour, or TINing (Delaunay triangulation)
    # for the gridding step. TINing option is available as of WhiteboxTools v0.11.
    wbt.lidar_idw_interpolation(parameter=&quot;elevation&quot;, returns=&quot;all&quot;, resolution=2.0, weight=1.0, radius=5.0, exclude_cls='3,4,5,6,7,18')
    # wbt.lidar_nearest_neighbour_gridding(returns=&quot;last&quot;, resolution=1.5, radius=2.5, exclude_cls='3,4,5,6,7,18')
    # wbt.lidar_tin_gridding(parameter=&quot;elevation&quot;, returns=&quot;all&quot;, resolution=2.0, exclude_cls='3,4,5,6,7,18')

    ###############################################################
    # Now mosaic the tiles; this is done using intermediate steps #
    ###############################################################
    if not os.path.exists(raster_data_dir):
        os.makedirs(raster_data_dir)

    wbt.work_dir = filtered_las_dir #set working directory
    wbt.verbose = False
    processed_files = []
    num_mosaiced = 1
    flag = True
    round = 1
    while flag:
        # This will mosaic a maximum of 250 tiles together; these sub-files
        # will subsequently be merged. Mosaicing many hundreds of tiles
        # together at one time is otherwise too intensive.
        file_names = find_tiff_files(filtered_las_dir, processed_files, 2)
        if len(file_names) &gt; 1:
            in_files = &quot;&quot;
            for i in range(len(file_names)):
                if i &lt; len(file_names)-1:
                    in_files += f&quot;{file_names[i]};&quot;
                else:
                    in_files += f&quot;{file_names[i]}&quot;

                processed_files.append(file_names[i])
                num_mosaiced += 1

            out_file = raster_data_dir + f&quot;mosaic{round}.tif&quot;
            wbt.mosaic(inputs=in_files, output=out_file, method=&quot;nn&quot;)
            print(f&quot;Processing mosaic {round}; num. files = {num_mosaiced}&quot;)

            # now clean up the individual tiles
            for i in range(len(file_names)):
                os.remove(filtered_las_dir + file_names[i])

        else:
            flag = False

        round += 1

    wbt.work_dir = raster_data_dir #set working directory
    mosaic_file = raster_data_dir + f&quot;final_mosaic.tif&quot;
    file_names = find_mosaic_files(raster_data_dir)
    if len(file_names) &gt; 1:
        in_files = &quot;&quot;
        for i in range(len(file_names)):
            if i &lt; len(file_names)-1:
                in_files += f&quot;{file_names[i]};&quot;
            else:
                in_files += f&quot;{file_names[i]}&quot;

            num_mosaiced += 1


        wbt.mosaic(inputs=in_files, output=mosaic_file, method=&quot;nn&quot;)

        # now clean up the intermediate mosaics
        for i in range(len(file_names)):
            os.remove(raster_data_dir + file_names[i])



    ##############################################
    # Would you like to fill in the NoData gaps? #
    ##############################################
    dem_nodata_filled = raster_data_dir + f&quot;DEM_gaps_filled.tif&quot;
    wbt.fill_missing_data(mosaic_file, dem_nodata_filled, filter=11)


    ######################################################################
    # I usually remove off-terrain objects, like any remaining buildings #
    ######################################################################
    dem_no_otos = raster_data_dir + f&quot;DEM_no_OTOs.tif&quot;
    wbt.remove_off_terrain_objects(dem_nodata_filled, dem_no_otos, filter=11, slope=15.0)


    #####################################
    # Would you like to smooth the DEM? #
    #####################################
    dem_smoothed = raster_data_dir + f&quot;DEM_smoothed.tif&quot;
    wbt.feature_preserving_denoise(dem_no_otos, dem_smoothed, filter=11, norm_diff=8.0)


    ################################
    # Want to fix the depressions? #
    ################################
    dem_breached = raster_data_dir + f&quot;DEM_breached.tif&quot;
    # Set the maximum breach depth appropriate for the terrain. You can
    # also restrict breaching based on a maximum breach channel length.
    wbt.breach_depressions(dem_smoothed, dem_breached, max_depth=5.0)

    # because we restricted the use of very deep breach channels, there
    # may still be depressions in the DEM. To get rid of these, we can
    # perform a subsequent depression filling operation.
    dem_filled = raster_data_dir + f&quot;DEM_filled.tif&quot;
    wbt.fill_depressions(dem_breached, dem_filled)


    ####################################################################
    # Okay, now we have a good base DEM from which we can extract      #
    # various land-surface parameters. There are really a large        #
    # number of these parameters available, but I'll just showcase     #
    # a few common ones here. See the User Manual for a complete list. #
    ####################################################################

    # slope
    slope_file = raster_data_dir + f&quot;slope.tif&quot;
    wbt.slope(dem_filled, slope_file)

    # plan curvature
    plan_curv_file = raster_data_dir + f&quot;plan_curv.tif&quot;
    wbt.plan_curvature(dem_filled, plan_curv_file)

    # profile curvature; other curvatures are available too.
    profile_curv_file = raster_data_dir + f&quot;profile_curv.tif&quot;
    wbt.profile_curvature(dem_filled, profile_curv_file)

    # hillshade (shaded relief raster)
    hillshade_file = raster_data_dir + f&quot;hillshade.tif&quot;
    wbt.hillshade(dem_filled, hillshade_file)

    # relative topographic position (RTP) index
    rtp_file = raster_data_dir + f&quot;relative_topographic_position.tif&quot;
    wbt.relative_topographic_position(dem_filled, rtp_file, filterx=11, filtery=11)

    # or even better, multiscale topographic position
    dev_max_mag = raster_data_dir + f&quot;multiscale_topo_position_mag.tif&quot;
    dev_max_scale = raster_data_dir + f&quot;multiscale_topo_position_scale.tif&quot;
    wbt.max_elevation_deviation(dem_filled, dev_max_mag, dev_max_scale, min_scale=1, max_scale=100, step=2)

    # ruggedness index
    ruggedness_index_file = raster_data_dir + f&quot;ruggedness_index.tif&quot;
    wbt.ruggedness_index(dem_filled, ruggedness_index_file)

    # or even better, multiscale roughness
    roughness_mag = raster_data_dir + f&quot;multiscale_roughness_mag.tif&quot;
    roughness_scale = raster_data_dir + f&quot;multiscale_roughness_scale.tif&quot;
    wbt.multiscale_roughness(dem_filled, roughness_mag, roughness_scale, min_scale=1, max_scale=100, step=2)

    # D-infinity flow accumulation
    flow_accum_file = raster_data_dir + f&quot;dinf_flow_accum.tif&quot;
    wbt.d_inf_flow_accumulation(dem_filled, flow_accum_file, log=True)

    # There literally hundreds of other useful parameters that could be
    # extracted from our DEM using WhiteboxTools. Take a look at the User Manual.


    print(&quot;Done!&quot;)

def find_las_files(input_dir, processed_files):
    files = os.listdir(input_dir)
    file_names = []
    for f in files:
        if f.endswith(&quot;.las&quot;) and f not in processed_files:
            file_names.append(f)

    return file_names


def find_tiff_files(input_dir, processed_files, max_num=10):
    files = os.listdir(input_dir)
    file_names = []
    for f in files:
        if f.endswith(&quot;.tif&quot;) and f not in processed_files:
            if len(file_names) &lt; max_num:
                file_names.append(f)
            else:
                break

    return file_names

def find_mosaic_files(input_dir):
    files = os.listdir(input_dir)
    file_names = []
    for f in files:
        if &quot;mosaic&quot; in f and (f.endswith(&quot;.tif&quot;) or f.endswith(&quot;.dep&quot;)):
            file_names.append(f)

    return file_names

main()
</code></pre>
<a class="header" href="#supported-data-formats" id="supported-data-formats"><h1>Supported Data Formats</h1></a>
<a class="header" href="#raster-formats" id="raster-formats"><h2>Raster formats</h2></a>
<p>The <em>WhiteboxTools</em> library can currently support reading/writing raster data in several common formats.</p>
<table><thead><tr><th align="left"> Format </th><th align="left"> Extension </th><th align="center"> Read </th><th align="center"> Write </th></tr></thead><tbody>
<tr><td align="left"> Big GeoTIFF </td><td align="left"> *.tif, *.tiff </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> ESRI ASCII </td><td align="left"> *.txt, *.asc </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> ESRI Binary </td><td align="left"> *.flt and *.hdr </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> GeoTIFF </td><td align="left"> *.tif, *.tiff </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> GRASS ASCII </td><td align="left"> *.txt, *.asc </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> Idrisi </td><td align="left"> *.rdc and *.rst </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> SAGA Binary </td><td align="left"> *.sdat and *.sgrd </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> Surfer ASCII </td><td align="left"> *.grd </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> Surfer Binary </td><td align="left"> *.grd </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left"> Whitebox </td><td align="left"> *.tas and *.dep </td><td align="center"> X </td><td align="center"> X </td></tr>
</tbody></table>
<blockquote>
<p>Throughout this manual code examples that manipulate raster files all use the GeoTIFF format (.tif) but any of the supported file extensions can be used in its place.</p>
</blockquote>
<p><em>Multi-band GeoTIFFs are not currently supported.</em> The library is primarily tested using Whitebox raster and GeoTIFF data sets and if you encounter issues when reading/writing data in other formats, you should report the <a href="#reporting-bugs">issue</a>.</p>
<p>Please note that there are no plans to incorporate third-party libraries, like <a href="http://www.gdal.org">GDAL</a>, in the project given the design goal of keeping a pure (or as close as possible) Rust codebase without third-party dependencies. This design greatly simplifies installation of the library but significantly complicates the development by necessitating hand-rolled encoders/decoders for various raster data formats. For more complicated file formats, particularly the ubiquitous GeoTIFF format, it will take time to develop a mature and bug-free encoder/decoder and it is likely that we will only ever be able to support a sub-set of the possible GeoTIFF raster types. It is helpful if users who encounter raster-format related issues <a href="(#reporting-bugs)">report their problems</a> complete with descriptions of the error (<em>What tool was being used? What type of data were input? How far along was the execution before the error was thrown? What was the error message?</em>) and if possible submit a copy of the problematic file.</p>
<a class="header" href="#vector-formats" id="vector-formats"><h2>Vector Formats</h2></a>
<p>At present, there is limited support in <em>WhiteboxTools</em> for working with vector geospatial data formats. The only supported vector format is the ESRI <a href="https://en.wikipedia.org/wiki/Shapefile">Shapefile</a>. Shapefiles geometries (.shp) and attributes (.dbf) can be read and written. There are plans to support a wider variety of vector file formats in the future.</p>
<p>While the Shapefile format is extremely common, it does have certain limitations for vector representation. For example, owing to their 32-bit indexing, Shapefiles are limited in the number of geometries that can be stored in these files. Furthermore, Shapefiles are incapable of storing geometries of more than one type (point, lines, polygons) within the same file. As such, the vector-related tools in <em>WhiteboxTools</em> also carry these same limitations imposed by the Shapefile format.</p>
<a class="header" href="#point-cloud-lidar-formats" id="point-cloud-lidar-formats"><h2>Point Cloud (LiDAR) Formats</h2></a>
<p>LiDAR data can be read/written in the common <a href="https://www.asprs.org/committee-general/laser-las-file-format-exchange-activities.html">LAS</a> data format. <em>WhiteboxTools</em> can read and write LAS files that have been compressed (zipped with a .zip extension) using the common DEFLATE algorithm. Note that only LAS file should be contained within a zipped archive file. The following is an example of running a LiDAR tool using zipped input/output files:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LidarTophatTransform -v --wd=&quot;/path/to/data/&quot;
-i=&quot;input.las.zip&quot; -o=&quot;output.las.zip&quot; --radius=10.0
</code></pre>
<p>Note that the double extensions (.las.zip) in the above command are not necessary and are only used for convenience of keeping track of LiDAR data sets (i.e. .zip extensions work too). The extra work of decoding/encoding compressed files does add additional processing time, although the Rust compression library that is used is highly efficient and usually only adds a few seconds to tool run times. Zipping LAS files frequently results 40-60% smaller binary files, making the additional processing time worthwhile for larger LAS file data sets with massive storage requirements.</p>
<blockquote>
<p>Note: The compressed LiDAR format LAZ and ESRI LiDAR format are not currently supported in <em>WhiteboxTools</em>. The ESRI format is proprietary and closed-source, making it impossible to write an encoder/decoder for this file format. While there is a <a href="http://lastools.org/download/laszip.pdf">published paper</a> describing Martin Isenburg's impressive <a href="https://laszip.org/">LAZ format</a>, it is not up-to-date with the current data format. Nor does the paper provide as much detailed information regarding the file structure as an open <em>specification</em> document (e.g. the <a href="https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf">LAS format spec</a>). This makes the open-source code for the LAZ reader/writer the only means of interogating the current structure of these files, which makes it difficult to natively support LAZ.</p>
</blockquote>
<a class="header" href="#contributing-and-reporting-bugs" id="contributing-and-reporting-bugs"><h1>Contributing and Reporting Bugs</h1></a>
<p>If you would like to contribute to the project as a developer, follow these instructions to get started:</p>
<ol>
<li>Fork the <em>WhiteboxTools</em> project ( https://github.com/jblindsay/whitebox-tools )</li>
<li>Create your feature branch (git checkout -b my-new-feature)</li>
<li>Commit your changes (git commit -am 'Add some feature')</li>
<li>Push to the branch (git push origin my-new-feature)</li>
<li>Create a new Pull Request</li>
</ol>
<p>Unless explicitly stated otherwise, any contribution intentionally submitted for inclusion in the work shall be licensed under the <a href="./license.html">MIT License</a> without any additional terms or conditions.</p>
<p>If you would like to contribute financial support for the project, please contact <a href="https://jblindsay.github.io/ghrg/index.html">John Lindsay</a>. We also welcome contributions in the form of media exposure. If you have written an article or blog about <em>WhiteboxTools</em> please let us know about it.</p>
<p>WhiteboxTools is distributed as is and without warranty of suitability for application. If you encounter flaws with the software (i.e. bugs) please report the issue. Providing a detailed description of the conditions under which the bug occurred will help to identify the bug. <em>Use the Issues tracker on GitHub to report issues with the software and to request feature enchancements.</em> Please do not email Dr. Lindsay directly with bugs.</p>
<a class="header" href="#contributors" id="contributors"><h2>Contributors</h2></a>
<p>The following is a list of the developers who have helped to improve <em>WhiteboxTools</em> by contributing code.</p>
<ol>
<li>John Lindsay (jblindsay)</li>
<li>Dharhas Pothina (dharhas)</li>
<li>Qiusheng Wu (giswqs)</li>
<li>Daniel Newman</li>
<li>Anthony Francioni (Afrancioni)</li>
<li>Simon Gudim</li>
<li>Alexander Bruy (alexbruy)</li>
<li>Katrin Leinweber (katrinleinweber)</li>
<li>Yvan Le Bras (yvanlebras)</li>
</ol>
<p>If you feel you're missing from this list, please let us know. Also, the project is grateful to the numerous users that have contributed bug reports that have resulted in improvements to individual tools.</p>
<a class="header" href="#known-issues-and-limitations" id="known-issues-and-limitations"><h1>Known Issues and Limitations</h1></a>
<ul>
<li>The LAZ and zLAS (Esri) compressed LiDAR data formats are currently unsupported although zipped LAS files (.zip) are.</li>
<li>There is no support for reading waveform data contained within or associated with LAS files.</li>
<li>File directories cannot contain apostrophes (', e.g. /John's data/) as they will be interpreted in the arguments array as single quoted strings.</li>
<li>The Python scripts included with <strong>WhiteboxTools</strong> require Python 3. They will not work with Python 2, which is frequently the default Python version installed on many systems.</li>
<li>Not all types of GeoTIFF files are supported. The GeoTIFF format is very flexible and certain less common varieties may not be read properly by WhiteboxTools. The WhiteboxTools GeoTIFF reader/writer is a custom implementation and does not rely on other library (e.g. GDAL) and therefore there may be difficulties when exchanging GeoTIFF data between WhiteboxTools and GDAL supported software.</li>
</ul>
<a class="header" href="#license" id="license"><h1>License</h1></a>
<p>The <strong>WhiteboxTools</strong> library is distributed under the <a href="LICENSE.txt">MIT license</a>, a permissive open-source (free software) license.</p>
<blockquote>
<p>The MIT License (MIT)</p>
<p>Copyright (c) 2017-2019 John Lindsay</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
</blockquote>
<a class="header" href="#frequently-asked-questions" id="frequently-asked-questions"><h1>Frequently Asked Questions</h1></a>
<a class="header" href="#do-i-need-whitebox-gat-to-use-whiteboxtools" id="do-i-need-whitebox-gat-to-use-whiteboxtools"><h2>Do I need Whitebox GAT to use WhiteboxTools?</h2></a>
<p>No you do not. You can call the tools contained within <em>WhiteboxTools</em> completely independent from the <em>Whitebox GAT</em> user interface using a Remote Procedure Call (RPC) approach. In fact, you can interact with the tools using Python scripting or directly, using a terminal application (command prompt). See <a href="#interacting-with-whiteboxtools-from-the-command-prompt"><em>Interacting With <em>WhiteboxTools</em> From the Command Prompt</em></a> for further details.</p>
<a class="header" href="#how-do-i-request-a-tool-be-added" id="how-do-i-request-a-tool-be-added"><h2>How do I request a tool be added?</h2></a>
<p>Eventually most of the tools in <em>Whitebox GAT</em> will be ported over to <em>WhiteboxTools</em> and all new tools will be added to this library as well. Naturally, this will take time. The order by which tools are ported is partly a function of ease of porting, existing infrastructure (i.e. raster and LiDAR tools will be ported first since their is currently no support in the library for vector I/O), and interest. If you are interested in making a tool a higher priority for porting, email <a href="https://jblindsay.github.io/ghrg/index.html">John Lindsay</a>.</p>
<a class="header" href="#can-whiteboxtools-be-incorporated-into-other-software-and-open-source-gis-projects" id="can-whiteboxtools-be-incorporated-into-other-software-and-open-source-gis-projects"><h2>Can WhiteboxTools be incorporated into other software and open-source GIS projects?</h2></a>
<p><em>WhiteboxTools</em> was developed with the open-source GIS <a href="https://jblindsay.github.io/ghrg/Whitebox/index.html">Whitebox GAT</a> in mind. That said, the tools can be accessed independently and so long as you abide by the terms of the <a href="#license">MIT license</a>, there is no reason why other software and GIS projects cannot use <em>WhiteboxTools</em> as well. In fact, this was one of the motivating factors for creating the library in the first place. Feel free to use <em>WhiteboxTools</em> as the geospatial analysis engine in your open-source software project.</p>
<a class="header" href="#what-platforms-does-whiteboxtools-support" id="what-platforms-does-whiteboxtools-support"><h2>What platforms does WhiteboxTools support?</h2></a>
<p><em>WhiteboxTools</em> is developed using the Rust programming language, which supports a <a href="https://forge.rust-lang.org/platform-support.html">wide variety of platforms</a> including MS Windows, MacOS, and Linux operating systems and common chip architectures. Interestingly, Rust also supports mobile platforms, and <em>WhiteboxTools</em> should therefore be capable of targeting (although no testing has been completed in this regard to date). Nearly all development and testing of the software is currently carried out on MacOS and we cannot guarantee a bug-free performance on other platforms. In particularly, MS Windows is the most different from the other platforms and is therefore the most likely to encounter platform-specific bugs. If you encounter bugs in the software, please consider reporting an issue using the GitHub support for issue-tracking.</p>
<a class="header" href="#what-are-the-system-requirements" id="what-are-the-system-requirements"><h2>What are the system requirements?</h2></a>
<p>The answer to this question depends strongly on the type of analysis and data that you intend to process. However, generally we find performance to be optimal with a recommended minimum of 8-16GB of memory (RAM), a modern multi-core processor (e.g. 64-bit i5 or i7), and an solid-state-drive (SSD). It is likely that <em>WhiteboxTools</em> will have satisfactory performance on lower-spec systems if smaller datasets are being processed. Because <em>WhiteboxTools</em> reads entire raster datasets into system memory (for optimal performance, and in recognition that modern systems have increasingly larger amounts of fast RAM), this tends to be the limiting factor for the upper-end of data size successfully processed by the library. 64-bit operating systems are recommended and extensive testing has not been carried out on 32-bit OSs. See <a href="#what-platforms-does-whiteboxtools-support"><strong>&quot;What platforms does WhiteboxTools support?&quot;</strong></a> for further details on supported platforms.</p>
<a class="header" href="#are-pre-compiled-executables-of-whiteboxtools-available" id="are-pre-compiled-executables-of-whiteboxtools-available"><h2>Are pre-compiled executables of WhiteboxTools available?</h2></a>
<p>Pre-compiled binaries for <em>WhiteboxTools</em> can be downloaded from the <a href="https://jblindsay.github.io/ghrg/software.shtml#WhiteboxTools"><em>Geomorphometry and Hydrogeomatics Research Group</em></a> software web site for various supported operating systems. If you need binaries for other operating systems/system architectures, you will need to compile the executable from source files. See <a href="#installation">Installation</a> for details.</p>
<a class="header" href="#why-is-whiteboxtools-programmed-in-rust" id="why-is-whiteboxtools-programmed-in-rust"><h2>Why is WhiteboxTools programmed in Rust?</h2></a>
<p>I spent a long time evaluating potential programming language for future development efforts for the <em>Whitebox GAT</em> project. My most important criterion for a language was that it compile to native code, rather than target the Java virtual machine (JVM). I have been keen to move Whitebox GAT away from Java because of some of the challenges that supporting the JVM has included for many Whitebox users. The language should be fast and productive--Java is already quite fast, but if I am going to change development languages, I would like a performance boost. Furthermore, given that many, though not all, of the algorithms used for geospatial analysis scale well with concurrent (parallel) implementations, I favoured languages that offered easy and safe concurrent programming. Although many would consider C/C++ for this work, I was looking for a modern and safe language. Fortunately, we are living through a renaissance period in programming language development and there are many newer languages that fit the bill nicely. Over the past two years, I considered each of Go, Rust, D, Nim, and Crystal for Whitebox development and ultimately decided on Rust. [See <a href="https://github.com/jblindsay/go-spatial"><em>GoSpatial</em></a> and <a href="https://github.com/jblindsay/lidario"><em>lidario</em></a>.]</p>
<p>Each of the languages I examined has its own advantages of disadvantages, so why Rust? It's a combination of factors that made it a compelling option for this project. Compared with many on the list, Rust is a mature language with a vibrant user community. Like C/C++, it's a high-performance and low-level language that allows for complete control of the system. However, Rust is also one of the safest languages, meaning that I can be confident that <em>WhiteboxTools</em> will not contain common bugs, such as memory use-after-release, memory leaks and race conditions within concurrent code. Importantly, and quite uniquely, this safety is achieved in the Rust language without the use of a garbage collector (automatic memory management). Garbage collectors can be great, but they do generally come with a certain efficiency trade-off that Rust does not have. The other main advantage of Rust's approach to memory management is that it allows for  a level of interaction with scripting languages (e.g. Python) that is quite difficult to do in garbage collected languages. Although <strong>WhiteboxTools</strong> is currently set up to use an automation approach to interacting with Python code that calls it, I like the fact that I have the option to create a <em>WhiteboxTools</em> shared library.</p>
<p>Not everything with Rust is perfect however. It is still a very young language and there are many pieces still missing from its ecosystem. Furthermore, it is not the easiest language to learn, particularly for people who are inexperienced with programming. This may limit my ability to attract other programers to the Whitebox project, which would be unfortunate. However, overall, Rust was the best option for this particular application.</p>
<a class="header" href="#do-i-need-rust-installed-on-my-computer-to-run-whiteboxtools" id="do-i-need-rust-installed-on-my-computer-to-run-whiteboxtools"><h2>Do I need Rust installed on my computer to run WhiteboxTools?</h2></a>
<p>No, you would only need Rust installed if you were compiling the <em>WhiteboxTools</em> codebase from source files.</p>
<a class="header" href="#how-does-whiteboxtools-design-philosophy-differ" id="how-does-whiteboxtools-design-philosophy-differ"><h2>How does WhiteboxTools' design philosophy differ?</h2></a>
<p><em>Whitebox GAT</em> is frequently praised for its consistent design and ease of use. Like <em>Whitebox GAT</em>, <em>WhiteboxTools</em> follows the convention of <em>one tool for one function</em>. For example, in <em>WhiteboxTools</em> assigning the links in a stream channel network their Horton, Strahler, Shreve, or Hack stream ordering numbers requires running separate tools (i.e. <em>HortonStreamOrder</em>, <em>StrahlerStreamOrder</em>, <em>ShreveStreamMagnitude</em>, and <em>HackStreamOrder</em>). By contrast, in GRASS GIS<sup>1</sup> and ArcGIS single tools (i.e. the <em>r.stream.order</em> and <em>Stream Order</em> tools respectively) can be configured to output different channel ordering schemes. The <em>WhiteboxTools</em> design is intended to simplify the user experience and to make it easier to find the right tool for a task. With more specific tool names that are reflective of their specific purposes, users are not as reliant on reading help documentation to identify the tool for the task at hand. Similarly, it is not uncommon for tools in other GIS to have multiple outputs. For example, in GRASS GIS the <em>r.slope.aspect</em> tool can be configured to output slope, aspect, profile curvature, plan curvature, and several other common terrain surface derivatives. Based on the <em>one tool for one function</em> design approach of <em>WhiteboxTools</em>, multiple outputs are indicative that a tool should be split into different, more specific tools. Are you more likely to go to a tool named <em>r.slope.aspect</em> or <em>TangentialCurvature</em> when you want to create a tangential curvature raster from a DEM? If you're new to the software and are unfamiliar with it, probably the later is more obvious. The <em>WhiteboxTools</em> design approach also has the added benefit of simplifying the documentation for tools. The one downside to this design approach, however, is that it results (or will result) in a large number of tools, often with signifcant overlap in function.</p>
<p><sup>1</sup> NOTE: It is not my intent to criticize GRASS GIS, as I deeply respect the work that the GRASS developers have contributed. Rather, I am contrasting the consequences of <em>WhiteboxTools'</em> design philosophy to that of other GIS.</p>
<a class="header" href="#index-of-tools" id="index-of-tools"><h1>Index of Tools</h1></a>
<ol>
<li>
<p><a href="available_tools/mathand_stats_tools.html#AbsoluteValue">AbsoluteValue</a>: Calculates the absolute value of every cell in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#AdaptiveFilter">AdaptiveFilter</a>: Performs an adaptive filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#AddPointCoordinatesToTable">AddPointCoordinatesToTable</a>: Modifies the attribute table of a point vector by adding fields containing each point's X and Y coordinates. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Add">Add</a>: Performs an addition operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#AggregateRaster">AggregateRaster</a>: Aggregates a raster to a lower resolution. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#And">And</a>: Performs a logical AND operator on two Boolean raster images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Anova">Anova</a>: Performs an analysis of variance (ANOVA) test on a raster dataset. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ArcCos">ArcCos</a>: Returns the inverse cosine (arccos) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ArcSin">ArcSin</a>: Returns the inverse sine (arcsin) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ArcTan">ArcTan</a>: Returns the inverse tangent (arctan) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#Aspect">Aspect</a>: Calculates an aspect raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Atan2">Atan2</a>: Returns the 2-argument inverse tangent (atan2). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#AttributeCorrelation">AttributeCorrelation</a>: Performs a correlation analysis on attribute fields from a vector database. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#AttributeHistogram">AttributeHistogram</a>: Creates a histogram for the field values of a vector's attribute table. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#AttributeScattergram">AttributeScattergram</a>: Creates a scattergram for two field values of a vector's attribute table. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#AverageFlowpathSlope">AverageFlowpathSlope</a>: Measures the average slope gradient from each grid cell to all upslope divide cells. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#AverageNormalVectorAngularDeviation">AverageNormalVectorAngularDeviation</a>: Calculates the circular variance of aspect at a scale for a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#AverageOverlay">AverageOverlay</a>: Calculates the average for each grid cell from a group of raster images. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#AverageUpslopeFlowpathLength">AverageUpslopeFlowpathLength</a>: Measures the average length of all upslope flowpaths draining each grid cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#BalanceContrastEnhancement">BalanceContrastEnhancement</a>: Performs a balance contrast enhancement on a colour-composite image of multispectral data. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Basins">Basins</a>: Identifies drainage basins that drain to the DEM edge. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#BilateralFilter">BilateralFilter</a>: A bilateral filter is an edge-preserving smoothing filter introduced by Tomasi and Manduchi (1998). Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#BlockMaximumGridding">BlockMaximumGridding</a>: Creates a raster grid based on a set of vector points and assigns grid values using a block maximum scheme. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#BlockMinimumGridding">BlockMinimumGridding</a>: Creates a raster grid based on a set of vector points and assigns grid values using a block minimum scheme. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#BoundaryShapeComplexity">BoundaryShapeComplexity</a>: Calculates the complexity of the boundaries of raster polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#BreachDepressions">BreachDepressions</a>: Breaches all of the depressions in a DEM using Lindsay's (2016) algorithm. This should be preferred over depression filling in most cases. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#BreachSingleCellPits">BreachSingleCellPits</a>: Removes single-cell pits from an input DEM by breaching. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#BufferRaster">BufferRaster</a>: Maps a distance-based buffer around each non-background (non-zero/non-nodata) grid cell in an input image. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Ceil">Ceil</a>: Returns the smallest (closest to negative infinity) value that is greater than or equal to the values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#CentroidVector">CentroidVector</a>: Identifes the centroid point of a vector polyline or polygon feature or a group of vector points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#Centroid">Centroid</a>: Calculates the centroid, or average location, of raster polygon objects. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#ChangeVectorAnalysis">ChangeVectorAnalysis</a>: Performs a change vector analysis on a two-date multi-spectral dataset. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#CircularVarianceOfAspect">CircularVarianceOfAspect</a>: Calculates the circular variance of aspect at a scale for a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#ClassifyOverlapPoints">ClassifyOverlapPoints</a>: Classifies or filters LAS points in regions of overlapping flight lines. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#CleanVector">CleanVector</a>: Removes null features and lines/polygons with fewer than the required number of vertices. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#ClipLidarToPolygon">ClipLidarToPolygon</a>: Clips a LiDAR point cloud to a vector polygon or polygons. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#ClipRasterToPolygon">ClipRasterToPolygon</a>: Clips a raster to a vector polygon. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Clip">Clip</a>: Extract all the features, or parts of features, that overlap with the features of the clip vector. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#Closing">Closing</a>: A closing is a mathematical morphology operation involving an erosion (min filter) of a dilation (max filter) set. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#Clump">Clump</a>: Groups cells that form discrete areas, assigning them unique identifiers. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#CompactnessRatio">CompactnessRatio</a>: Calculates the compactness ratio (A/P), a measure of shape complexity, for vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#ConservativeSmoothingFilter">ConservativeSmoothingFilter</a>: Performs a conservative-smoothing filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ConstructVectorTin">ConstructVectorTin</a>: Creates a vector triangular irregular network (TIN) for a set of vector points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#ConvertNodataToZero">ConvertNodataToZero</a>: Converts nodata values in a raster to zero. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#ConvertRasterFormat">ConvertRasterFormat</a>: Converts raster data from one format to another. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#CornerDetection">CornerDetection</a>: Identifies corner patterns in boolean images using hit-and-miss pattern matching. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#CorrectVignetting">CorrectVignetting</a>: Corrects the darkening of images towards corners. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Cos">Cos</a>: Returns the cosine (cos) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Cosh">Cosh</a>: Returns the hyperbolic cosine (cosh) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#CostAllocation">CostAllocation</a>: Identifies the source cell to which each grid cell is connected by a least-cost pathway in a cost-distance analysis. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#CostDistance">CostDistance</a>: Performs cost-distance accumulation on a cost surface and a group of source cells. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#CostPathway">CostPathway</a>: Performs cost-distance pathway analysis using a series of destination grid cells. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#CountIf">CountIf</a>: Counts the number of occurrences of a specified value in a cell-stack of rasters. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#CreateColourComposite">CreateColourComposite</a>: Creates a colour-composite image from three bands of multispectral imagery. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#CreateHexagonalVectorGrid">CreateHexagonalVectorGrid</a>: Creates a hexagonal vector grid. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#CreatePlane">CreatePlane</a>: Creates a raster image based on the equation for a simple plane. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#CreateRectangularVectorGrid">CreateRectangularVectorGrid</a>: Creates a rectangular vector grid. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#CrispnessIndex">CrispnessIndex</a>: Calculates the Crispness Index, which is used to quantify how crisp (or conversely how fuzzy) a probability image is. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#CrossTabulation">CrossTabulation</a>: Performs a cross-tabulation on two categorical images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#CsvPointsToVector">CsvPointsToVector</a>: Converts a CSV text file to vector points. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#CumulativeDistribution">CumulativeDistribution</a>: Converts a raster image to its cumulative distribution function. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#D8FlowAccumulation">D8FlowAccumulation</a>: Calculates a D8 flow accumulation raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#D8MassFlux">D8MassFlux</a>: Performs a D8 mass flux calculation. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#D8Pointer">D8Pointer</a>: Calculates a D8 flow pointer raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DInfFlowAccumulation">DInfFlowAccumulation</a>: Calculates a D-infinity flow accumulation raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DInfMassFlux">DInfMassFlux</a>: Performs a D-infinity mass flux calculation. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DInfPointer">DInfPointer</a>: Calculates a D-infinity flow pointer (flow direction) raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Decrement">Decrement</a>: Decreases the values of each grid cell in an input raster by 1.0 (see also InPlaceSubtract). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DepthInSink">DepthInSink</a>: Measures the depth of sinks (depressions) in a DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#DevFromMeanElev">DevFromMeanElev</a>: Calculates deviation from mean elevation. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#DiffFromMeanElev">DiffFromMeanElev</a>: Calculates difference from mean elevation (equivalent to a high-pass filter). Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#DiffOfGaussianFilter">DiffOfGaussianFilter</a>: Performs a Difference of Gaussian (DoG) filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Difference">Difference</a>: Outputs the features that occur in one of the two vector inputs but not both, i.e. no overlapping features. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#DirectDecorrelationStretch">DirectDecorrelationStretch</a>: Performs a direct decorrelation stretch enhancement on a colour-composite image of multispectral data. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#DirectionalRelief">DirectionalRelief</a>: Calculates relief for cells in an input DEM for a specified direction. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#Dissolve">Dissolve</a>: Removes the interior, or shared, boundaries within a vector polygon coverage. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#DistanceToOutlet">DistanceToOutlet</a>: Calculates the distance of stream grid cells to the channel network outlet cell. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#DiversityFilter">DiversityFilter</a>: Assigns each cell in the output grid the number of different values in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Divide">Divide</a>: Performs a division operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DownslopeDistanceToStream">DownslopeDistanceToStream</a>: Measures distance to the nearest downslope stream cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#DownslopeFlowpathLength">DownslopeFlowpathLength</a>: Calculates the downslope flowpath length from each cell to basin outlet. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#DownslopeIndex">DownslopeIndex</a>: Calculates the Hjerdt et al. (2004) downslope index. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#EdgeDensity">EdgeDensity</a>: Calculates the density of edges, or breaks-in-slope within DEMs. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#EdgePreservingMeanFilter">EdgePreservingMeanFilter</a>: Performs a simple edge-preserving mean filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#EdgeProportion">EdgeProportion</a>: Calculate the proportion of cells in a raster polygon that are edge cells. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#ElevAbovePit">ElevAbovePit</a>: Calculate the elevation of each grid cell above the nearest downstream pit cell or grid edge cell. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#ElevPercentile">ElevPercentile</a>: Calculates the elevation percentile raster from a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#ElevRelativeToMinMax">ElevRelativeToMinMax</a>: Calculates the elevation of a location relative to the minimum and maximum elevations in a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#ElevRelativeToWatershedMinMax">ElevRelativeToWatershedMinMax</a>: Calculates the elevation of a location relative to the minimum and maximum elevations in a watershed. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#ElevationAboveStreamEuclidean">ElevationAboveStreamEuclidean</a>: Calculates the elevation of cells above the nearest (Euclidean distance) stream cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#ElevationAboveStream">ElevationAboveStream</a>: Calculates the elevation of cells above the nearest downslope stream cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#EliminateCoincidentPoints">EliminateCoincidentPoints</a>: Removes any coincident, or nearly coincident, points from a vector points file. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#ElongationRatio">ElongationRatio</a>: Calculates the elongation ratio for vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#EmbossFilter">EmbossFilter</a>: Performs an emboss filter on an image, similar to a hillshade operation. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#EqualTo">EqualTo</a>: Performs a equal-to comparison operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#ErasePolygonFromLidar">ErasePolygonFromLidar</a>: Erases (cuts out) a vector polygon or polygons from a LiDAR point cloud. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#ErasePolygonFromRaster">ErasePolygonFromRaster</a>: Erases (cuts out) a vector polygon from a raster. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Erase">Erase</a>: Removes all the features, or parts of features, that overlap with the features of the erase vector polygon. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#EuclideanAllocation">EuclideanAllocation</a>: Assigns grid cells in the output raster the value of the nearest target cell in the input image, measured by the Shih and Wu (2004) Euclidean distance transform. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_distance_tools.html#EuclideanDistance">EuclideanDistance</a>: Calculates the Shih and Wu (2004) Euclidean distance transform. Found in <em>GIS Analysis → Distance Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Exp2">Exp2</a>: Returns the exponential (base 2) of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Exp">Exp</a>: Returns the exponential (base e) of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#ExportTableToCsv">ExportTableToCsv</a>: Exports an attribute table to a CSV text file. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ExtendVectorLines">ExtendVectorLines</a>: Extends vector lines by a specified distance. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ExtractNodes">ExtractNodes</a>: Converts vector lines or polygons into vertex points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ExtractRasterValuesAtPoints">ExtractRasterValuesAtPoints</a>: Extracts the values of raster(s) at vector point locations. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#ExtractStreams">ExtractStreams</a>: Extracts stream grid cells from a flow accumulation raster. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#ExtractValleys">ExtractValleys</a>: Identifies potential valley bottom grid cells based on local topolography alone. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#FarthestChannelHead">FarthestChannelHead</a>: Calculates the distance to the furthest upstream channel head for each stream cell. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#FastAlmostGaussianFilter">FastAlmostGaussianFilter</a>: Performs a fast approximate Gaussian filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Fd8FlowAccumulation">Fd8FlowAccumulation</a>: Calculates an FD8 flow accumulation raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Fd8Pointer">Fd8Pointer</a>: Calculates an FD8 flow pointer raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#FeaturePreservingSmoothing">FeaturePreservingSmoothing</a>: Reduces short-scale variation in an input DEM using a modified Sun et al. (2007) algorithm. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#FetchAnalysis">FetchAnalysis</a>: Performs an analysis of fetch or upwind distance to an obstacle. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FillBurn">FillBurn</a>: Burns streams into a DEM using the FillBurn (Saunders, 1999) method. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FillDepressions">FillDepressions</a>: Fills all of the depressions in a DEM. Depression breaching should be preferred in most cases. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#FillMissingData">FillMissingData</a>: Fills NoData holes in a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FillSingleCellPits">FillSingleCellPits</a>: Raises pit cells to the elevation of their lowest neighbour. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#FilterLidarClasses">FilterLidarClasses</a>: Removes points in a LAS file with certain specified class values. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#FilterLidarScanAngles">FilterLidarScanAngles</a>: Removes points in a LAS file with scan angles greater than a threshold. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#FindFlightlineEdgePoints">FindFlightlineEdgePoints</a>: Identifies points along a flightline's edge in a LAS file. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#FindLowestOrHighestPoints">FindLowestOrHighestPoints</a>: Locates the lowest and/or highest valued cells in a raster. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#FindMainStem">FindMainStem</a>: Finds the main stem, based on stream lengths, of each stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FindNoFlowCells">FindNoFlowCells</a>: Finds grid cells with no downslope neighbours. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FindParallelFlow">FindParallelFlow</a>: Finds areas of parallel flow in D8 flow direction rasters. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#FindPatchOrClassEdgeCells">FindPatchOrClassEdgeCells</a>: Finds all cells located on the edge of patch or class features. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#FindRidges">FindRidges</a>: Identifies potential ridge and peak grid cells. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FlattenLakes">FlattenLakes</a>: Flattens lake polygons in a raster DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#FlightlineOverlap">FlightlineOverlap</a>: Reads a LiDAR (LAS) point file and outputs a raster containing the number of overlapping flight lines in each grid cell. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#FlipImage">FlipImage</a>: Reflects an image in the vertical or horizontal axis. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FloodOrder">FloodOrder</a>: Assigns each DEM grid cell its order in the sequence of inundations that are encountered during a search starting from the edges, moving inward at increasing elevations. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Floor">Floor</a>: Returns the largest (closest to positive infinity) value that is less than or equal to the values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FlowAccumulationFullWorkflow">FlowAccumulationFullWorkflow</a>: Resolves all of the depressions in a DEM, outputting a breached DEM, an aspect-aligned non-divergent flow pointer, and a flow accumulation raster. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#FlowLengthDiff">FlowLengthDiff</a>: Calculates the local maximum absolute difference in downslope flowpath length, useful in mapping drainage divides and ridges. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#GammaCorrection">GammaCorrection</a>: Performs a gamma correction on an input images. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#GaussianContrastStretch">GaussianContrastStretch</a>: Performs a Gaussian contrast stretch on input images. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#GaussianFilter">GaussianFilter</a>: Performs a Gaussian filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#GreaterThan">GreaterThan</a>: Performs a greater-than comparison operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#HackStreamOrder">HackStreamOrder</a>: Assigns the Hack stream order to each tributary in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#HighPassFilter">HighPassFilter</a>: Performs a high-pass filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#HighPassMedianFilter">HighPassMedianFilter</a>: Performs a high pass median filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#HighestPosition">HighestPosition</a>: Identifies the stack position of the maximum value within a raster stack on a cell-by-cell basis. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#Hillshade">Hillshade</a>: Calculates a hillshade raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Hillslopes">Hillslopes</a>: Identifies the individual hillslopes draining to each link in a stream network. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#HistogramEqualization">HistogramEqualization</a>: Performs a histogram equalization contrast enhancment on an image. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#HistogramMatchingTwoImages">HistogramMatchingTwoImages</a>: This tool alters the cumulative distribution function of a raster image to that of another image. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#HistogramMatching">HistogramMatching</a>: Alters the statistical distribution of a raster image matching it to a specified PDF. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#HoleProportion">HoleProportion</a>: Calculates the proportion of the total area of a polygon's holes relative to the area of the polygon's hull. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#HorizonAngle">HorizonAngle</a>: Calculates horizon angle (maximum upwind slope) for each grid cell in an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#HortonStreamOrder">HortonStreamOrder</a>: Assigns the Horton stream order to each tributary in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#HypsometricAnalysis">HypsometricAnalysis</a>: Calculates a hypsometric curve for one or more DEMs. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#IdwInterpolation">IdwInterpolation</a>: Interpolates vector points into a raster surface using an inverse-distance weighted scheme. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#IhsToRgb">IhsToRgb</a>: Converts intensity, hue, and saturation (IHS) images into red, green, and blue (RGB) images. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ImageAutocorrelation">ImageAutocorrelation</a>: Performs Moran's I analysis on two or more input images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ImageCorrelation">ImageCorrelation</a>: Performs image correlation on two or more input images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ImageRegression">ImageRegression</a>: Performs image regression analysis on two input images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#ImageStackProfile">ImageStackProfile</a>: Plots an image stack profile (i.e. signature) for a set of points and multispectral images. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#ImpoundmentSizeIndex">ImpoundmentSizeIndex</a>: Calculates the impoundment size resulting from damming a DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#InPlaceAdd">InPlaceAdd</a>: Performs an in-place addition operation (input1 += input2). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#InPlaceDivide">InPlaceDivide</a>: Performs an in-place division operation (input1 /= input2). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#InPlaceMultiply">InPlaceMultiply</a>: Performs an in-place multiplication operation (input1 *= input2). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#InPlaceSubtract">InPlaceSubtract</a>: Performs an in-place subtraction operation (input1 -= input2). Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Increment">Increment</a>: Increases the values of each grid cell in an input raster by 1.0. (see also InPlaceAdd) Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#IntegerDivision">IntegerDivision</a>: Performs an integer division operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#IntegralImage">IntegralImage</a>: Transforms an input image (summed area table) into its integral image equivalent. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Intersect">Intersect</a>: Identifies the parts of features in common between two input vector layers. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#IsNoData">IsNoData</a>: Identifies NoData valued pixels in an image. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Isobasins">Isobasins</a>: Divides a landscape into nearly equal sized drainage basins (i.e. watersheds). Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#JensonSnapPourPoints">JensonSnapPourPoints</a>: Moves outlet points used to specify points of interest in a watershedding operation to the nearest stream cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#JoinTables">JoinTables</a>: Merge a vector's attribute table with another table based on a common field. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#KMeansClustering">KMeansClustering</a>: Performs a k-means clustering operation on a multi-spectral dataset. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#KNearestMeanFilter">KNearestMeanFilter</a>: A k-nearest mean filter is a type of edge-preserving smoothing filter. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#KappaIndex">KappaIndex</a>: Performs a kappa index of agreement (KIA) analysis on two categorical raster files. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#KsTestForNormality">KsTestForNormality</a>: Evaluates whether the values in a raster are normally distributed. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#LaplacianFilter">LaplacianFilter</a>: Performs a Laplacian filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#LaplacianOfGaussianFilter">LaplacianOfGaussianFilter</a>: Performs a Laplacian-of-Gaussian (LoG) filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LasToAscii">LasToAscii</a>: Converts one or more LAS files into ASCII text files. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LasToMultipointShapefile">LasToMultipointShapefile</a>: Converts one or more LAS files into MultipointZ vector Shapefiles. When the input parameter is not specified, the tool grids all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LasToShapefile">LasToShapefile</a>: Converts one or more LAS files into a vector Shapefile of POINT ShapeType. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#LayerFootprint">LayerFootprint</a>: Creates a vector polygon footprint of the area covered by a raster grid or vector layer. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#LeeFilter">LeeFilter</a>: Performs a Lee (Sigma) smoothing filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#LengthOfUpstreamChannels">LengthOfUpstreamChannels</a>: Calculates the total length of channels upstream. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#LessThan">LessThan</a>: Performs a less-than comparison operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarBlockMaximum">LidarBlockMaximum</a>: Creates a block-maximum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarBlockMinimum">LidarBlockMinimum</a>: Creates a block-minimum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarClassifySubset">LidarClassifySubset</a>: Classifies the values in one LiDAR point cloud that correpond with points in a subset cloud. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarColourize">LidarColourize</a>: Adds the red-green-blue colour fields of a LiDAR (LAS) file based on an input image. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarConstructVectorTin">LidarConstructVectorTin</a>: Creates a vector triangular irregular network (TIN) fitted to LiDAR points. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarElevationSlice">LidarElevationSlice</a>: Outputs all of the points within a LiDAR (LAS) point file that lie between a specified elevation range. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarGroundPointFilter">LidarGroundPointFilter</a>: Identifies ground points within LiDAR dataset using a slope-based method. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarHexBinning">LidarHexBinning</a>: Hex-bins a set of LiDAR points. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarHillshade">LidarHillshade</a>: Calculates a hillshade value for points within a LAS file and stores these data in the RGB field. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarHistogram">LidarHistogram</a>: Creates a histogram of LiDAR data. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarIdwInterpolation">LidarIdwInterpolation</a>: Interpolates LAS files using an inverse-distance weighted (IDW) scheme. When the input/output parameters are not specified, the tool interpolates all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarInfo">LidarInfo</a>: Prints information about a LiDAR (LAS) dataset, including header, point return frequency, and classification data and information about the variable length records (VLRs) and geokeys. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarJoin">LidarJoin</a>: Joins multiple LiDAR (LAS) files into a single LAS file. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarKappaIndex">LidarKappaIndex</a>: Performs a kappa index of agreement (KIA) analysis on the classifications of two LAS files. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarNearestNeighbourGridding">LidarNearestNeighbourGridding</a>: Grids LAS files using nearest-neighbour scheme. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarPointDensity">LidarPointDensity</a>: Calculates the spatial pattern of point density for a LiDAR data set. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarPointStats">LidarPointStats</a>: Creates several rasters summarizing the distribution of LAS point data. When the input/output parameters are not specified, the tool works on all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarRansacPlanes">LidarRansacPlanes</a>: Removes outliers (high and low points) in a LiDAR point cloud. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarRemoveDuplicates">LidarRemoveDuplicates</a>: Removes duplicate points from a LiDAR data set. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarRemoveOutliers">LidarRemoveOutliers</a>: Removes outliers (high and low points) in a LiDAR point cloud. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarSegmentationBasedFilter">LidarSegmentationBasedFilter</a>: Identifies ground points within LiDAR point clouds using a segmentation based approach. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarSegmentation">LidarSegmentation</a>: Segments a LiDAR point cloud based on normal vectors. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarThinHighDensity">LidarThinHighDensity</a>: Thins points from high density areas within a LiDAR point cloud. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarThin">LidarThin</a>: Thins a LiDAR point cloud, reducing point density. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarTileFootprint">LidarTileFootprint</a>: Creates a vector polygon of the convex hull of a LiDAR point cloud. When the input/output parameters are not specified, the tool works with all LAS files contained within the working directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarTile">LidarTile</a>: Tiles a LiDAR LAS file into multiple LAS files. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarTinGridding">LidarTinGridding</a>: Creates a raster grid based on a Delaunay triangular irregular network (TIN) fitted to LiDAR points. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#LidarTophatTransform">LidarTophatTransform</a>: Performs a white top-hat transform on a Lidar dataset; as an estimate of height above ground, this is useful for modelling the vegetation canopy. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#LineDetectionFilter">LineDetectionFilter</a>: Performs a line-detection filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#LineIntersections">LineIntersections</a>: Identifies points where the features of two vector line layers intersect. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#LineThinning">LineThinning</a>: Performs line thinning a on Boolean raster image; intended to be used with the RemoveSpurs tool. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#LinearityIndex">LinearityIndex</a>: Calculates the linearity index for vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#LinesToPolygons">LinesToPolygons</a>: Converts vector polylines to polygons. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ListUniqueValues">ListUniqueValues</a>: Lists the unique values contained in a field witin a vector's attribute table. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Ln">Ln</a>: Returns the natural logarithm of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Log10">Log10</a>: Returns the base-10 logarithm of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Log2">Log2</a>: Returns the base-2 logarithm of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#LongProfileFromPoints">LongProfileFromPoints</a>: Plots the longitudinal profiles from flow-paths initiating from a set of vector points. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#LongProfile">LongProfile</a>: Plots the stream longitudinal profiles for one or more rivers. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#LongestFlowpath">LongestFlowpath</a>: Delineates the longest flowpaths for a group of subbasins or watersheds. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#LowestPosition">LowestPosition</a>: Identifies the stack position of the minimum value within a raster stack on a cell-by-cell basis. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#MajorityFilter">MajorityFilter</a>: Assigns each cell in the output grid the most frequently occurring value (mode) in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#MaxAbsoluteOverlay">MaxAbsoluteOverlay</a>: Evaluates the maximum absolute value for each grid cell from a stack of input rasters. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxAnisotropyDevSignature">MaxAnisotropyDevSignature</a>: Calculates the anisotropy in deviation from mean for points over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxAnisotropyDev">MaxAnisotropyDev</a>: Calculates the maximum anisotropy (directionality) in elevation deviation over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxBranchLength">MaxBranchLength</a>: Lindsay and Seibert's (2013) branch length index is used to map drainage divides or ridge lines. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxDifferenceFromMean">MaxDifferenceFromMean</a>: Calculates the maximum difference from mean elevation over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxDownslopeElevChange">MaxDownslopeElevChange</a>: Calculates the maximum downslope change in elevation between a grid cell and its eight downslope neighbors. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxElevDevSignature">MaxElevDevSignature</a>: Calculates the maximum elevation deviation over a range of spatial scales and for a set of points. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MaxElevationDeviation">MaxElevationDeviation</a>: Calculates the maximum elevation deviation over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#MaxOverlay">MaxOverlay</a>: Evaluates the maximum value for each grid cell from a stack of input rasters. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#MaxUpslopeFlowpathLength">MaxUpslopeFlowpathLength</a>: Measures the maximum length of all upslope flowpaths draining each grid cell. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Max">Max</a>: Performs a MAX operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#MaximumFilter">MaximumFilter</a>: Assigns each cell in the output grid the maximum value in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#MeanFilter">MeanFilter</a>: Performs a mean filter (low-pass filter) on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#MedianFilter">MedianFilter</a>: Performs a median filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#Medoid">Medoid</a>: Calculates the medoid for a series of vector features contained in a shapefile. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#MergeLineSegments">MergeLineSegments</a>: Merges vector line segments into larger features. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#MergeTableWithCsv">MergeTableWithCsv</a>: Merge a vector's attribute table with a table contained within a CSV text file. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#MergeVectors">MergeVectors</a>: Combines two or more input vectors of the same ShapeType creating a single, new output vector. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#MinAbsoluteOverlay">MinAbsoluteOverlay</a>: Evaluates the minimum absolute value for each grid cell from a stack of input rasters. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MinDownslopeElevChange">MinDownslopeElevChange</a>: Calculates the minimum downslope change in elevation between a grid cell and its eight downslope neighbors. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#MinMaxContrastStretch">MinMaxContrastStretch</a>: Performs a min-max contrast stretch on an input greytone image. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#MinOverlay">MinOverlay</a>: Evaluates the minimum value for each grid cell from a stack of input rasters. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Min">Min</a>: Performs a MIN operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#MinimumBoundingBox">MinimumBoundingBox</a>: Creates a vector minimum bounding rectangle around vector features. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#MinimumBoundingCircle">MinimumBoundingCircle</a>: Delineates the minimum bounding circle (i.e. smallest enclosing circle) for a group of vectors. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#MinimumBoundingEnvelope">MinimumBoundingEnvelope</a>: Creates a vector axis-aligned minimum bounding rectangle (envelope) around vector features. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#MinimumConvexHull">MinimumConvexHull</a>: Creates a vector convex polygon around vector features. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#MinimumFilter">MinimumFilter</a>: Assigns each cell in the output grid the minimum value in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#ModifiedKMeansClustering">ModifiedKMeansClustering</a>: Performs a modified k-means clustering operation on a multi-spectral dataset. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Modulo">Modulo</a>: Performs a modulo operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#MosaicWithFeathering">MosaicWithFeathering</a>: Mosaics two images together using a feathering technique in overlapping areas to reduce edge-effects. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#Mosaic">Mosaic</a>: Mosaics two or more images together. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#MultiPartToSinglePart">MultiPartToSinglePart</a>: Converts a vector file containing multi-part features into a vector containing only single-part features. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Multiply">Multiply</a>: Performs a multiplication operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MultiscaleRoughnessSignature">MultiscaleRoughnessSignature</a>: Calculates the surface roughness for points over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MultiscaleRoughness">MultiscaleRoughness</a>: Calculates surface roughness over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MultiscaleStdDevNormalsSignature">MultiscaleStdDevNormalsSignature</a>: Calculates the surface roughness for points over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MultiscaleStdDevNormals">MultiscaleStdDevNormals</a>: Calculates surface roughness over a range of spatial scales. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#MultiscaleTopographicPositionImage">MultiscaleTopographicPositionImage</a>: Creates a multiscale topographic position image from three DEVmax rasters of differing spatial scale ranges. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#NarrownessIndex">NarrownessIndex</a>: Calculates the narrowness of raster polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#NearestNeighbourGridding">NearestNeighbourGridding</a>: Creates a raster grid based on a set of vector points and assigns grid values using the nearest neighbour. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Negate">Negate</a>: Changes the sign of values in a raster or the 0-1 values of a Boolean raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#NewRasterFromBase">NewRasterFromBase</a>: Creates a new raster using a base image. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#NormalVectors">NormalVectors</a>: Calculates normal vectors for points within a LAS file and stores these data (XYZ vector components) in the RGB field. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#NormalizedDifferenceIndex">NormalizedDifferenceIndex</a>: Calculate a normalized-difference index (NDI) from two bands of multispectral image data. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#NotEqualTo">NotEqualTo</a>: Performs a not-equal-to comparison operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Not">Not</a>: Performs a logical NOT operator on two Boolean raster images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#NumDownslopeNeighbours">NumDownslopeNeighbours</a>: Calculates the number of downslope neighbours to each grid cell in a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#NumInflowingNeighbours">NumInflowingNeighbours</a>: Computes the number of inflowing neighbours to each cell in an input DEM based on the D8 algorithm. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#NumUpslopeNeighbours">NumUpslopeNeighbours</a>: Calculates the number of upslope neighbours to each grid cell in a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#OlympicFilter">OlympicFilter</a>: Performs an olympic smoothing filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#Opening">Opening</a>: An opening is a mathematical morphology operation involving a dilation (max filter) of an erosion (min filter) set. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Or">Or</a>: Performs a logical OR operator on two Boolean raster images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#PanchromaticSharpening">PanchromaticSharpening</a>: Increases the spatial resolution of image data by combining multispectral bands with panchromatic data. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#PatchOrientation">PatchOrientation</a>: Calculates the orientation of vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#PennockLandformClass">PennockLandformClass</a>: Classifies hillslope zones based on slope, profile curvature, and plan curvature. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#PercentElevRange">PercentElevRange</a>: Calculates percent of elevation range from a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#PercentEqualTo">PercentEqualTo</a>: Calculates the percentage of a raster stack that have cell values equal to an input on a cell-by-cell basis. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#PercentGreaterThan">PercentGreaterThan</a>: Calculates the percentage of a raster stack that have cell values greather than an input on a cell-by-cell basis. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#PercentLessThan">PercentLessThan</a>: Calculates the percentage of a raster stack that have cell values less than an input on a cell-by-cell basis. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#PercentageContrastStretch">PercentageContrastStretch</a>: Performs a percentage linear contrast stretch on input images. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#PercentileFilter">PercentileFilter</a>: Performs a percentile filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#PerimeterAreaRatio">PerimeterAreaRatio</a>: Calculates the perimeter-area ratio of vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#PickFromList">PickFromList</a>: Outputs the value from a raster stack specified by a position raster. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#PlanCurvature">PlanCurvature</a>: Calculates a plan (contour) curvature raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#PolygonArea">PolygonArea</a>: Calculates the area of vector polygons. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#PolygonLongAxis">PolygonLongAxis</a>: This tool can be used to map the long axis of polygon features. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#PolygonPerimeter">PolygonPerimeter</a>: Calculates the perimeter of vector polygons. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#PolygonShortAxis">PolygonShortAxis</a>: This tool can be used to map the short axis of polygon features. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Polygonize">Polygonize</a>: Creates a polygon layer from two or more intersecting line features contained in one or more input vector line files. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#PolygonsToLines">PolygonsToLines</a>: Converts vector polygons to polylines. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Power">Power</a>: Raises the values in grid cells of one rasters, or a constant value, by values in another raster or constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#PrewittFilter">PrewittFilter</a>: Performs a Prewitt edge-detection filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#PrincipalComponentAnalysis">PrincipalComponentAnalysis</a>: Performs a principal component analysis (PCA) on a multi-spectral dataset. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#PrintGeoTiffTags">PrintGeoTiffTags</a>: Prints the tags within a GeoTIFF. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#ProfileCurvature">ProfileCurvature</a>: Calculates a profile curvature raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#Profile">Profile</a>: Plots profiles from digital surface models. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Quantiles">Quantiles</a>: Transforms raster values into quantiles. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#RadiusOfGyration">RadiusOfGyration</a>: Calculates the distance of cells from their polygon's centroid. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#RaiseWalls">RaiseWalls</a>: Raises walls in a DEM along a line or around a polygon, e.g. a watershed. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RandomField">RandomField</a>: Creates an image containing random values. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RandomSample">RandomSample</a>: Creates an image containing randomly located sample grid cells with unique IDs. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#RangeFilter">RangeFilter</a>: Assigns each cell in the output grid the range of values in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#RasterArea">RasterArea</a>: Calculates the area of polygons or classes within a raster image. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#RasterCellAssignment">RasterCellAssignment</a>: Assign row or column number to cells. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RasterHistogram">RasterHistogram</a>: Creates a histogram from raster values. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#RasterStreamsToVector">RasterStreamsToVector</a>: Converts a raster stream file into a vector file. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RasterSummaryStats">RasterSummaryStats</a>: Measures a rasters min, max, average, standard deviation, num. non-nodata cells, and total. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#RasterToVectorLines">RasterToVectorLines</a>: Converts a raster lines features into a vector of the POLYLINE shapetype Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#RasterToVectorPoints">RasterToVectorPoints</a>: Converts a raster dataset to a vector of the POINT shapetype. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#RasterizeStreams">RasterizeStreams</a>: Rasterizes vector streams based on Lindsay (2016) method. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Reciprocal">Reciprocal</a>: Returns the reciprocal (i.e. 1 / z) of values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ReclassEqualInterval">ReclassEqualInterval</a>: Reclassifies the values in a raster image based on equal-ranges. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#ReclassFromFile">ReclassFromFile</a>: Reclassifies the values in a raster image using reclass ranges in a text file. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#Reclass">Reclass</a>: Reclassifies the values in a raster image. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#ReinitializeAttributeTable">ReinitializeAttributeTable</a>: Reinitializes a vector's attribute table deleting all fields but the feature ID (FID). Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#RelatedCircumscribingCircle">RelatedCircumscribingCircle</a>: Calculates the related circumscribing circle of vector polygons. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#RelativeAspect">RelativeAspect</a>: Calculates relative aspect (relative to a user-specified direction) from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#RelativeStreamPowerIndex">RelativeStreamPowerIndex</a>: Calculates the relative stream power index. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#RelativeTopographicPosition">RelativeTopographicPosition</a>: Calculates the relative topographic position index from a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#RemoveOffTerrainObjects">RemoveOffTerrainObjects</a>: Removes off-terrain objects from a raster digital elevation model (DEM). Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#RemovePolygonHoles">RemovePolygonHoles</a>: Removes holes within the features of a vector polygon file. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#RemoveShortStreams">RemoveShortStreams</a>: Removes short first-order streams from a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#RemoveSpurs">RemoveSpurs</a>: Removes the spurs (pruning operation) from a Boolean line image; intended to be used on the output of the LineThinning tool. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#Resample">Resample</a>: Resamples one or more input images into a destination image. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RescaleValueRange">RescaleValueRange</a>: Performs a min-max contrast stretch on an input greytone image. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#RgbToIhs">RgbToIhs</a>: Converts red, green, and blue (RGB) images into intensity, hue, and saturation (IHS) images. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Rho8Pointer">Rho8Pointer</a>: Calculates a stochastic Rho8 flow pointer raster from an input DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#RobertsCrossFilter">RobertsCrossFilter</a>: Performs a Robert's cross edge-detection filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#RootMeanSquareError">RootMeanSquareError</a>: Calculates the RMSE and other accuracy statistics. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Round">Round</a>: Rounds the values in an input raster to the nearest integer value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#RuggednessIndex">RuggednessIndex</a>: Calculates the Riley et al.'s (1999) terrain ruggedness index from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#ScharrFilter">ScharrFilter</a>: Performs a Scharr edge-detection filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#SedimentTransportIndex">SedimentTransportIndex</a>: Calculates the sediment transport index. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/lidar_tools.html#SelectTilesByPolygon">SelectTilesByPolygon</a>: Copies LiDAR tiles overlapping with a polygon into an output directory. Found in <em>LiDAR Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#SetNodataValue">SetNodataValue</a>: Assign a specified value in an input image to the NoData value. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#ShapeComplexityIndexRaster">ShapeComplexityIndexRaster</a>: Calculates the complexity of raster polygons or classes. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_patch_shape_tools.html#ShapeComplexityIndex">ShapeComplexityIndex</a>: Calculates overall polygon shape complexity or irregularity. Found in <em>GIS Analysis → Patch Shape Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#ShreveStreamMagnitude">ShreveStreamMagnitude</a>: Assigns the Shreve stream magnitude to each link in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#SigmoidalContrastStretch">SigmoidalContrastStretch</a>: Performs a sigmoidal contrast stretch on input images. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Sin">Sin</a>: Returns the sine (sin) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#SinglePartToMultiPart">SinglePartToMultiPart</a>: Converts a vector file containing multi-part features into a vector containing only single-part features. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Sinh">Sinh</a>: Returns the hyperbolic sine (sinh) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Sink">Sink</a>: Identifies the depressions in a DEM, giving each feature a unique identifier. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#SlopeVsElevationPlot">SlopeVsElevationPlot</a>: Creates a slope vs. elevation plot for one or more DEMs. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#Slope">Slope</a>: Calculates a slope raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#SmoothVectors">SmoothVectors</a>: Smooths a vector coverage of either a POLYLINE or POLYGON base ShapeType. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#SnapPourPoints">SnapPourPoints</a>: Moves outlet points used to specify points of interest in a watershedding operation to the cell with the highest flow accumulation in its neighbourhood. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#SobelFilter">SobelFilter</a>: Performs a Sobel edge-detection filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#SphericalStdDevOfNormals">SphericalStdDevOfNormals</a>: Calculates the spherical standard deviation of surface normals for a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#SplitColourComposite">SplitColourComposite</a>: This tool splits an RGB colour composite image into seperate multispectral images. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#SplitWithLines">SplitWithLines</a>: Splits the lines or polygons in one layer using the lines in another layer. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#SquareRoot">SquareRoot</a>: Returns the square root of the values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Square">Square</a>: Squares the values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_image_enhancement.html#StandardDeviationContrastStretch">StandardDeviationContrastStretch</a>: Performs a standard-deviation contrast stretch on input images. Found in <em>Image Processing Tools → Image Enhancement</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#StandardDeviationFilter">StandardDeviationFilter</a>: Assigns each cell in the output grid the standard deviation of values in a moving window centred on each grid cell in the input raster. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#StandardDeviationOfSlope">StandardDeviationOfSlope</a>: Calculates the standard deviation of slope from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#StochasticDepressionAnalysis">StochasticDepressionAnalysis</a>: Preforms a stochastic analysis of depressions within a DEM. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#StrahlerOrderBasins">StrahlerOrderBasins</a>: Identifies Strahler-order basins from an input stream network. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StrahlerStreamOrder">StrahlerStreamOrder</a>: Assigns the Strahler stream order to each link in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StreamLinkClass">StreamLinkClass</a>: Identifies the exterior/interior links and nodes in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StreamLinkIdentifier">StreamLinkIdentifier</a>: Assigns a unique identifier to each link in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StreamLinkLength">StreamLinkLength</a>: Estimates the length of each link (or tributary) in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StreamLinkSlope">StreamLinkSlope</a>: Estimates the average slope of each link (or tributary) in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#StreamSlopeContinuous">StreamSlopeContinuous</a>: Estimates the slope of each grid cell in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Subbasins">Subbasins</a>: Identifies the catchments, or sub-basin, draining to each link in a stream network. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Subtract">Subtract</a>: Performs a differencing operation on two rasters or a raster and a constant value. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#SumOverlay">SumOverlay</a>: Calculates the sum for each grid cell from a group of raster images. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#SurfaceAreaRatio">SurfaceAreaRatio</a>: Calculates a the surface area ratio of each grid cell in an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#SymmetricalDifference">SymmetricalDifference</a>: Outputs the features that occur in one of the two vector inputs but not both, i.e. no overlapping features. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Tan">Tan</a>: Returns the tangent (tan) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#TangentialCurvature">TangentialCurvature</a>: Calculates a tangential curvature raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Tanh">Tanh</a>: Returns the hyperbolic tangent (tanh) of each values in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#ThickenRasterLine">ThickenRasterLine</a>: Thickens single-cell wide lines within a raster image. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#TinGridding">TinGridding</a>: Creates a raster grid based on a triangular irregular network (TIN) fitted to vector points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ToDegrees">ToDegrees</a>: Converts a raster from radians to degrees. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ToRadians">ToRadians</a>: Converts a raster from degrees to radians. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#TophatTransform">TophatTransform</a>: Performs either a white or black top-hat transform on an input image. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#TopologicalStreamOrder">TopologicalStreamOrder</a>: Assigns each link in a stream network its topological order. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#TotalCurvature">TotalCurvature</a>: Calculates a total curvature raster from an input DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#TotalFilter">TotalFilter</a>: Performs a total filter on an input image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#TraceDownslopeFlowpaths">TraceDownslopeFlowpaths</a>: Traces downslope flowpaths from one or more target sites (i.e. seed points). Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#TrendSurfaceVectorPoints">TrendSurfaceVectorPoints</a>: Estimates a trend surface from vector points. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#TrendSurface">TrendSurface</a>: Estimates the trend surface of an input raster file. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/stream_network_analysis.html#TributaryIdentifier">TributaryIdentifier</a>: Assigns a unique identifier to each tributary in a stream network. Found in <em>Stream Network Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Truncate">Truncate</a>: Truncates the values in a raster to the desired number of decimal places. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#TurningBandsSimulation">TurningBandsSimulation</a>: Creates an image containing random values based on a turning-bands simulation. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#Union">Union</a>: Splits vector layers at their overlaps, creating a layer containing all the portions from both input and overlay layers. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#UnnestBasins">UnnestBasins</a>: Extract whole watersheds for a set of outlet points. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#UnsharpMasking">UnsharpMasking</a>: An image sharpening technique that enhances edges. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools_filters.html#UserDefinedWeightsFilter">UserDefinedWeightsFilter</a>: Performs a user-defined weights filter on an image. Found in <em>Image Processing Tools → Filters</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#VectorHexBinning">VectorHexBinning</a>: Hex-bins a set of vector points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#VectorLinesToRaster">VectorLinesToRaster</a>: Converts a vector containing polylines into a raster. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#VectorPointsToRaster">VectorPointsToRaster</a>: Converts a vector containing points into a raster. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/data_tools.html#VectorPolygonsToRaster">VectorPolygonsToRaster</a>: Converts a vector containing polygons into a raster. Found in <em>Data Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#Viewshed">Viewshed</a>: Identifies the viewshed for a point or set of points. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#VisibilityIndex">VisibilityIndex</a>: Estimates the relative visibility of sites in a DEM. Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis.html#VoronoiDiagram">VoronoiDiagram</a>: Creates a vector Voronoi diagram for a set of vector points. Found in <em>GIS Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/hydrological_analysis.html#Watershed">Watershed</a>: Identifies the watershed, or drainage basin, draining to a set of target cells. Found in <em>Hydrological Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#WeightedOverlay">WeightedOverlay</a>: Performs a weighted sum on multiple input rasters after converting each image to a common scale. The tool performs a multi-criteria evaluation (MCE). Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/gis_analysis_overlay_tools.html#WeightedSum">WeightedSum</a>: Performs a weighted-sum overlay on multiple input raster images. Found in <em>GIS Analysis → Overlay Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/geomorphometric_analysis.html#WetnessIndex">WetnessIndex</a>: Calculates the topographic wetness index, Ln(A / tan(slope)). Found in <em>Geomorphometric Analysis</em>.</p>
</li>
<li>
<p><a href="available_tools/image_processing_tools.html#WriteFunctionMemoryInsertion">WriteFunctionMemoryInsertion</a>: Performs a write function memory insertion for single-band multi-date change detection. Found in <em>Image Processing Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#Xor">Xor</a>: Performs a logical XOR operator on two Boolean raster images. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ZScores">ZScores</a>: Standardizes the values in an input raster by converting to z-scores. Found in <em>Math and Stats Tools</em>.</p>
</li>
<li>
<p><a href="available_tools/mathand_stats_tools.html#ZonalStatistics">ZonalStatistics</a>: Extracts descriptive statistics for a group of patches in a raster. Found in <em>Math and Stats Tools</em>.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
