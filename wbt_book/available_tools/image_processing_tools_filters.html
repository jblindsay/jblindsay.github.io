<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Filters - WhiteboxTools User Manual</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../preface.html">Preface</a></li><li><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="../install.html"><strong aria-hidden="true">2.</strong> Setting Up WhiteboxTools</a></li><li><a href="../using_whiteboxtools.html"><strong aria-hidden="true">3.</strong> Using WhiteboxTools</a></li><li><ol class="section"><li><a href="../command_prompt.html"><strong aria-hidden="true">3.1.</strong> Command-line interface</a></li><li><a href="../python_scripting/scripting.html"><strong aria-hidden="true">3.2.</strong> Interfacing with Python</a></li><li><ol class="section"><li><a href="../python_scripting/using_whitebox_tools.html"><strong aria-hidden="true">3.2.1.</strong> Using whitebox_tools.py</a></li><li><a href="../python_scripting/tool_output.html"><strong aria-hidden="true">3.2.2.</strong> Handling tool output</a></li><li><a href="../python_scripting/additional_functions.html"><strong aria-hidden="true">3.2.3.</strong> Additional functions</a></li><li><a href="../python_scripting/example.html"><strong aria-hidden="true">3.2.4.</strong> An example Python project</a></li></ol></li><li><a href="../r_interface.html"><strong aria-hidden="true">3.3.</strong> Interfacing with R</a></li><li><a href="../whitebox_tools_runner.html"><strong aria-hidden="true">3.4.</strong> WhiteboxTools Runner</a></li><li><a href="../qgis_plugin.html"><strong aria-hidden="true">3.5.</strong> QGIS plugin</a></li><li><a href="../arcgis_plugin.html"><strong aria-hidden="true">3.6.</strong> ArcGIS plugin</a></li></ol></li><li><a href="../available_tools/index.html"><strong aria-hidden="true">4.</strong> Tools Reference</a></li><li><ol class="section"><li><a href="../available_tools/data_tools.html"><strong aria-hidden="true">4.1.</strong> Data tools</a></li><li><a href="../available_tools/geomorphometric_analysis.html"><strong aria-hidden="true">4.2.</strong> Geomorphometric analysis</a></li><li><a href="../available_tools/gis_analysis.html"><strong aria-hidden="true">4.3.</strong> GIS analysis</a></li><li><ol class="section"><li><a href="../available_tools/gis_analysis_distance_tools.html"><strong aria-hidden="true">4.3.1.</strong> Distance tools</a></li><li><a href="../available_tools/gis_analysis_overlay_tools.html"><strong aria-hidden="true">4.3.2.</strong> Overlay tools</a></li><li><a href="../available_tools/gis_analysis_patch_shape_tools.html"><strong aria-hidden="true">4.3.3.</strong> Patch shape tools</a></li></ol></li><li><a href="../available_tools/hydrological_analysis.html"><strong aria-hidden="true">4.4.</strong> Hydrological analysis</a></li><li><a href="../available_tools/image_processing_tools.html"><strong aria-hidden="true">4.5.</strong> Image processing tools</a></li><li><ol class="section"><li><a href="../available_tools/image_processing_tools_filters.html" class="active"><strong aria-hidden="true">4.5.1.</strong> Filters</a></li><li><a href="../available_tools/image_processing_tools_image_enhancement.html"><strong aria-hidden="true">4.5.2.</strong> Image enchancement</a></li></ol></li><li><a href="../available_tools/lidar_tools.html"><strong aria-hidden="true">4.6.</strong> LiDAR tools</a></li><li><a href="../available_tools/mathand_stats_tools.html"><strong aria-hidden="true">4.7.</strong> Mathematical and statistical analysis</a></li><li><a href="../available_tools/stream_network_analysis.html"><strong aria-hidden="true">4.8.</strong> Stream network analysis</a></li></ol></li><li><a href="../tutorials/index.html"><strong aria-hidden="true">5.</strong> Tutorials</a></li><li><ol class="section"><li><a href="../tutorials/lidar.html"><strong aria-hidden="true">5.1.</strong> Processing LiDAR data</a></li></ol></li><li><a href="../supported_formats.html"><strong aria-hidden="true">6.</strong> Supported Data Formats</a></li><li><a href="../contributing.html"><strong aria-hidden="true">7.</strong> Contributing and Reporting Bugs</a></li><li><a href="../limitations.html"><strong aria-hidden="true">8.</strong> Limitations</a></li><li><a href="../license.html"><strong aria-hidden="true">9.</strong> License</a></li><li><a href="../faq.html"><strong aria-hidden="true">10.</strong> Frequently Asked Questions</a></li><li><a href="../tool_index.html"><strong aria-hidden="true">11.</strong> Tool Index</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">WhiteboxTools User Manual</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#image-processing-tools--filters" id="image-processing-tools--filters"><h1>Image Processing Tools → Filters</h1></a>
<ul>
<li><a href="#AdaptiveFilter">AdaptiveFilter</a></li>
<li><a href="#BilateralFilter">BilateralFilter</a></li>
<li><a href="#ConservativeSmoothingFilter">ConservativeSmoothingFilter</a></li>
<li><a href="#CornerDetection">CornerDetection</a></li>
<li><a href="#DiffOfGaussianFilter">DiffOfGaussianFilter</a></li>
<li><a href="#DiversityFilter">DiversityFilter</a></li>
<li><a href="#EdgePreservingMeanFilter">EdgePreservingMeanFilter</a></li>
<li><a href="#EmbossFilter">EmbossFilter</a></li>
<li><a href="#FastAlmostGaussianFilter">FastAlmostGaussianFilter</a></li>
<li><a href="#GaussianFilter">GaussianFilter</a></li>
<li><a href="#HighPassFilter">HighPassFilter</a></li>
<li><a href="#HighPassMedianFilter">HighPassMedianFilter</a></li>
<li><a href="#KNearestMeanFilter">KNearestMeanFilter</a></li>
<li><a href="#LaplacianFilter">LaplacianFilter</a></li>
<li><a href="#LaplacianOfGaussianFilter">LaplacianOfGaussianFilter</a></li>
<li><a href="#LeeFilter">LeeFilter</a></li>
<li><a href="#LineDetectionFilter">LineDetectionFilter</a></li>
<li><a href="#MajorityFilter">MajorityFilter</a></li>
<li><a href="#MaximumFilter">MaximumFilter</a></li>
<li><a href="#MeanFilter">MeanFilter</a></li>
<li><a href="#MedianFilter">MedianFilter</a></li>
<li><a href="#MinimumFilter">MinimumFilter</a></li>
<li><a href="#OlympicFilter">OlympicFilter</a></li>
<li><a href="#PercentileFilter">PercentileFilter</a></li>
<li><a href="#PrewittFilter">PrewittFilter</a></li>
<li><a href="#RangeFilter">RangeFilter</a></li>
<li><a href="#RobertsCrossFilter">RobertsCrossFilter</a></li>
<li><a href="#ScharrFilter">ScharrFilter</a></li>
<li><a href="#SobelFilter">SobelFilter</a></li>
<li><a href="#StandardDeviationFilter">StandardDeviationFilter</a></li>
<li><a href="#TotalFilter">TotalFilter</a></li>
<li><a href="#UnsharpMasking">UnsharpMasking</a></li>
<li><a href="#UserDefinedWeightsFilter">UserDefinedWeightsFilter</a></li>
</ul>
<p><a name="AdaptiveFilter"></a></p>
<a class="header" href="#adaptivefilter" id="adaptivefilter"><h1>AdaptiveFilter</h1></a>
<p>This tool performs a type of adaptive filter on a raster image. An adaptive filter can be used to reduce
the level of random noise (shot noise) in an image. The algorithm operates by calculating the average
value in a moving window centred on each grid cell. If the absolute difference between the window mean
value and the centre grid cell value is beyond a user-defined threshold (<code>--threshold</code>), the grid cell in the
output image is assigned the mean value, otherwise it is equivalent to the original value. Therefore, the
algorithm only modifies the image where grid cell values are substantially different than their neighbouring
values.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--threshold        </td><td> Difference from mean threshold, in standard deviations</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">adaptive_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    threshold=2.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=AdaptiveFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=DEM.tif -o=output.tif --filter=25 --threshold = 2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/adaptive_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="BilateralFilter"></a></p>
<a class="header" href="#bilateralfilter" id="bilateralfilter"><h1>BilateralFilter</h1></a>
<p>This tool can be used to perform an edge-preserving smoothing filter, or bilateral filter, on an image. A bilateral
filter can be used to emphasize the longer-range variability in an image, effectively acting to smooth the image,
while reducing the edge blurring effect common with other types of smoothing filters. As such, this filter is very
useful for reducing the noise in an image. Bilateral filtering is a non-linear filtering technique introduced by
Tomasi and Manduchi (1998). The algorithm operates by convolving a kernel of weights with each grid cell and its
neighbours in an image. The bilateral filter is related to Gaussian smoothing, in that the weights of the convolution
kernel are partly determined by the 2-dimensional Gaussian (i.e. normal) curve, which gives stronger weighting to
cells nearer the kernel centre. Unlike the <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, however, the bilateral kernel weightings are also
affected by their similarity to the intensity value of the central pixel. Pixels that are very different in intensity
from the central pixel are weighted less, also based on a Gaussian weight distribution. Therefore, this non-linear
convolution filter is determined by the spatial and intensity domains of a localized pixel neighborhood.</p>
<p>The heavier weighting given to nearer and similar-valued pixels makes the bilateral filter an attractive alternative
for image smoothing and noise reduction compared to the much-used Mean filter. The size of the filter is determined
by setting the standard deviation distance parameter (<code>--sigma_dist</code>); the larger the standard deviation the larger
the resulting filter kernel. The standard deviation can be any number in the range 0.5-20 and is specified in the
unit of pixels. The standard deviation intensity parameter (<code>--sigma_int</code>), specified in the same units as the z-values,
determines the intensity domain contribution to kernel weightings.</p>
<p><em>References</em>:</p>
<p>Tomasi, C., &amp; Manduchi, R. (1998, January). Bilateral filtering for gray and color images. In null (p. 839). IEEE.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma_dist       </td><td> Standard deviation in distance in pixels</td></tr>
<tr><td>--sigma_int        </td><td> Standard deviation in intensity in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">bilateral_filter(
    i, 
    output, 
    sigma_dist=0.75, 
    sigma_int=1.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=BilateralFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif ^
--sigma_dist=2.5 --sigma_int=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/bilateral_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="ConservativeSmoothingFilter"></a></p>
<a class="header" href="#conservativesmoothingfilter" id="conservativesmoothingfilter"><h1>ConservativeSmoothingFilter</h1></a>
<p>This tool performs a conservative smoothing filter on a raster image. A conservative smoothing filter can be used
to remove short-range variability in an image, effectively acting to smooth the image. It is particularly useful
for eliminating local spikes and reducing the noise in an image. The algorithm operates by calculating the
minimum and maximum neighbouring values surrounding a grid cell. If the cell at the centre of the kernel is
greater than the calculated maximum value, it is replaced with the maximum value in the output image. Similarly,
if the cell value at the kernel centre is less than the neighbouring minimum value, the corresponding grid cell
in the output image is replaced with the minimum value. This filter tends to alter an image very little compared
with other smoothing filters such as the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>,
<a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, or <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a>.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">conservative_smoothing_filter(
    i, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ConservativeSmoothingFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/conservative_smoothing_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="CornerDetection"></a></p>
<a class="header" href="#cornerdetection" id="cornerdetection"><h1>CornerDetection</h1></a>
<p>This tool identifies corner patterns in boolean images using hit-and-miss pattern matching. Foreground pixels
in the input image (<code>--input</code>) are designated by any positive, non-zero values. Zero-valued and NoData-valued
grid cells are interpreted by the algorithm as background values.</p>
<p><em>Reference</em>:</p>
<p>Fisher, R, Brown, N, Cammas, N, Fitzgibbon, A, Horne, S, Koryllos, K, Murdoch, A, Robertson, J, Sharman, T, Strachan, C,</p>
<ol start="2004">
<li>Hypertext Image Processing Resource. online: http://homepages.inf.ed.ac.uk/rbf/HIPR2/hitmiss.htm</li>
</ol>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input boolean image</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">corner_detection(
    i, 
    output, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=CornerDetection -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/corner_detection.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Simon Gudim</p>
<p><em>Created</em>: 04/05/2017</p>
<p><a name="DiffOfGaussianFilter"></a></p>
<a class="header" href="#diffofgaussianfilter" id="diffofgaussianfilter"><h1>DiffOfGaussianFilter</h1></a>
<p>This tool can be used to perform a difference-of-Gaussians (DoG) filter on a raster image. In digital
image processing, DoG is a feature enhancement algorithm that involves the subtraction of one blurred
version of an image from another, less blurred version of the original. The blurred images are obtained
by applying filters with Gaussian-weighted kernels of differing standard deviations to the input image
(<code>--input</code>). Blurring an image using a Gaussian-weighted kernel suppresses high-frequency spatial
information and emphasizes lower-frequency variation. Subtracting one blurred image from the other
preserves spatial information that lies between the range of frequencies that are preserved in the
two blurred images. Thus, the difference-of-Gaussians is a band-pass filter that discards all but a
specified range of spatial frequencies that are present in the original image.</p>
<p>The algorithm operates by differencing the results of convolving two kernels of weights with each grid
cell and its neighbours in an image. The weights of the convolution kernels are determined by the 2-dimensional
Gaussian (i.e. normal) curve, which gives stronger weighting to cells nearer the kernel centre. The size of
the two convolution kernels are determined by setting the two standard deviation parameters (<code>--sigma1</code> and
<code>--sigma2</code>); the larger the standard deviation the larger the resulting filter kernel. The second standard
deviation should be a larger value than the first, however if this is not the case, the tool will automatically
swap the two parameters. Both standard deviations can range from 0.5-20.</p>
<p>The difference-of-Gaussians filter can be used to emphasize edges present in an image. Other edge-sharpening
filters also operate by enhancing high-frequency detail, but because random noise also has a high spatial
frequency, many of these sharpening filters tend to enhance noise, which can be an undesirable artifact.
The difference-of-Gaussians filter can remove high-frequency noise while emphasizing edges. This filter can,
however, reduce overall image contrast.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#laplacianfilter"><strong>LaplacianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma1           </td><td> Standard deviation distance in pixels</td></tr>
<tr><td>--sigma2           </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">diff_of_gaussian_filter(
    i, 
    output, 
    sigma1=2.0, 
    sigma2=4.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiffOfGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma1=2.0 ^
--sigma2=4.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/dog_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="DiversityFilter"></a></p>
<a class="header" href="#diversityfilter" id="diversityfilter"><h1>DiversityFilter</h1></a>
<p>Assigns each cell in the output grid the number of different values in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">diversity_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=DiversityFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/diversity_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 5, 2017</p>
<p><a name="EdgePreservingMeanFilter"></a></p>
<a class="header" href="#edgepreservingmeanfilter" id="edgepreservingmeanfilter"><h1>EdgePreservingMeanFilter</h1></a>
<p>This tool performs a type of edge-preserving mean filter operation on an input image (<code>--input</code>). The filter, a
type of low-pass filter, can be used to emphasize the longer-range variability in an image, effectively acting to
smooth the image and to reduce noise in the image. The algorithm calculates the average value in a moving window
centred on each grid cell, including in the averaging only the set of neighbouring values for which the absolute
value difference with the centre value is less than a specified threshold value (<code>--threshold</code>). It is, therefore,
similar to the <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, except all neighbours within the threshold difference are equally weighted and
neighbour distance is not accounted for. Filter kernels are always square, and filter size, is specified using
the <code>--filter</code> parameter. This dimensions should be odd, positive integer values, e.g. 3, 5, 7, 9...</p>
<p>This tool works with both greyscale and red-green-blue (RGB) input images. RGB images are decomposed into
intensity-hue-saturation (IHS) and the filter is applied to the intensity channel. If an RGB image is input, the
threshold value must be in the range 0.0-1.0 (more likely less than 0.15), where a value of 1.0 would result in an ordinary mean filter
(<a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>). NoData values in the input image are ignored during filtering.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filter           </td><td> Size of the filter kernel</td></tr>
<tr><td>--threshold        </td><td> Maximum difference in values</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">edge_preserving_mean_filter(
    i, 
    output, 
    threshold, 
    filter=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EdgePreservingMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; --input=image.tif -o=output.tif ^
--filter=5 --threshold=20 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/edge_preserving_mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 24/03/2018</p>
<p><a name="EmbossFilter"></a></p>
<a class="header" href="#embossfilter" id="embossfilter"><h1>EmbossFilter</h1></a>
<p>This tool can be used to perform one of eight 3x3 emboss filters on a raster image. Like the <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a> and
<a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, the <a href="./image_processing_tools_filters.html#embossfilter"><strong>EmbossFilter</strong></a> is often applied in edge-detection applications. While these other two
common edge-detection filters approximate the slope magnitude of the local neighbourhood surrounding each
grid cell, the <a href="./image_processing_tools_filters.html#embossfilter"><strong>EmbossFilter</strong></a> can be used to estimate the directional slope. The kernel weights for each of
the eight available filters are as follows:</p>
<p>North (<code>n</code>)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  -1 </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Northeast (<code>ne</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>East (<code>e</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Southeast (<code>se</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>South (<code>s</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 1  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  -1 </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Southwest (<code>sw</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>West (<code>w</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>Northwest (<code>nw</code>)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> 0  </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>The user must specify the <code>--direction</code>, options include 'n', 's', 'e', 'w', 'ne', 'se', 'nw', 'sw'. The user may also optionally
clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a>, <a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--direction        </td><td> Direction of reflection; options include 'n', 's', 'e', 'w', 'ne', 'se', 'nw', 'sw'</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">emboss_filter(
    i, 
    output, 
    direction=&quot;n&quot;, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=EmbossFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --direction='s' --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/emboss_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="FastAlmostGaussianFilter"></a></p>
<a class="header" href="#fastalmostgaussianfilter" id="fastalmostgaussianfilter"><h1>FastAlmostGaussianFilter</h1></a>
<p>The tool is somewhat modified from Dr. Kovesi's original Matlab code in that it
works with both greyscale and RGB images (decomposes to HSI and uses the intensity
data) and it handles the case of rasters that contain NoData values. This adds
complexity to the original 20 additions and 5 multiplications assertion of the
original paper.</p>
<p>Also note, for small values of sigma (&lt; 1.8), you should probably just use the
regular GaussianFilter tool.</p>
<p><em>Reference</em>:</p>
<p>P. Kovesi 2010 Fast Almost-Gaussian Filtering, Digital Image Computing:
Techniques and Applications (DICTA), 2010 International Conference on.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">fast_almost_gaussian_filter(
    i, 
    output, 
    sigma=1.8, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=FastAlmostGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/fast_almost_gaussian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 19/05/2018</p>
<p><a name="GaussianFilter"></a></p>
<a class="header" href="#gaussianfilter" id="gaussianfilter"><h1>GaussianFilter</h1></a>
<p>This tool can be used to perform a Gaussian filter on a raster image. A Gaussian filter
can be used to emphasize the longer-range variability in an image, effectively acting to
smooth the image. This can be useful for reducing the noise in an image. The algorithm
operates by convolving a kernel of weights with each grid cell and its neighbours in an
image. The weights of the convolution kernel are determined by the 2-dimensional Gaussian
(i.e. normal) curve, which gives stronger weighting to cells nearer the kernel centre. It
is this characteristic that makes the Gaussian filter an attractive alternative for image
smoothing and noise reduction than the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>. The size of the filter is determined
by setting the standard deviation parameter (<code>--sigma</code>), which is in units of grid cells;
the larger the standard deviation the larger the resulting filter kernel. The standard
deviation can be any number in the range 0.5-20.</p>
<p><a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a> works with both greyscale and red-green-blue (RGB) images. RGB images are
decomposed into intensity-hue-saturation (IHS) and the filter is applied to the intensity
channel. NoData values in the input image are ignored during processing.</p>
<p>Like many low-pass filters, Gaussian filtering can signficantly blur well-defined edges in
the input image. The <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> and <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a> offer more robust
feature preservation during image smoothing. <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a> is relatively slow compared to
the <a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a> tool, which offers a fast-running approximatation to a
Gaussian filter for larger kernel sizes.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#fastalmostgaussianfilter"><strong>FastAlmostGaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">gaussian_filter(
    i, 
    output, 
    sigma=0.75, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=GaussianFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/gaussian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="HighPassFilter"></a></p>
<a class="header" href="#highpassfilter" id="highpassfilter"><h1>HighPassFilter</h1></a>
<p>This tool performs a high-pass filter on a raster image. High-pass filters can be used to emphasize
the short-range variability in an image. The algorithm operates essentially by subtracting the value at
the grid cell at the centre of the window from the average value in the surrounding neighbourhood (i.e. window.)</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#highpassmedianfilter"><strong>HighPassMedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">high_pass_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HighPassFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/highpass_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="HighPassMedianFilter"></a></p>
<a class="header" href="#highpassmedianfilter" id="highpassmedianfilter"><h1>HighPassMedianFilter</h1></a>
<p>This tool performs a high-pass median filter on a raster image. High-pass filters can be used to emphasize
the short-range variability in an image. The algorithm operates essentially by subtracting the value at
the grid cell at the centre of the window from the median value in the surrounding neighbourhood (i.e. window.)</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#highpassmedianfilter"><strong>HighPassMedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">high_pass_median_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=HighPassMedianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/highpass_median_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 10/09/2018</p>
<p><a name="KNearestMeanFilter"></a></p>
<a class="header" href="#knearestmeanfilter" id="knearestmeanfilter"><h1>KNearestMeanFilter</h1></a>
<p>This tool performs a k-nearest mean filter on a raster image. A mean filter can be used to emphasize the
longer-range variability in an image, effectively acting to smooth or blur the image. This can be useful
for reducing the noise in an image. The algorithm operates by calculating the average of a specified
number (<em>k</em>) values in a moving window centred on each grid cell. The <em>k</em> values used in the average are
those cells in the window with the nearest intensity values to that of the centre cell. As such, this is
a type of edge-preserving smoothing filter. The <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a> and <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> are
examples of more sophisticated edge-preserving smoothing filters.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>NoData values in the input image are ignored during filtering.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>-k                  </td><td> k-value in pixels; this is the number of nearest-valued neighbours to use</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">k_nearest_mean_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    k=5, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=KNearestMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=9 ^
-k=5
&gt;&gt;./whitebox_tools -r=KNearestMeanFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filtery=7 ^
--filtery=9 -k=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/k_nearest_mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="LaplacianFilter"></a></p>
<a class="header" href="#laplacianfilter" id="laplacianfilter"><h1>LaplacianFilter</h1></a>
<p>This tool can be used to perform a Laplacian filter on a raster image. A Laplacian filter can be used
to emphasize the edges in an image. As such, this filter type is commonly used in edge-detection
applications. The algorithm operates by convolving a kernel of weights with each grid cell and its
neighbours in an image. Four 3x3 sized filters and one 5x5 filter are available for selection. The
weights of the kernels are as follows:</p>
<p>3x3(1)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  4  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>3x3(2)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  5  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 0  </td><td align="center"> -1  </td><td align="center"> 0  </td></tr>
</tbody></table>
<p>3x3(3)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  8  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>3x3(4)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center"> -2  </td><td align="center">  1 </td></tr>
<tr><td align="center"> -2 </td><td align="center">  4  </td><td align="center"> -2 </td></tr>
<tr><td align="center">  1 </td><td align="center"> -2  </td><td align="center">  1 </td></tr>
</tbody></table>
<p>5x5(1)</p>
<table><thead><tr><th align="center"> .  </th><th align="center">  . </th><th>  . </th><th> .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> 17 </td><td align="center"> -2 </td><td align="center"> -1 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
</tbody></table>
<p>5x5(2)</p>
<table><thead><tr><th> .  </th><th>  . </th><th>  . </th><th> .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> 16 </td><td align="center"> -2 </td><td align="center"> -1 </td></tr>
<tr><td align="center">  0 </td><td align="center"> -1 </td><td align="center"> -2 </td><td align="center"> -1 </td><td align="center">  0 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0 </td><td align="center"> -1 </td><td align="center">  0 </td><td align="center">  0 </td></tr>
</tbody></table>
<p>The user must specify the <code>--variant</code>, including '3x3(1)', '3x3(2)', '3x3(3)', '3x3(4)', '5x5(1)', and '5x5(2)'.
The user may also optionally clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 3x3(1), 3x3(2), 3x3(3), 3x3(4), 5x5(1), and 5x5(2) (default is 3x3(1))</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">laplacian_filter(
    i, 
    output, 
    variant=&quot;3x3(1)&quot;, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LaplacianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif ^
--variant='3x3(1)' --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/laplacian_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="LaplacianOfGaussianFilter"></a></p>
<a class="header" href="#laplacianofgaussianfilter" id="laplacianofgaussianfilter"><h1>LaplacianOfGaussianFilter</h1></a>
<p>Performs a Laplacian-of-Gaussian (LoG) filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation in pixels</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">laplacian_of_gaussian_filter(
    i, 
    output, 
    sigma=0.75, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LaplacianOfGaussianFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --sigma=2.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/log_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="LeeFilter"></a></p>
<a class="header" href="#leefilter" id="leefilter"><h1>LeeFilter</h1></a>
<p>Performs a Lee (Sigma) smoothing filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sigma            </td><td> Sigma value should be related to the standarad deviation of the distribution of image speckle noise</td></tr>
<tr><td>-m                  </td><td> M-threshold value the minimum allowable number of pixels within the intensity range</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">lee_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sigma=10.0, 
    m=5.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LeeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=9 --sigma=10.0 ^
-m=5
&gt;&gt;./whitebox_tools -r=LeeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filtery=7 --filtery=9 ^
--sigma=10.0 -m=5 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/lee_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="LineDetectionFilter"></a></p>
<a class="header" href="#linedetectionfilter" id="linedetectionfilter"><h1>LineDetectionFilter</h1></a>
<p>This tool can be used to perform one of four 3x3 line-detection filters on a raster image. These
filters can be used to find one-cell-thick vertical, horizontal, or angled (135-degrees or
45-degrees) lines in an image. Notice that line-finding is a similar application to edge-detection.
Common edge-detection filters include the Sobel and Prewitt filters. The kernel weights for each of
the four line-detection filters are as follows:</p>
<p>'v' (Vertical)</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'h' (Horizontal)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center">  2 </td><td align="center">  2  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'45' (Northeast-Southwest)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> 2  </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>'135' (Northwest-Southeast)</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  2 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center">  2  </td><td align="center"> -1 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center">  2 </td></tr>
</tbody></table>
<p>The user must specify the <code>--variant</code>, including 'v', 'h', '45', and '135', for vertical, horizontal,
northeast-southwest, and northwest-southeast directions respectively. The user may also optionally clip
the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 'v' (vertical), 'h' (horizontal), '45', and '135' (default is 'v')</td></tr>
<tr><td>--absvals          </td><td> Optional flag indicating whether outputs should be absolute values</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">line_detection_filter(
    i, 
    output, 
    variant=&quot;vertical&quot;, 
    absvals=False, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=LineDetectionFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --variant=h ^
--clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/line_detection_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 11/07/2017</p>
<p><a name="MajorityFilter"></a></p>
<a class="header" href="#majorityfilter" id="majorityfilter"><h1>MajorityFilter</h1></a>
<p>This tool performs a majority (or modal) filter on a raster image. A mode filter assigns each
cell in the output grid the most commonly occurring value, i.e. mode, in a moving window centred
on each grid cell. Mode filters should only be applied to input images of a categorical data
scale. The input image should contain integer values but floating point data will be handled using a multiplier.
Because it requires binning the values in the window, a relatively computationally intensive
task, <a href="./image_processing_tools_filters.html#majorityfilter"><strong>MajorityFilter</strong></a> is considerably less efficient than other smoothing filters. This may pose a problem
for large images or large neighbourhoods. Like all WhiteboxTools' filters, however, this tool is
parallelized, benefitting from multi-core processors.</p>
<p>Neighbourhood size, or filter size, is determined by the user-defined x and y dimensions. These dimensions
should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p>NoData values in the input image are ignored during filtering. When the neighbourhood around a grid cell extends
beyond the edge of the grid, NoData values are assigned to these sites.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">majority_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MajorityFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/majority_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 6, 2017</p>
<p><a name="MaximumFilter"></a></p>
<a class="header" href="#maximumfilter" id="maximumfilter"><h1>MaximumFilter</h1></a>
<p>Assigns each cell in the output grid the maximum value in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">maximum_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MaximumFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/max_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="MeanFilter"></a></p>
<a class="header" href="#meanfilter" id="meanfilter"><h1>MeanFilter</h1></a>
<p>This tool performs a mean filter operation on a raster image. A mean filter, a type of low-pass filter, can be
used to emphasize the longer-range variability in an image, effectively acting to smooth the image. This can be
useful for reducing the noise in an image. This tool utilizes an integral image approach (Crow, 1984) to ensure highly
efficient filtering that is invariant to filter size. The algorithm operates by calculating the average value
in a moving window centred on each grid cell.  Neighbourhood size, or filter size, is specified in the x and y
dimensions using the <code>--filterx</code> and <code>--filtery</code> flags. These dimensions should be odd, positive integer values,
e.g. 3, 5, 7, 9... If the kernel filter size is the same in the x and y dimensions, the silent <code>--filter</code> flag
may be used instead (command-line interface only).</p>
<p>Although commonly applied in digital image processing, mean filters are
generally considered to be quite harsh, with respect to their impact on the image, compared to other smoothing
filters such as the edge-preserving smoothing filters including the <a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools_filters.html#olympicfilter"><strong>OlympicFilter</strong></a>,
<a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a> and even <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>.</p>
<p>This tool works with both greyscale and red-green-blue (RGB) images. RGB images are
decomposed into intensity-hue-saturation (IHS) and the filter is applied to the intensity
channel. NoData values in the input image are ignored during filtering. NoData values are assigned to all sites beyond
the raster.</p>
<p><em>Reference</em>:</p>
<p>Crow, F. C. (1984, January). Summed-area tables for texture mapping. In ACM SIGGRAPH computer graphics (Vol. 18, No.
3, pp. 207-212). ACM.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#medianfilter"><strong>MedianFilter</strong></a>, <a href="./image_processing_tools.html#rgbtoihs"><strong>RgbToIhs</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">mean_filter(
    i, 
    output, 
    filterx=3, 
    filtery=3, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MeanFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filterx=25 --filtery=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/mean_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="MedianFilter"></a></p>
<a class="header" href="#medianfilter" id="medianfilter"><h1>MedianFilter</h1></a>
<p>This tool performs a median filter on a raster image. Median filters, a type of low-pass filter, can be used to emphasize
the longer-range variability in an image, effectively acting to smooth the image. This can be useful for reducing the
noise in an image. The algorithm operates by calculating the median value (middle value in a sorted list) in a moving
window centred on each grid cell. Specifically, this tool uses the efficient running-median filtering algorithm of Huang
et al. (1979). The median value is not influenced by anomolously high or low values in the distribution to the extent
that the average is. As such, the median filter is far less sensitive to shot noise in an image than the mean filter.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>flags.
These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>Reference</em>:</p>
<p>Huang, T., Yang, G.J.T.G.Y. and Tang, G., 1979. A fast two-dimensional median filtering algorithm. IEEE
Transactions on Acoustics, Speech, and Signal Processing, 27(1), pp.13-18.</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#bilateralfilter"><strong>BilateralFilter</strong></a>, <a href="./image_processing_tools_filters.html#edgepreservingmeanfilter"><strong>EdgePreservingMeanFilter</strong></a>, <a href="./image_processing_tools_filters.html#gaussianfilter"><strong>GaussianFilter</strong></a>, <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">median_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MedianFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/median_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: July 15, 2017</p>
<p><a name="MinimumFilter"></a></p>
<a class="header" href="#minimumfilter" id="minimumfilter"><h1>MinimumFilter</h1></a>
<p>Assigns each cell in the output grid the minimum value in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">minimum_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=MinimumFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/min_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="OlympicFilter"></a></p>
<a class="header" href="#olympicfilter" id="olympicfilter"><h1>OlympicFilter</h1></a>
<p>This filter is a modification of the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, whereby the highest and lowest values in the kernel are
dropped, and the remaining values are averaged to replace the central pixel. The result is a low-pass smoothing
filter that is more robust than the <a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a>, which is more strongly impacted by the presence of outlier
values. It is named after a system of scoring Olympic events.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#meanfilter"><strong>MeanFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">olympic_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=OlympicFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/olympic_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/06/2017</p>
<p><a name="PercentileFilter"></a></p>
<a class="header" href="#percentilefilter" id="percentilefilter"><h1>PercentileFilter</h1></a>
<p>Performs a percentile filter on an input image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
<tr><td>--sig_digits       </td><td> Number of significant digits</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">percentile_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    sig_digits=2, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PercentileFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=input.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/percentile_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 22, 2017</p>
<p><a name="PrewittFilter"></a></p>
<a class="header" href="#prewittfilter" id="prewittfilter"><h1>PrewittFilter</h1></a>
<p>This tool performs a 3 × 3 Prewitt edge-detection filter on a raster image. The Prewitt filter
is similar to the <a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a>, in that it identifies areas of high slope in the input image through
the calculation of slopes in the x and y directions. The Prewitt edge-detection filter, however, gives less
weight to nearer cell values within the moving window, or kernel. For example, a Prewitt filter uses
the following schemes to calculate x and y slopes:</p>
<p>X-direction slope</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>Y-direction slope</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center">  1  </td><td align="center">  1 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0  </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -1  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>Each grid cell in the output image is assigned the square-root of the squared sum of the x and y slopes.</p>
<p>The user may optionally clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#sobelfilter"><strong>SobelFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">prewitt_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=PrewittFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/prewitt_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="RangeFilter"></a></p>
<a class="header" href="#rangefilter" id="rangefilter"><h1>RangeFilter</h1></a>
<p>Assigns each cell in the output grid the range of values in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">range_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RangeFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/range_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="RobertsCrossFilter"></a></p>
<a class="header" href="#robertscrossfilter" id="robertscrossfilter"><h1>RobertsCrossFilter</h1></a>
<p>Performs a Robert's cross edge-detection filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">roberts_cross_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=RobertsCrossFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/roberts_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="ScharrFilter"></a></p>
<a class="header" href="#scharrfilter" id="scharrfilter"><h1>ScharrFilter</h1></a>
<p>Performs a Scharr edge-detection filter on an image.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">scharr_filter(
    i, 
    output, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=ScharrFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/scharr_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 27, 2017</p>
<p><a name="SobelFilter"></a></p>
<a class="header" href="#sobelfilter" id="sobelfilter"><h1>SobelFilter</h1></a>
<p>This tool performs a 3 × 3 or 5 × 5 Sobel edge-detection filter on a raster image. The Sobel filter
is similar to the <a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a>, in that it identifies areas of high slope in the input image through
the calculation of slopes in the x and y directions. The Sobel edge-detection filter, however, gives more
weight to nearer cell values within the moving window, or kernel. For example, a 3 × 3 Sobel filter uses
the following schemes to calculate x and y slopes:</p>
<p>X-direction slope</p>
<table><thead><tr><th align="center"> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
<tr><td align="center"> -2 </td><td align="center">  0  </td><td align="center"> 2  </td></tr>
<tr><td align="center"> -1 </td><td align="center">  0  </td><td align="center"> 1  </td></tr>
</tbody></table>
<p>Y-direction slope</p>
<table><thead><tr><th> .  </th><th>  .  </th><th>  . </th></tr></thead><tbody>
<tr><td align="center">  1 </td><td align="center">  2  </td><td align="center">  1 </td></tr>
<tr><td align="center">  0 </td><td align="center">  0  </td><td align="center">  0 </td></tr>
<tr><td align="center"> -1 </td><td align="center"> -2  </td><td align="center"> -1 </td></tr>
</tbody></table>
<p>Each grid cell in the output image is assigned the square-root of the squared sum of the x and y slopes.</p>
<p>The user must specify the <code>--variant</code>, including '3x3' and '5x5' variants. The user may also optionally
clip the output image distribution tails by a specified amount (e.g. 1%).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#prewittfilter"><strong>PrewittFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--variant          </td><td> Optional variant value. Options include 3x3 and 5x5 (default is 3x3)</td></tr>
<tr><td>--clip             </td><td> Optional amount to clip the distribution tails by, in percent (default is 0.0)</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">sobel_filter(
    i, 
    output, 
    variant=&quot;3x3&quot;, 
    clip=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=SobelFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --variant=5x5 --clip=1.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/sobel_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 27/06/2017</p>
<p><a name="StandardDeviationFilter"></a></p>
<a class="header" href="#standarddeviationfilter" id="standarddeviationfilter"><h1>StandardDeviationFilter</h1></a>
<p>Assigns each cell in the output grid the standard deviation of values in a moving window centred on each grid cell in the input raster.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">standard_deviation_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=StandardDeviationFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/stdev_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: June 26, 2017</p>
<p><a name="TotalFilter"></a></p>
<a class="header" href="#totalfilter" id="totalfilter"><h1>TotalFilter</h1></a>
<p>This tool performs a total filter on an input image. A total filter assigns to each cell in the output grid
the total (sum) of all values in a moving window centred on each grid cell.</p>
<p>Neighbourhood size, or filter size, is specified in the x and y dimensions using the <code>--filterx</code> and <code>--filtery</code>
flags. These dimensions should be odd, positive integer values (e.g. 3, 5, 7, 9, etc.).</p>
<p><em>See Also</em>:</p>
<p><a href="./image_processing_tools_filters.html#rangefilter"><strong>RangeFilter</strong></a></p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--filterx          </td><td> Size of the filter kernel in the x-direction</td></tr>
<tr><td>--filtery          </td><td> Size of the filter kernel in the y-direction</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">total_filter(
    i, 
    output, 
    filterx=11, 
    filtery=11, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=TotalFilter -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --filter=25 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/total_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 25/06/2017</p>
<p><a name="UnsharpMasking"></a></p>
<a class="header" href="#unsharpmasking" id="unsharpmasking"><h1>UnsharpMasking</h1></a>
<p>An image sharpening technique that enhances edges.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--sigma            </td><td> Standard deviation distance in pixels</td></tr>
<tr><td>--amount           </td><td> A percentage and controls the magnitude of each overshoot</td></tr>
<tr><td>--threshold        </td><td> Controls the minimal brightness change that will be sharpened</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">unsharp_masking(
    i, 
    output, 
    sigma=0.75, 
    amount=100.0, 
    threshold=0.0, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=UnsharpMasking -v --wd=&quot;/path/to/data/&quot; ^
-i=image.tif -o=output.tif --sigma=2.0 --amount=50.0 ^
--threshold=10.0 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/unsharp_masking.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 02/05/2018</p>
<p><a name="UserDefinedWeightsFilter"></a></p>
<a class="header" href="#userdefinedweightsfilter" id="userdefinedweightsfilter"><h1>UserDefinedWeightsFilter</h1></a>
<p>NoData values in the input image are ignored during the convolution operation.
This can lead to unexpected behavior at the edges of images (since the default behavior
is to return NoData when addressing cells beyond the grid edge) and where the grid
contains interior areas of NoData values. Normalization of kernel weights can be useful
for handling the edge effects associated with interior areas of NoData values. When the
normalization option is selected, the sum of the cell value-weight product is divided
by the sum of the weights on a cell-by-cell basis. Therefore, if the kernel at a
particular grid cell contains neighboring cells of NoData values, normalization
effectively re-adjusts the weighting to account for the missing data values. Normalization
also ensures that the output image will possess values within the range of the input
image and allows the user to specify integer value weights in the kernel. However, note
that this implies that the sum of weights should equal one. In some cases, alternative
sums (e.g. zero) are more appropriate, and as such normalization should not be applied
in these cases.</p>
<p><em>Parameters</em>:</p>
<table><thead><tr><th><strong>Flag</strong>            </th><th>  <strong>Description</strong></th></tr></thead><tbody>
<tr><td>-i, --input        </td><td> Input raster file</td></tr>
<tr><td>--weights          </td><td> Input weights file</td></tr>
<tr><td>-o, --output       </td><td> Output raster file</td></tr>
<tr><td>--center           </td><td> Kernel center cell; options include 'center', 'upper-left', 'upper-right', 'lower-left', 'lower-right'</td></tr>
<tr><td>--normalize        </td><td> Normalize kernel weights? This can reduce edge effects and lessen the impact of data gaps (nodata) but is not suited when the kernel weights sum to zero</td></tr>
</tbody></table>
<p><em>Python function</em>:</p>
<pre><code class="language-python">user_defined_weights_filter(
    i, 
    weights, 
    output, 
    center=&quot;center&quot;, 
    normalize=False, 
    callback=default_callback)
</code></pre>
<p><em>Command-line Interface</em>:</p>
<pre><code>&gt;&gt;./whitebox_tools -r=UserDefinedWeightsFilter -v ^
--wd=&quot;/path/to/data/&quot; -i=image.tif --weights=weights.txt ^
-o=output.tif --center=center --normalize 
</code></pre>
<p><a href="https://github.com/jblindsay/whitebox-tools//tree/master/src/tools/image_analysis/user_defined_weights_filter.rs">Source code on GitHub</a></p>
<p><em>Author</em>: Dr. John Lindsay</p>
<p><em>Created</em>: 26/04/2018</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../available_tools/image_processing_tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../available_tools/image_processing_tools_image_enhancement.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../available_tools/image_processing_tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../available_tools/image_processing_tools_image_enhancement.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
